<?xml version="1.0" encoding="UTF-8"?>
<unload unload_date="2017-03-09 20:42:37">
<sys_remote_update_set action="INSERT_OR_UPDATE">
<application display_value="Global">global</application>
<application_name>Global</application_name>
<application_scope>global</application_scope>
<application_version/>
<collisions/>
<commit_date/>
<deleted/>
<description/>
<inserted/>
<name>PE Highcharts - Bar Chart</name>
<origin_sys_id/>
<release_date/>
<remote_sys_id>11f4e0cbdb1932002e5df2b6ae96199a</remote_sys_id>
<state>loaded</state>
<summary/>
<sys_class_name>sys_remote_update_set</sys_class_name>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>a3dbb59fdbd532002e5df2b6ae9619c3</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<update_set display_value=""/>
<update_source display_value=""/>
<updated/>
</sys_remote_update_set>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_widget_14c5b087dbd53200f687dfea5e9619b8</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sp_widget"&gt;&lt;sp_widget action="INSERT_OR_UPDATE"&gt;&lt;client_script&gt;&lt;![CDATA[function($scope, HighchartsConfigService) {
	var c = this;
	var chartType = c.options.bar_type;
	var hcs = new HighchartsConfigService(c.options, chartType, c.data);
	c.chartConfig = hcs.getChartConfig();
	hcs.get();
}]]&gt;&lt;/client_script&gt;&lt;controller_as&gt;c&lt;/controller_as&gt;&lt;css/&gt;&lt;data_table&gt;sp_instance&lt;/data_table&gt;&lt;demo_data&gt;{&amp;#13;
	"data": [&amp;#13;
		["Jan", 31],&amp;#13;
		["Feb", 28],&amp;#13;
		["Mar", 31],&amp;#13;
		["Apr", 30],&amp;#13;
		["May", 31],&amp;#13;
		["Jun", 30],&amp;#13;
		["Jul", 31],&amp;#13;
		["Aug", 31],&amp;#13;
		["Sep", 30],&amp;#13;
		["Oct", 31],&amp;#13;
		["Nov", 30],&amp;#13;
		["Dec", 31]&amp;#13;
	]&amp;#13;
}&lt;/demo_data&gt;&lt;description/&gt;&lt;docs/&gt;&lt;field_list/&gt;&lt;has_preview&gt;true&lt;/has_preview&gt;&lt;id&gt;pe-bar-chart&lt;/id&gt;&lt;internal&gt;false&lt;/internal&gt;&lt;link/&gt;&lt;name&gt;PE Bar Chart&lt;/name&gt;&lt;option_schema&gt;[{"name":"bar_type","label":"Type","type":"choice","choices":[{"label":"Bar","value":"bar"},{"label":"Column","value":"column"}]},{"name":"interval","label":"Update Interval","type":"glide_duration"},{"name":"table","label":"Table","type":"string"},{"name":"fields","label":"Fields","type":"field_list"},{"name":"encoded_query","label":"Encoded Query","type":"string"},{"name":"script_include","label":"Script Include","type":"string"},{"name":"function_name","label":"Process Function Name","type":"string"},{"name":"param1","label":"Parameter 1","type":"string"},{"name":"advance","label":"Set your own Chart object","instructions":"&amp;lt;p&amp;gt;All items in THIS JSON object will override any above selected options. &amp;lt;br/&amp;gt; Options available can be seen here &amp;lt;a targe=\"_blank\" href=\"http://api.highcharts.com/highcharts\"&amp;gt;Highcharts Doc&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;A example of the output is as follows&amp;lt;/p&amp;gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;{\n\ttitle:{\n\t\ttext:\"hello&amp;amp;nbspworld\"\n\t}\n}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;","type":"script"}]&lt;/option_schema&gt;&lt;public&gt;false&lt;/public&gt;&lt;roles/&gt;&lt;script&gt;&lt;![CDATA[(function() {
	var serverOptions = input.options ? input.options : (input.parameters ? input.parameters : {});
	options.bar_type = options.bar_type || serverOptions.bar_type || "bar";
	options.interval = options.interval || serverOptions.interval;
	options.table = options.table || serverOptions.table;
	options.fields = options.fields || serverOptions.fields;
	options.encoded_query = options.encoded_query || serverOptions.encoded_query;
	options.script_include = options.script_include || serverOptions.script_include || "PEHighchartsExample";
	options.function_name = options.function_name || serverOptions.function_name || "getDemoData";
	options.param1 = options.param1 || serverOptions.param1;
	options.advance = options.advance || serverOptions.advance || JSON.stringify({
		"title": {
			"text": "Bar Chart"
		}
	})
})();]]&gt;&lt;/script&gt;&lt;servicenow&gt;false&lt;/servicenow&gt;&lt;sys_class_name&gt;sp_widget&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 20:57:49&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;true&lt;/sys_customer_update&gt;&lt;sys_id&gt;14c5b087dbd53200f687dfea5e9619b8&lt;/sys_id&gt;&lt;sys_mod_count&gt;49&lt;/sys_mod_count&gt;&lt;sys_name&gt;PE Bar Chart&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sp_widget_14c5b087dbd53200f687dfea5e9619b8&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 17:10:16&lt;/sys_updated_on&gt;&lt;template&gt;&lt;![CDATA[&lt;highchart config="c.chartConfig" class="pe-highchart-class pe-highchart-bar-chart"&gt;&lt;/highchart&gt;]]&gt;&lt;/template&gt;&lt;/sp_widget&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>23dbb59fdbd532002e5df2b6ae9619c6</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Bar Chart</target_name>
<type>Widget</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_js_include_64940147db5932002e5df2b6ae961981</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_js_include"><sp_js_include action="INSERT_OR_UPDATE"><display_name>PE Highcharts No Data</display_name><source>local</source><sys_class_name>sp_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:02:41</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>64940147db5932002e5df2b6ae961981</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE Highcharts No Data</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_ui_script display_value="PE Highcharts No Data">26c3854bdbd53200f687dfea5e9619ac</sys_ui_script><sys_update_name>sp_js_include_64940147db5932002e5df2b6ae961981</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:02:41</sys_updated_on><url/></sp_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>27dbb59fdbd532002e5df2b6ae9619c5</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts No Data</target_name>
<type>JS Include</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>m2m_sp_widget_dependency_99b40147db5932002e5df2b6ae961987</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="m2m_sp_widget_dependency"><m2m_sp_widget_dependency action="INSERT_OR_UPDATE"><sp_dependency display_value="PE HighchartsNG">c722c9c3db5932002e5df2b6ae96193b</sp_dependency><sp_widget display_value="PE Bar Chart">14c5b087dbd53200f687dfea5e9619b8</sp_widget><sys_class_name>m2m_sp_widget_dependency</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:03:08</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>99b40147db5932002e5df2b6ae961987</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE HighchartsNG.PE Bar Chart</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>m2m_sp_widget_dependency_99b40147db5932002e5df2b6ae961987</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:03:08</sys_updated_on></m2m_sp_widget_dependency></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>2bdbb59fdbd532002e5df2b6ae9619c4</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE HighchartsNG.PE Bar Chart</target_name>
<type>Widget Dependency</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>m2m_sp_dependency_js_include_ba94cd07db5932002e5df2b6ae9619f5</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="m2m_sp_dependency_js_include"><m2m_sp_dependency_js_include action="INSERT_OR_UPDATE"><order>300</order><sp_dependency display_value="PE Highcharts 5.0.5">5a548d07db5932002e5df2b6ae9619bf</sp_dependency><sp_js_include display_value="PE Highcharts No Data">64940147db5932002e5df2b6ae961981</sp_js_include><sys_class_name>m2m_sp_dependency_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:02:41</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>ba94cd07db5932002e5df2b6ae9619f5</sys_id><sys_mod_count>1</sys_mod_count><sys_name>PE Highcharts 5.0.5.PE Highcharts No Data</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>m2m_sp_dependency_js_include_ba94cd07db5932002e5df2b6ae9619f5</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:02:46</sys_updated_on></m2m_sp_dependency_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>2fdbb59fdbd532002e5df2b6ae9619c3</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5.0.5.PE Highcharts No Data</target_name>
<type>Dependency JS Includes</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ui_script_3793058bdbd53200f687dfea5e9619fb</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_ui_script"&gt;&lt;sys_ui_script action="INSERT_OR_UPDATE"&gt;&lt;active&gt;true&lt;/active&gt;&lt;description/&gt;&lt;global&gt;false&lt;/global&gt;&lt;name&gt;PE highcharts-more&lt;/name&gt;&lt;script&gt;&lt;![CDATA[/*
 Highcharts JS v5.0.5 (2016-11-29)

 (c) 2009-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function(w) {
	"object" === typeof module &amp;&amp; module.exports ? module.exports = w : w(Highcharts)
})(function(w) {
	(function(a) {
		function q(a, b, e) {
			this.init(a, b, e)
		}
		var u = a.each,
			v = a.extend,
			h = a.merge,
			t = a.splat;
		v(q.prototype, {
			init: function(a, b, e) {
				var f = this,
					p = f.defaultOptions;
				f.chart = b;
				f.options = a = h(p, b.angular ? {
					background: {}
				} : void 0, a);
				(a = a.background) &amp;&amp; u([].concat(t(a)).reverse(), function(b) {
					var c, p = e.userOptions;
					c = h(f.defaultBackgroundOptions, b);
					b.backgroundColor &amp;&amp; (c.backgroundColor = b.backgroundColor);
					c.color = c.backgroundColor;
					e.options.plotBands.unshift(c);
					p.plotBands = p.plotBands || [];
					p.plotBands !== e.options.plotBands &amp;&amp; p.plotBands.unshift(c)
				})
			},
			defaultOptions: {
				center: ["50%", "50%"],
				size: "85%",
				startAngle: 0
			},
			defaultBackgroundOptions: {
				className: "highcharts-pane",
				shape: "circle",
				borderWidth: 1,
				borderColor: "#cccccc",
				backgroundColor: {
					linearGradient: {
						x1: 0,
						y1: 0,
						x2: 0,
						y2: 1
					},
					stops: [
						[0, "#ffffff"],
						[1, "#e6e6e6"]
					]
				},
				from: -Number.MAX_VALUE,
				innerRadius: 0,
				to: Number.MAX_VALUE,
				outerRadius: "105%"
			}
		});
		a.Pane = q
	})(w);
	(function(a) {
		var q = a.CenteredSeriesMixin,
			u = a.each,
			v = a.extend,
			h = a.map,
			t = a.merge,
			d = a.noop,
			b = a.Pane,
			e = a.pick,
			f = a.pInt,
			p = a.splat,
			n = a.wrap,
			c, k, l = a.Axis.prototype;
		a = a.Tick.prototype;
		c = {
			getOffset: d,
			redraw: function() {
				this.isDirty = !1
			},
			render: function() {
				this.isDirty = !1
			},
			setScale: d,
			setCategories: d,
			setTitle: d
		};
		k = {
			defaultRadialGaugeOptions: {
				labels: {
					align: "center",
					x: 0,
					y: null
				},
				minorGridLineWidth: 0,
				minorTickInterval: "auto",
				minorTickLength: 10,
				minorTickPosition: "inside",
				minorTickWidth: 1,
				tickLength: 10,
				tickPosition: "inside",
				tickWidth: 2,
				title: {
					rotation: 0
				},
				zIndex: 2
			},
			defaultRadialXOptions: {
				gridLineWidth: 1,
				labels: {
					align: null,
					distance: 15,
					x: 0,
					y: null
				},
				maxPadding: 0,
				minPadding: 0,
				showLastLabel: !1,
				tickLength: 0
			},
			defaultRadialYOptions: {
				gridLineInterpolation: "circle",
				labels: {
					align: "right",
					x: -3,
					y: -2
				},
				showLastLabel: !1,
				title: {
					x: 4,
					text: null,
					rotation: 90
				}
			},
			setOptions: function(b) {
				b = this.options = t(this.defaultOptions, this.defaultRadialOptions, b);
				b.plotBands || (b.plotBands = [])
			},
			getOffset: function() {
				l.getOffset.call(this);
				this.chart.axisOffset[this.side] = 0;
				this.center = this.pane.center =
					q.getCenter.call(this.pane)
			},
			getLinePath: function(b, g) {
				b = this.center;
				var c = this.chart,
					m = e(g, b[2] / 2 - this.offset);
				this.isCircular || void 0 !== g ? g = this.chart.renderer.symbols.arc(this.left + b[0], this.top + b[1], m, m, {
					start: this.startAngleRad,
					end: this.endAngleRad,
					open: !0,
					innerR: 0
				}) : (g = this.postTranslate(this.angleRad, m), g = ["M", b[0] + c.plotLeft, b[1] + c.plotTop, "L", g.x, g.y]);
				return g
			},
			setAxisTranslation: function() {
				l.setAxisTranslation.call(this);
				this.center &amp;&amp; (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) /
					(this.max - this.min || 1) : this.center[2] / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0)
			},
			beforeSetTickPositions: function() {
				if (this.autoConnect = this.isCircular &amp;&amp; void 0 === e(this.userMax, this.options.max) &amp;&amp; this.endAngleRad - this.startAngleRad === 2 * Math.PI) this.max += this.categories &amp;&amp; 1 || this.pointRange || this.closestPointRange || 0
			},
			setAxisSize: function() {
				l.setAxisSize.call(this);
				this.isRadial &amp;&amp; (this.center = this.pane.center = q.getCenter.call(this.pane), this.isCircular &amp;&amp;
					(this.sector = this.endAngleRad - this.startAngleRad), this.len = this.width = this.height = this.center[2] * e(this.sector, 1) / 2)
			},
			getPosition: function(b, g) {
				return this.postTranslate(this.isCircular ? this.translate(b) : this.angleRad, e(this.isCircular ? g : this.translate(b), this.center[2] / 2) - this.offset)
			},
			postTranslate: function(b, g) {
				var e = this.chart,
					c = this.center;
				b = this.startAngleRad + b;
				return {
					x: e.plotLeft + c[0] + Math.cos(b) * g,
					y: e.plotTop + c[1] + Math.sin(b) * g
				}
			},
			getPlotBandPath: function(b, g, c) {
				var m = this.center,
					p = this.startAngleRad,
					l = m[2] / 2,
					r = [e(c.outerRadius, "100%"), c.innerRadius, e(c.thickness, 10)],
					a = Math.min(this.offset, 0),
					k = /%$/,
					n, d = this.isCircular;
				"polygon" === this.options.gridLineInterpolation ? m = this.getPlotLinePath(b).concat(this.getPlotLinePath(g, !0)) : (b = Math.max(b, this.min), g = Math.min(g, this.max), d || (r[0] = this.translate(b), r[1] = this.translate(g)), r = h(r, function(b) {
						k.test(b) &amp;&amp; (b = f(b, 10) * l / 100);
						return b
					}), "circle" !== c.shape &amp;&amp; d ? (b = p + this.translate(b), g = p + this.translate(g)) : (b = -Math.PI / 2, g = 1.5 * Math.PI, n = !0), r[0] -= a, r[2] -=
					a, m = this.chart.renderer.symbols.arc(this.left + m[0], this.top + m[1], r[0], r[0], {
						start: Math.min(b, g),
						end: Math.max(b, g),
						innerR: e(r[1], r[0] - r[2]),
						open: n
					}));
				return m
			},
			getPlotLinePath: function(b, g) {
				var e = this,
					c = e.center,
					f = e.chart,
					p = e.getPosition(b),
					m, l, a;
				e.isCircular ? a = ["M", c[0] + f.plotLeft, c[1] + f.plotTop, "L", p.x, p.y] : "circle" === e.options.gridLineInterpolation ? (b = e.translate(b)) &amp;&amp; (a = e.getLinePath(0, b)) : (u(f.xAxis, function(b) {
					b.pane === e.pane &amp;&amp; (m = b)
				}), a = [], b = e.translate(b), c = m.tickPositions, m.autoConnect &amp;&amp; (c =
					c.concat([c[0]])), g &amp;&amp; (c = [].concat(c).reverse()), u(c, function(g, e) {
					l = m.getPosition(g, b);
					a.push(e ? "L" : "M", l.x, l.y)
				}));
				return a
			},
			getTitlePosition: function() {
				var b = this.center,
					g = this.chart,
					e = this.options.title;
				return {
					x: g.plotLeft + b[0] + (e.x || 0),
					y: g.plotTop + b[1] - {
						high: .5,
						middle: .25,
						low: 0
					}[e.align] * b[2] + (e.y || 0)
				}
			}
		};
		n(l, "init", function(f, g, l) {
			var a = g.angular,
				m = g.polar,
				r = l.isX,
				n = a &amp;&amp; r,
				d, x = g.options,
				h = l.pane || 0;
			if (a) {
				if (v(this, n ? c : k), d = !r) this.defaultRadialOptions = this.defaultRadialGaugeOptions
			} else m &amp;&amp; (v(this,
				k), this.defaultRadialOptions = (d = r) ? this.defaultRadialXOptions : t(this.defaultYAxisOptions, this.defaultRadialYOptions));
			a || m ? (this.isRadial = !0, g.inverted = !1, x.chart.zoomType = null) : this.isRadial = !1;
			f.call(this, g, l);
			n || !a &amp;&amp; !m || (f = this.options, g.panes || (g.panes = []), this.pane = g = g.panes[h] = g.panes[h] || new b(p(x.pane)[h], g, this), g = g.options, this.angleRad = (f.angle || 0) * Math.PI / 180, this.startAngleRad = (g.startAngle - 90) * Math.PI / 180, this.endAngleRad = (e(g.endAngle, g.startAngle + 360) - 90) * Math.PI / 180, this.offset = f.offset ||
				0, this.isCircular = d)
		});
		n(l, "autoLabelAlign", function(b) {
			if (!this.isRadial) return b.apply(this, [].slice.call(arguments, 1))
		});
		n(a, "getPosition", function(b, e, c, f, p) {
			var g = this.axis;
			return g.getPosition ? g.getPosition(c) : b.call(this, e, c, f, p)
		});
		n(a, "getLabelPosition", function(b, g, c, f, p, a, l, k, n) {
			var m = this.axis,
				r = a.y,
				d = 20,
				x = a.align,
				z = (m.translate(this.pos) + m.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360;
			m.isRadial ? (b = m.getPosition(this.pos, m.center[2] / 2 + e(a.distance, -25)), "auto" === a.rotation ? f.attr({
					rotation: z
				}) :
				null === r &amp;&amp; (r = m.chart.renderer.fontMetrics(f.styles.fontSize).b - f.getBBox().height / 2), null === x &amp;&amp; (m.isCircular ? (this.label.getBBox().width &gt; m.len * m.tickInterval / (m.max - m.min) &amp;&amp; (d = 0), x = z &gt; d &amp;&amp; z &lt; 180 - d ? "left" : z &gt; 180 + d &amp;&amp; z &lt; 360 - d ? "right" : "center") : x = "center", f.attr({
					align: x
				})), b.x += a.x, b.y += r) : b = b.call(this, g, c, f, p, a, l, k, n);
			return b
		});
		n(a, "getMarkPath", function(b, e, c, f, a, p, l) {
			var g = this.axis;
			g.isRadial ? (b = g.getPosition(this.pos, g.center[2] / 2 + f), e = ["M", e, c, "L", b.x, b.y]) : e = b.call(this, e, c, f, a, p, l);
			return e
		})
	})(w);
	(function(a) {
		var q = a.each,
			u = a.noop,
			v = a.pick,
			h = a.Series,
			t = a.seriesType,
			d = a.seriesTypes;
		t("arearange", "area", {
			lineWidth: 1,
			marker: null,
			threshold: null,
			tooltip: {
				pointFormat: '\x3cspan style\x3d"color:{series.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.low}\x3c/b\x3e - \x3cb\x3e{point.high}\x3c/b\x3e\x3cbr/\x3e'
			},
			trackByArea: !0,
			dataLabels: {
				align: null,
				verticalAlign: null,
				xLow: 0,
				xHigh: 0,
				yLow: 0,
				yHigh: 0
			},
			states: {
				hover: {
					halo: !1
				}
			}
		}, {
			pointArrayMap: ["low", "high"],
			dataLabelCollections: ["dataLabel",
				"dataLabelUpper"
			],
			toYData: function(b) {
				return [b.low, b.high]
			},
			pointValKey: "low",
			deferTranslatePolar: !0,
			highToXY: function(b) {
				var e = this.chart,
					f = this.xAxis.postTranslate(b.rectPlotX, this.yAxis.len - b.plotHigh);
				b.plotHighX = f.x - e.plotLeft;
				b.plotHigh = f.y - e.plotTop
			},
			translate: function() {
				var b = this,
					e = b.yAxis,
					f = !!b.modifyValue;
				d.area.prototype.translate.apply(b);
				q(b.points, function(a) {
					var p = a.low,
						c = a.high,
						k = a.plotY;
					null === c || null === p ? a.isNull = !0 : (a.plotLow = k, a.plotHigh = e.translate(f ? b.modifyValue(c, a) : c, 0, 1,
						0, 1), f &amp;&amp; (a.yBottom = a.plotHigh))
				});
				this.chart.polar &amp;&amp; q(this.points, function(e) {
					b.highToXY(e)
				})
			},
			getGraphPath: function(b) {
				var e = [],
					f = [],
					a, n = d.area.prototype.getGraphPath,
					c, k, l;
				l = this.options;
				var m = l.step;
				b = b || this.points;
				for (a = b.length; a--;) c = b[a], c.isNull || l.connectEnds || b[a + 1] &amp;&amp; !b[a + 1].isNull || f.push({
						plotX: c.plotX,
						plotY: c.plotY,
						doCurve: !1
					}), k = {
						polarPlotY: c.polarPlotY,
						rectPlotX: c.rectPlotX,
						yBottom: c.yBottom,
						plotX: v(c.plotHighX, c.plotX),
						plotY: c.plotHigh,
						isNull: c.isNull
					}, f.push(k), e.push(k), c.isNull ||
					l.connectEnds || b[a - 1] &amp;&amp; !b[a - 1].isNull || f.push({
						plotX: c.plotX,
						plotY: c.plotY,
						doCurve: !1
					});
				b = n.call(this, b);
				m &amp;&amp; (!0 === m &amp;&amp; (m = "left"), l.step = {
					left: "right",
					center: "center",
					right: "left"
				}[m]);
				e = n.call(this, e);
				f = n.call(this, f);
				l.step = m;
				l = [].concat(b, e);
				this.chart.polar || "M" !== f[0] || (f[0] = "L");
				this.graphPath = l;
				this.areaPath = this.areaPath.concat(b, f);
				l.isArea = !0;
				l.xMap = b.xMap;
				this.areaPath.xMap = b.xMap;
				return l
			},
			drawDataLabels: function() {
				var b = this.data,
					e = b.length,
					f, a = [],
					n = h.prototype,
					c = this.options.dataLabels,
					k = c.align,
					l = c.verticalAlign,
					m = c.inside,
					g, r, d = this.chart.inverted;
				if (c.enabled || this._hasPointLabels) {
					for (f = e; f--;)
						if (g = b[f]) r = m ? g.plotHigh &lt; g.plotLow : g.plotHigh &gt; g.plotLow, g.y = g.high, g._plotY = g.plotY, g.plotY = g.plotHigh, a[f] = g.dataLabel, g.dataLabel = g.dataLabelUpper, g.below = r, d ? k || (c.align = r ? "right" : "left") : l || (c.verticalAlign = r ? "top" : "bottom"), c.x = c.xHigh, c.y = c.yHigh;
					n.drawDataLabels &amp;&amp; n.drawDataLabels.apply(this, arguments);
					for (f = e; f--;)
						if (g = b[f]) r = m ? g.plotHigh &lt; g.plotLow : g.plotHigh &gt; g.plotLow, g.dataLabelUpper =
							g.dataLabel, g.dataLabel = a[f], g.y = g.low, g.plotY = g._plotY, g.below = !r, d ? k || (c.align = r ? "left" : "right") : l || (c.verticalAlign = r ? "bottom" : "top"), c.x = c.xLow, c.y = c.yLow;
					n.drawDataLabels &amp;&amp; n.drawDataLabels.apply(this, arguments)
				}
				c.align = k;
				c.verticalAlign = l
			},
			alignDataLabel: function() {
				d.column.prototype.alignDataLabel.apply(this, arguments)
			},
			setStackedPoints: u,
			getSymbol: u,
			drawPoints: u
		})
	})(w);
	(function(a) {
		var q = a.seriesType;
		q("areasplinerange", "arearange", null, {
			getPointSpline: a.seriesTypes.spline.prototype.getPointSpline
		})
	})(w);
	(function(a) {
		var q = a.defaultPlotOptions,
			u = a.each,
			v = a.merge,
			h = a.noop,
			t = a.pick,
			d = a.seriesType,
			b = a.seriesTypes.column.prototype;
		d("columnrange", "arearange", v(q.column, q.arearange, {
			lineWidth: 1,
			pointRange: null
		}), {
			translate: function() {
				var e = this,
					f = e.yAxis,
					a = e.xAxis,
					n = a.startAngleRad,
					c, k = e.chart,
					l = e.xAxis.isRadial,
					m;
				b.translate.apply(e);
				u(e.points, function(b) {
					var g = b.shapeArgs,
						p = e.options.minPointLength,
						d, h;
					b.plotHigh = m = f.translate(b.high, 0, 1, 0, 1);
					b.plotLow = b.plotY;
					h = m;
					d = t(b.rectPlotY, b.plotY) - m;
					Math.abs(d) &lt;
						p ? (p -= d, d += p, h -= p / 2) : 0 &gt; d &amp;&amp; (d *= -1, h -= d);
					l ? (c = b.barX + n, b.shapeType = "path", b.shapeArgs = {
						d: e.polarArc(h + d, h, c, c + b.pointWidth)
					}) : (g.height = d, g.y = h, b.tooltipPos = k.inverted ? [f.len + f.pos - k.plotLeft - h - d / 2, a.len + a.pos - k.plotTop - g.x - g.width / 2, d] : [a.left - k.plotLeft + g.x + g.width / 2, f.pos - k.plotTop + h + d / 2, d])
				})
			},
			directTouch: !0,
			trackerGroups: ["group", "dataLabelsGroup"],
			drawGraph: h,
			crispCol: b.crispCol,
			drawPoints: b.drawPoints,
			drawTracker: b.drawTracker,
			getColumnMetrics: b.getColumnMetrics,
			animate: function() {
				return b.animate.apply(this,
					arguments)
			},
			polarArc: function() {
				return b.polarArc.apply(this, arguments)
			},
			pointAttribs: b.pointAttribs
		})
	})(w);
	(function(a) {
		var q = a.each,
			u = a.isNumber,
			v = a.merge,
			h = a.pick,
			t = a.pInt,
			d = a.Series,
			b = a.seriesType,
			e = a.TrackerMixin;
		b("gauge", "line", {
			dataLabels: {
				enabled: !0,
				defer: !1,
				y: 15,
				borderRadius: 3,
				crop: !1,
				verticalAlign: "top",
				zIndex: 2,
				borderWidth: 1,
				borderColor: "#cccccc"
			},
			dial: {},
			pivot: {},
			tooltip: {
				headerFormat: ""
			},
			showInLegend: !1
		}, {
			angular: !0,
			directTouch: !0,
			drawGraph: a.noop,
			fixedBox: !0,
			forceDL: !0,
			noSharedTooltip: !0,
			trackerGroups: ["group", "dataLabelsGroup"],
			translate: function() {
				var b = this.yAxis,
					e = this.options,
					a = b.center;
				this.generatePoints();
				q(this.points, function(c) {
					var f = v(e.dial, c.dial),
						l = t(h(f.radius, 80)) * a[2] / 200,
						m = t(h(f.baseLength, 70)) * l / 100,
						g = t(h(f.rearLength, 10)) * l / 100,
						p = f.baseWidth || 3,
						n = f.topWidth || 1,
						d = e.overshoot,
						q = b.startAngleRad + b.translate(c.y, null, null, null, !0);
					u(d) ? (d = d / 180 * Math.PI, q = Math.max(b.startAngleRad - d, Math.min(b.endAngleRad + d, q))) : !1 === e.wrap &amp;&amp; (q = Math.max(b.startAngleRad, Math.min(b.endAngleRad,
						q)));
					q = 180 * q / Math.PI;
					c.shapeType = "path";
					c.shapeArgs = {
						d: f.path || ["M", -g, -p / 2, "L", m, -p / 2, l, -n / 2, l, n / 2, m, p / 2, -g, p / 2, "z"],
						translateX: a[0],
						translateY: a[1],
						rotation: q
					};
					c.plotX = a[0];
					c.plotY = a[1]
				})
			},
			drawPoints: function() {
				var b = this,
					e = b.yAxis.center,
					a = b.pivot,
					c = b.options,
					k = c.pivot,
					l = b.chart.renderer;
				q(b.points, function(e) {
					var a = e.graphic,
						f = e.shapeArgs,
						m = f.d,
						p = v(c.dial, e.dial);
					a ? (a.animate(f), f.d = m) : (e.graphic = l[e.shapeType](f).attr({
						rotation: f.rotation,
						zIndex: 1
					}).addClass("highcharts-dial").add(b.group), e.graphic.attr({
						stroke: p.borderColor ||
							"none",
						"stroke-width": p.borderWidth || 0,
						fill: p.backgroundColor || "#000000"
					}))
				});
				a ? a.animate({
					translateX: e[0],
					translateY: e[1]
				}) : (b.pivot = l.circle(0, 0, h(k.radius, 5)).attr({
					zIndex: 2
				}).addClass("highcharts-pivot").translate(e[0], e[1]).add(b.group), b.pivot.attr({
					"stroke-width": k.borderWidth || 0,
					stroke: k.borderColor || "#cccccc",
					fill: k.backgroundColor || "#000000"
				}))
			},
			animate: function(b) {
				var e = this;
				b || (q(e.points, function(b) {
					var a = b.graphic;
					a &amp;&amp; (a.attr({
						rotation: 180 * e.yAxis.startAngleRad / Math.PI
					}), a.animate({
							rotation: b.shapeArgs.rotation
						},
						e.options.animation))
				}), e.animate = null)
			},
			render: function() {
				this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup);
				d.prototype.render.call(this);
				this.group.clip(this.chart.clipRect)
			},
			setData: function(b, e) {
				d.prototype.setData.call(this, b, !1);
				this.processData();
				this.generatePoints();
				h(e, !0) &amp;&amp; this.chart.redraw()
			},
			drawTracker: e &amp;&amp; e.drawTrackerPoint
		}, {
			setState: function(b) {
				this.state = b
			}
		})
	})(w);
	(function(a) {
		var q = a.each,
			u = a.noop,
			v = a.pick,
			h = a.seriesType,
			t = a.seriesTypes;
		h("boxplot", "column", {
			threshold: null,
			tooltip: {
				pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cb\x3e {series.name}\x3c/b\x3e\x3cbr/\x3eMaximum: {point.high}\x3cbr/\x3eUpper quartile: {point.q3}\x3cbr/\x3eMedian: {point.median}\x3cbr/\x3eLower quartile: {point.q1}\x3cbr/\x3eMinimum: {point.low}\x3cbr/\x3e'
			},
			whiskerLength: "50%",
			fillColor: "#ffffff",
			lineWidth: 1,
			medianWidth: 2,
			states: {
				hover: {
					brightness: -.3
				}
			},
			whiskerWidth: 2
		}, {
			pointArrayMap: ["low", "q1", "median",
				"q3", "high"
			],
			toYData: function(a) {
				return [a.low, a.q1, a.median, a.q3, a.high]
			},
			pointValKey: "high",
			pointAttribs: function(a) {
				var b = this.options,
					e = a &amp;&amp; a.color || this.color;
				return {
					fill: a.fillColor || b.fillColor || e,
					stroke: b.lineColor || e,
					"stroke-width": b.lineWidth || 0
				}
			},
			drawDataLabels: u,
			translate: function() {
				var a = this.yAxis,
					b = this.pointArrayMap;
				t.column.prototype.translate.apply(this);
				q(this.points, function(e) {
					q(b, function(b) {
						null !== e[b] &amp;&amp; (e[b + "Plot"] = a.translate(e[b], 0, 1, 0, 1))
					})
				})
			},
			drawPoints: function() {
				var a =
					this,
					b = a.options,
					e = a.chart.renderer,
					f, p, n, c, k, l, m = 0,
					g, r, h, t, A = !1 !== a.doQuartiles,
					u, y = a.options.whiskerLength;
				q(a.points, function(d) {
					var q = d.graphic,
						z = q ? "animate" : "attr",
						x = d.shapeArgs,
						w = {},
						C = {},
						H = {},
						I = d.color || a.color;
					void 0 !== d.plotY &amp;&amp; (g = x.width, r = Math.floor(x.x), h = r + g, t = Math.round(g / 2), f = Math.floor(A ? d.q1Plot : d.lowPlot), p = Math.floor(A ? d.q3Plot : d.lowPlot), n = Math.floor(d.highPlot), c = Math.floor(d.lowPlot), q || (d.graphic = q = e.g("point").add(a.group), d.stem = e.path().addClass("highcharts-boxplot-stem").add(q),
						y &amp;&amp; (d.whiskers = e.path().addClass("highcharts-boxplot-whisker").add(q)), A &amp;&amp; (d.box = e.path(void 0).addClass("highcharts-boxplot-box").add(q)), d.medianShape = e.path(void 0).addClass("highcharts-boxplot-median").add(q), w.stroke = d.stemColor || b.stemColor || I, w["stroke-width"] = v(d.stemWidth, b.stemWidth, b.lineWidth), w.dashstyle = d.stemDashStyle || b.stemDashStyle, d.stem.attr(w), y &amp;&amp; (C.stroke = d.whiskerColor || b.whiskerColor || I, C["stroke-width"] = v(d.whiskerWidth, b.whiskerWidth, b.lineWidth), d.whiskers.attr(C)), A &amp;&amp; (q =
							a.pointAttribs(d), d.box.attr(q)), H.stroke = d.medianColor || b.medianColor || I, H["stroke-width"] = v(d.medianWidth, b.medianWidth, b.lineWidth), d.medianShape.attr(H)), l = d.stem.strokeWidth() % 2 / 2, m = r + t + l, d.stem[z]({
						d: ["M", m, p, "L", m, n, "M", m, f, "L", m, c]
					}), A &amp;&amp; (l = d.box.strokeWidth() % 2 / 2, f = Math.floor(f) + l, p = Math.floor(p) + l, r += l, h += l, d.box[z]({
						d: ["M", r, p, "L", r, f, "L", h, f, "L", h, p, "L", r, p, "z"]
					})), y &amp;&amp; (l = d.whiskers.strokeWidth() % 2 / 2, n += l, c += l, u = /%$/.test(y) ? t * parseFloat(y) / 100 : y / 2, d.whiskers[z]({
						d: ["M", m - u, n, "L", m + u, n,
							"M", m - u, c, "L", m + u, c
						]
					})), k = Math.round(d.medianPlot), l = d.medianShape.strokeWidth() % 2 / 2, k += l, d.medianShape[z]({
						d: ["M", r, k, "L", h, k]
					}))
				})
			},
			setStackedPoints: u
		})
	})(w);
	(function(a) {
		var q = a.each,
			u = a.noop,
			v = a.seriesType,
			h = a.seriesTypes;
		v("errorbar", "boxplot", {
			color: "#000000",
			grouping: !1,
			linkedTo: ":previous",
			tooltip: {
				pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.low}\x3c/b\x3e - \x3cb\x3e{point.high}\x3c/b\x3e\x3cbr/\x3e'
			},
			whiskerWidth: null
		}, {
			type: "errorbar",
			pointArrayMap: ["low", "high"],
			toYData: function(a) {
				return [a.low, a.high]
			},
			pointValKey: "high",
			doQuartiles: !1,
			drawDataLabels: h.arearange ? function() {
				var a = this.pointValKey;
				h.arearange.prototype.drawDataLabels.call(this);
				q(this.data, function(d) {
					d.y = d[a]
				})
			} : u,
			getColumnMetrics: function() {
				return this.linkedParent &amp;&amp; this.linkedParent.columnMetrics || h.column.prototype.getColumnMetrics.call(this)
			}
		})
	})(w);
	(function(a) {
		var q = a.correctFloat,
			u = a.isNumber,
			v = a.pick,
			h = a.Point,
			t = a.Series,
			d = a.seriesType,
			b = a.seriesTypes;
		d("waterfall", "column", {
			dataLabels: {
				inside: !0
			},
			lineWidth: 1,
			lineColor: "#333333",
			dashStyle: "dot",
			borderColor: "#333333",
			states: {
				hover: {
					lineWidthPlus: 0
				}
			}
		}, {
			pointValKey: "y",
			translate: function() {
				var a = this.options,
					f = this.yAxis,
					d, n, c, k, l, m, g, r, h, t = v(a.minPointLength, 5),
					u = a.threshold,
					w = a.stacking,
					y = 0,
					x = 0;
				b.column.prototype.translate.apply(this);
				g = r = u;
				n = this.points;
				d = 0;
				for (a = n.length; d &lt; a; d++) c = n[d], m = this.processedYData[d], k = c.shapeArgs, h = (l = w &amp;&amp; f.stacks[(this.negStacks &amp;&amp; m &lt; u ? "-" : "") + this.stackKey]) ? l[c.x].points[this.index +
					"," + d] : [0, m], c.isSum ? c.y = q(m) : c.isIntermediateSum &amp;&amp; (c.y = q(m - r)), l = Math.max(g, g + c.y) + h[0], k.y = f.toPixels(l, !0), c.isSum ? (k.y = f.toPixels(h[1], !0), k.height = Math.min(f.toPixels(h[0], !0), f.len) - k.y + y + x) : c.isIntermediateSum ? (k.y = f.toPixels(h[1], !0), k.height = Math.min(f.toPixels(r, !0), f.len) - k.y + y + x, r = h[1]) : (k.height = 0 &lt; m ? f.toPixels(g, !0) - k.y : f.toPixels(g, !0) - f.toPixels(g - m, !0), g += m), 0 &gt; k.height &amp;&amp; (k.y += k.height, k.height *= -1), c.plotY = k.y = Math.round(k.y) - this.borderWidth % 2 / 2, k.height = Math.max(Math.round(k.height),
					.001), c.yBottom = k.y + k.height, k.y -= x, k.height &lt;= t &amp;&amp; (k.height = t, 0 &gt; c.y ? x -= t : y += t), k.y -= y, k = c.plotY - x - y + (c.negative &amp;&amp; 0 &lt;= x ? k.height : 0), this.chart.inverted ? c.tooltipPos[0] = f.len - k : c.tooltipPos[1] = k
			},
			processData: function(b) {
				var a = this.yData,
					e = this.options.data,
					d, c = a.length,
					k, l, m, g, r, h;
				l = k = m = g = this.options.threshold || 0;
				for (h = 0; h &lt; c; h++) r = a[h], d = e &amp;&amp; e[h] ? e[h] : {}, "sum" === r || d.isSum ? a[h] = q(l) : "intermediateSum" === r || d.isIntermediateSum ? a[h] = q(k) : (l += r, k += r), m = Math.min(l, m), g = Math.max(l, g);
				t.prototype.processData.call(this,
					b);
				this.dataMin = m;
				this.dataMax = g
			},
			toYData: function(b) {
				return b.isSum ? 0 === b.x ? null : "sum" : b.isIntermediateSum ? 0 === b.x ? null : "intermediateSum" : b.y
			},
			pointAttribs: function(a, f) {
				var e = this.options.upColor;
				e &amp;&amp; !a.options.color &amp;&amp; (a.color = 0 &lt; a.y ? e : null);
				a = b.column.prototype.pointAttribs.call(this, a, f);
				delete a.dashstyle;
				return a
			},
			getGraphPath: function() {
				return ["M", 0, 0]
			},
			getCrispPath: function() {
				var b = this.data,
					a = b.length,
					d = this.graph.strokeWidth() + this.borderWidth,
					d = Math.round(d) % 2 / 2,
					n = [],
					c, k, l;
				for (l = 1; l &lt; a; l++) k =
					b[l].shapeArgs, c = b[l - 1].shapeArgs, k = ["M", c.x + c.width, c.y + d, "L", k.x, c.y + d], 0 &gt; b[l - 1].y &amp;&amp; (k[2] += c.height, k[5] += c.height), n = n.concat(k);
				return n
			},
			drawGraph: function() {
				t.prototype.drawGraph.call(this);
				this.graph.attr({
					d: this.getCrispPath()
				})
			},
			getExtremes: a.noop
		}, {
			getClassName: function() {
				var b = h.prototype.getClassName.call(this);
				this.isSum ? b += " highcharts-sum" : this.isIntermediateSum &amp;&amp; (b += " highcharts-intermediate-sum");
				return b
			},
			isValid: function() {
				return u(this.y, !0) || this.isSum || this.isIntermediateSum
			}
		})
	})(w);
	(function(a) {
		var q = a.Series,
			u = a.seriesType,
			v = a.seriesTypes;
		u("polygon", "scatter", {
			marker: {
				enabled: !1,
				states: {
					hover: {
						enabled: !1
					}
				}
			},
			stickyTracking: !1,
			tooltip: {
				followPointer: !0,
				pointFormat: ""
			},
			trackByArea: !0
		}, {
			type: "polygon",
			getGraphPath: function() {
				for (var a = q.prototype.getGraphPath.call(this), t = a.length + 1; t--;)(t === a.length || "M" === a[t]) &amp;&amp; 0 &lt; t &amp;&amp; a.splice(t, 0, "z");
				return this.areaPath = a
			},
			drawGraph: function() {
				this.options.fillColor = this.color;
				v.area.prototype.drawGraph.call(this)
			},
			drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
			drawTracker: q.prototype.drawTracker,
			setStackedPoints: a.noop
		})
	})(w);
	(function(a) {
		var q = a.arrayMax,
			u = a.arrayMin,
			v = a.Axis,
			h = a.color,
			t = a.each,
			d = a.isNumber,
			b = a.noop,
			e = a.pick,
			f = a.pInt,
			p = a.Point,
			n = a.Series,
			c = a.seriesType,
			k = a.seriesTypes;
		c("bubble", "scatter", {
			dataLabels: {
				formatter: function() {
					return this.point.z
				},
				inside: !0,
				verticalAlign: "middle"
			},
			marker: {
				lineColor: null,
				lineWidth: 1,
				radius: null,
				states: {
					hover: {
						radiusPlus: 0
					}
				}
			},
			minSize: 8,
			maxSize: "20%",
			softThreshold: !1,
			states: {
				hover: {
					halo: {
						size: 5
					}
				}
			},
			tooltip: {
				pointFormat: "({point.x}, {point.y}), Size: {point.z}"
			},
			turboThreshold: 0,
			zThreshold: 0,
			zoneAxis: "z"
		}, {
			pointArrayMap: ["y", "z"],
			parallelArrays: ["x", "y", "z"],
			trackerGroups: ["group", "dataLabelsGroup"],
			bubblePadding: !0,
			zoneAxis: "z",
			markerAttribs: b,
			pointAttribs: function(b, a) {
				var c = e(this.options.marker.fillOpacity, .5);
				b = n.prototype.pointAttribs.call(this, b, a);
				1 !== c &amp;&amp; (b.fill = h(b.fill).setOpacity(c).get("rgba"));
				return b
			},
			getRadii: function(b, a, e, c) {
				var g, f, d, l = this.zData,
					k = [],
					m = this.options,
					n = "width" !== m.sizeBy,
					r = m.zThreshold,
					p = a - b;
				f = 0;
				for (g = l.length; f &lt; g; f++) d =
					l[f], m.sizeByAbsoluteValue &amp;&amp; null !== d &amp;&amp; (d = Math.abs(d - r), a = Math.max(a - r, Math.abs(b - r)), b = 0), null === d ? d = null : d &lt; b ? d = e / 2 - 1 : (d = 0 &lt; p ? (d - b) / p : .5, n &amp;&amp; 0 &lt;= d &amp;&amp; (d = Math.sqrt(d)), d = Math.ceil(e + d * (c - e)) / 2), k.push(d);
				this.radii = k
			},
			animate: function(b) {
				var a = this.options.animation;
				b || (t(this.points, function(b) {
					var e = b.graphic;
					b = b.shapeArgs;
					e &amp;&amp; b &amp;&amp; (e.attr("r", 1), e.animate({
						r: b.r
					}, a))
				}), this.animate = null)
			},
			translate: function() {
				var b, a = this.data,
					e, c, f = this.radii;
				k.scatter.prototype.translate.call(this);
				for (b = a.length; b--;) e =
					a[b], c = f ? f[b] : 0, d(c) &amp;&amp; c &gt;= this.minPxSize / 2 ? (e.shapeType = "circle", e.shapeArgs = {
						x: e.plotX,
						y: e.plotY,
						r: c
					}, e.dlBox = {
						x: e.plotX - c,
						y: e.plotY - c,
						width: 2 * c,
						height: 2 * c
					}) : e.shapeArgs = e.plotY = e.dlBox = void 0
			},
			drawLegendSymbol: function(b, a) {
				var e = this.chart.renderer,
					c = e.fontMetrics(b.itemStyle &amp;&amp; b.itemStyle.fontSize, a.legendItem).f / 2;
				a.legendSymbol = e.circle(c, b.baseline - c, c).attr({
					zIndex: 3
				}).add(a.legendGroup);
				a.legendSymbol.isMarker = !0
			},
			drawPoints: k.column.prototype.drawPoints,
			alignDataLabel: k.column.prototype.alignDataLabel,
			buildKDTree: b,
			applyZones: b
		}, {
			haloPath: function(b) {
				return p.prototype.haloPath.call(this, this.shapeArgs.r + b)
			},
			ttBelow: !1
		});
		v.prototype.beforePadding = function() {
			var b = this,
				a = this.len,
				c = this.chart,
				k = 0,
				n = a,
				p = this.isXAxis,
				h = p ? "xData" : "yData",
				v = this.min,
				w = {},
				x = Math.min(c.plotWidth, c.plotHeight),
				D = Number.MAX_VALUE,
				E = -Number.MAX_VALUE,
				F = this.max - v,
				B = a / F,
				G = [];
			t(this.series, function(a) {
				var d = a.options;
				!a.bubblePadding || !a.visible &amp;&amp; c.options.chart.ignoreHiddenSeries || (b.allowZoomOutside = !0, G.push(a), p &amp;&amp; (t(["minSize",
					"maxSize"
				], function(b) {
					var a = d[b],
						e = /%$/.test(a),
						a = f(a);
					w[b] = e ? x * a / 100 : a
				}), a.minPxSize = w.minSize, a.maxPxSize = Math.max(w.maxSize, w.minSize), a = a.zData, a.length &amp;&amp; (D = e(d.zMin, Math.min(D, Math.max(u(a), !1 === d.displayNegative ? d.zThreshold : -Number.MAX_VALUE))), E = e(d.zMax, Math.max(E, q(a))))))
			});
			t(G, function(a) {
				var e = a[h],
					c = e.length,
					f;
				p &amp;&amp; a.getRadii(D, E, a.minPxSize, a.maxPxSize);
				if (0 &lt; F)
					for (; c--;) d(e[c]) &amp;&amp; b.dataMin &lt;= e[c] &amp;&amp; e[c] &lt;= b.dataMax &amp;&amp; (f = a.radii[c], k = Math.min((e[c] - v) * B - f, k), n = Math.max((e[c] - v) * B + f, n))
			});
			G.length &amp;&amp; 0 &lt; F &amp;&amp; !this.isLog &amp;&amp; (n -= a, B *= (a + k - n) / a, t([
				["min", "userMin", k],
				["max", "userMax", n]
			], function(a) {
				void 0 === e(b.options[a[0]], b[a[1]]) &amp;&amp; (b[a[0]] += a[2] / B)
			}))
		}
	})(w);
	(function(a) {
		function q(b, a) {
			var e = this.chart,
				d = this.options.animation,
				n = this.group,
				c = this.markerGroup,
				k = this.xAxis.center,
				l = e.plotLeft,
				m = e.plotTop;
			e.polar ? e.renderer.isSVG &amp;&amp; (!0 === d &amp;&amp; (d = {}), a ? (b = {
				translateX: k[0] + l,
				translateY: k[1] + m,
				scaleX: .001,
				scaleY: .001
			}, n.attr(b), c &amp;&amp; c.attr(b)) : (b = {
				translateX: l,
				translateY: m,
				scaleX: 1,
				scaleY: 1
			}, n.animate(b,
				d), c &amp;&amp; c.animate(b, d), this.animate = null)) : b.call(this, a)
		}
		var u = a.each,
			v = a.pick,
			h = a.seriesTypes,
			t = a.wrap,
			d = a.Series.prototype;
		a = a.Pointer.prototype;
		d.searchPointByAngle = function(b) {
			var a = this.chart,
				d = this.xAxis.pane.center;
			return this.searchKDTree({
				clientX: 180 + -180 / Math.PI * Math.atan2(b.chartX - d[0] - a.plotLeft, b.chartY - d[1] - a.plotTop)
			})
		};
		t(d, "buildKDTree", function(b) {
			this.chart.polar &amp;&amp; (this.kdByAngle ? this.searchPoint = this.searchPointByAngle : this.kdDimensions = 2);
			b.apply(this)
		});
		d.toXY = function(b) {
			var a,
				d = this.chart,
				p = b.plotX;
			a = b.plotY;
			b.rectPlotX = p;
			b.rectPlotY = a;
			a = this.xAxis.postTranslate(b.plotX, this.yAxis.len - a);
			b.plotX = b.polarPlotX = a.x - d.plotLeft;
			b.plotY = b.polarPlotY = a.y - d.plotTop;
			this.kdByAngle ? (d = (p / Math.PI * 180 + this.xAxis.pane.options.startAngle) % 360, 0 &gt; d &amp;&amp; (d += 360), b.clientX = d) : b.clientX = b.plotX
		};
		h.spline &amp;&amp; t(h.spline.prototype, "getPointSpline", function(b, a, d, p) {
			var e, c, f, l, m, g, h;
			this.chart.polar ? (e = d.plotX, c = d.plotY, b = a[p - 1], f = a[p + 1], this.connectEnds &amp;&amp; (b || (b = a[a.length - 2]), f || (f = a[1])), b &amp;&amp; f &amp;&amp;
				(l = b.plotX, m = b.plotY, a = f.plotX, g = f.plotY, l = (1.5 * e + l) / 2.5, m = (1.5 * c + m) / 2.5, f = (1.5 * e + a) / 2.5, h = (1.5 * c + g) / 2.5, a = Math.sqrt(Math.pow(l - e, 2) + Math.pow(m - c, 2)), g = Math.sqrt(Math.pow(f - e, 2) + Math.pow(h - c, 2)), l = Math.atan2(m - c, l - e), m = Math.atan2(h - c, f - e), h = Math.PI / 2 + (l + m) / 2, Math.abs(l - h) &gt; Math.PI / 2 &amp;&amp; (h -= Math.PI), l = e + Math.cos(h) * a, m = c + Math.sin(h) * a, f = e + Math.cos(Math.PI + h) * g, h = c + Math.sin(Math.PI + h) * g, d.rightContX = f, d.rightContY = h), p ? (d = ["C", b.rightContX || b.plotX, b.rightContY || b.plotY, l || e, m || c, e, c], b.rightContX = b.rightContY =
					null) : d = ["M", e, c]) : d = b.call(this, a, d, p);
			return d
		});
		t(d, "translate", function(b) {
			var a = this.chart;
			b.call(this);
			if (a.polar &amp;&amp; (this.kdByAngle = a.tooltip &amp;&amp; a.tooltip.shared, !this.preventPostTranslate))
				for (b = this.points, a = b.length; a--;) this.toXY(b[a])
		});
		t(d, "getGraphPath", function(b, a) {
			var e = this,
				d, h;
			if (this.chart.polar) {
				a = a || this.points;
				for (d = 0; d &lt; a.length; d++)
					if (!a[d].isNull) {
						h = d;
						break
					}!1 !== this.options.connectEnds &amp;&amp; void 0 !== h &amp;&amp; (this.connectEnds = !0, a.splice(a.length, 0, a[h]));
				u(a, function(a) {
					void 0 === a.polarPlotY &amp;&amp;
						e.toXY(a)
				})
			}
			return b.apply(this, [].slice.call(arguments, 1))
		});
		t(d, "animate", q);
		h.column &amp;&amp; (h = h.column.prototype, h.polarArc = function(a, e, d, h) {
			var b = this.xAxis.center,
				c = this.yAxis.len;
			return this.chart.renderer.symbols.arc(b[0], b[1], c - e, null, {
				start: d,
				end: h,
				innerR: c - v(a, c)
			})
		}, t(h, "animate", q), t(h, "translate", function(a) {
			var b = this.xAxis,
				d = b.startAngleRad,
				h, n, c;
			this.preventPostTranslate = !0;
			a.call(this);
			if (b.isRadial)
				for (h = this.points, c = h.length; c--;) n = h[c], a = n.barX + d, n.shapeType = "path", n.shapeArgs = {
					d: this.polarArc(n.yBottom,
						n.plotY, a, a + n.pointWidth)
				}, this.toXY(n), n.tooltipPos = [n.plotX, n.plotY], n.ttBelow = n.plotY &gt; b.center[1]
		}), t(h, "alignDataLabel", function(a, e, f, h, n, c) {
			this.chart.polar ? (a = e.rectPlotX / Math.PI * 180, null === h.align &amp;&amp; (h.align = 20 &lt; a &amp;&amp; 160 &gt; a ? "left" : 200 &lt; a &amp;&amp; 340 &gt; a ? "right" : "center"), null === h.verticalAlign &amp;&amp; (h.verticalAlign = 45 &gt; a || 315 &lt; a ? "bottom" : 135 &lt; a &amp;&amp; 225 &gt; a ? "top" : "middle"), d.alignDataLabel.call(this, e, f, h, n, c)) : a.call(this, e, f, h, n, c)
		}));
		t(a, "getCoordinates", function(a, e) {
			var b = this.chart,
				d = {
					xAxis: [],
					yAxis: []
				};
			b.polar ?
				u(b.axes, function(a) {
					var c = a.isXAxis,
						f = a.center,
						h = e.chartX - f[0] - b.plotLeft,
						f = e.chartY - f[1] - b.plotTop;
					d[c ? "xAxis" : "yAxis"].push({
						axis: a,
						value: a.translate(c ? Math.PI - Math.atan2(h, f) : Math.sqrt(Math.pow(h, 2) + Math.pow(f, 2)), !0)
					})
				}) : d = a.call(this, e);
			return d
		})
	})(w)
});]]&gt;&lt;/script&gt;&lt;script_name/&gt;&lt;sys_class_name&gt;sys_ui_script&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 21:58:23&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;false&lt;/sys_customer_update&gt;&lt;sys_id&gt;3793058bdbd53200f687dfea5e9619fb&lt;/sys_id&gt;&lt;sys_mod_count&gt;2&lt;/sys_mod_count&gt;&lt;sys_name&gt;PE highcharts-more&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_ui_script_3793058bdbd53200f687dfea5e9619fb&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 06:06:26&lt;/sys_updated_on&gt;&lt;use_scoped_format&gt;false&lt;/use_scoped_format&gt;&lt;/sys_ui_script&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>2fdbb59fdbd532002e5df2b6ae9619c6</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE highcharts-more</target_name>
<type>UI Script</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ws_query_parameter_dfdc560bdbd932002e5df2b6ae961979</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ws_query_parameter"><sys_ws_query_parameter action="INSERT_OR_UPDATE"><example_value/><name>param1</name><required>false</required><short_description/><sys_class_name>sys_ws_query_parameter</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-09 04:28:23</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>dfdc560bdbd932002e5df2b6ae961979</sys_id><sys_mod_count>0</sys_mod_count><sys_name>param1</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>sys_ws_query_parameter_dfdc560bdbd932002e5df2b6ae961979</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-09 04:28:23</sys_updated_on><web_service_definition display_value="PE Highcharts Helper">226c520bdbd932002e5df2b6ae961978</web_service_definition></sys_ws_query_parameter></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>37dbb59fdbd532002e5df2b6ae9619c8</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>param1</target_name>
<type>Scripted REST Query Parameter</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ws_definition_226c520bdbd932002e5df2b6ae961978</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ws_definition"><sys_ws_definition action="INSERT_OR_UPDATE"><active>true</active><base_uri>/api/snc/pe_highcharts_helper</base_uri><consumes>application/json,application/xml,text/xml</consumes><consumes_customized>false</consumes_customized><default_version>No active default version</default_version><doc_link/><enforce_acl/><is_versioned>false</is_versioned><name>PE Highcharts Helper</name><namespace>snc</namespace><produces>application/json,application/xml,text/xml</produces><produces_customized>false</produces_customized><service_id>pe_highcharts_helper</service_id><short_description/><sys_class_name>sys_ws_definition</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-09 04:26:20</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>226c520bdbd932002e5df2b6ae961978</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE Highcharts Helper</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>sys_ws_definition_226c520bdbd932002e5df2b6ae961978</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-09 04:26:20</sys_updated_on></sys_ws_definition></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>3bdbb59fdbd532002e5df2b6ae9619c7</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts Helper</target_name>
<type>Scripted REST API</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_js_include_6043c507db5932002e5df2b6ae96196c</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_js_include"><sp_js_include action="INSERT_OR_UPDATE"><display_name>PE Highcharts 5_0_5</display_name><source>local</source><sys_class_name>sp_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 21:56:59</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>6043c507db5932002e5df2b6ae96196c</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE Highcharts 5_0_5</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_ui_script display_value="PE Highcharts 5_0_5">5752058bdbd53200f687dfea5e9619f8</sys_ui_script><sys_update_name>sp_js_include_6043c507db5932002e5df2b6ae96196c</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 21:56:59</sys_updated_on><url/></sp_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>63dbb59fdbd532002e5df2b6ae9619c5</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5_0_5</target_name>
<type>JS Include</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>m2m_sp_widget_dependency_91b40147db5932002e5df2b6ae961987</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="m2m_sp_widget_dependency"><m2m_sp_widget_dependency action="INSERT_OR_UPDATE"><sp_dependency display_value="PE Highcharts 5.0.5">5a548d07db5932002e5df2b6ae9619bf</sp_dependency><sp_widget display_value="PE Bar Chart">14c5b087dbd53200f687dfea5e9619b8</sp_widget><sys_class_name>m2m_sp_widget_dependency</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:03:08</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>91b40147db5932002e5df2b6ae961987</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE Highcharts 5.0.5.PE Bar Chart</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>m2m_sp_widget_dependency_91b40147db5932002e5df2b6ae961987</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:03:08</sys_updated_on></m2m_sp_widget_dependency></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>67dbb59fdbd532002e5df2b6ae9619c4</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5.0.5.PE Bar Chart</target_name>
<type>Widget Dependency</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>m2m_sp_dependency_js_include_ba84cd07db5932002e5df2b6ae961987</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="m2m_sp_dependency_js_include"><m2m_sp_dependency_js_include action="INSERT_OR_UPDATE"><order>200</order><sp_dependency display_value="PE Highcharts 5.0.5">5a548d07db5932002e5df2b6ae9619bf</sp_dependency><sp_js_include display_value="PE Highcharts Export">9084cd07db5932002e5df2b6ae9619f0</sp_js_include><sys_class_name>m2m_sp_dependency_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:02:25</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>ba84cd07db5932002e5df2b6ae961987</sys_id><sys_mod_count>1</sys_mod_count><sys_name>PE Highcharts 5.0.5.PE Highcharts Export</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>m2m_sp_dependency_js_include_ba84cd07db5932002e5df2b6ae961987</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:02:30</sys_updated_on></m2m_sp_dependency_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>6bdbb59fdbd532002e5df2b6ae9619c3</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5.0.5.PE Highcharts Export</target_name>
<type>Dependency JS Includes</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ui_script_26c3854bdbd53200f687dfea5e9619ac</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_ui_script"&gt;&lt;sys_ui_script action="INSERT_OR_UPDATE"&gt;&lt;active&gt;true&lt;/active&gt;&lt;description/&gt;&lt;global&gt;false&lt;/global&gt;&lt;name&gt;PE Highcharts No Data&lt;/name&gt;&lt;script&gt;&lt;![CDATA[/*
 Highcharts JS v4.2.6 (2016-08-02)
 Plugin for displaying a message when there is no data visible in chart.

 (c) 2010-2016 Highsoft AS
 Author: Oystein Moseng
 License: www.highcharts.com/license
*/
(function(a) {
	typeof module === "object" &amp;&amp; module.exports ? module.exports = a : a(Highcharts)
})(function(a) {
	function h() {
		return !!this.points.length
	}

	function d() {
		this.hasData() ? this.hideNoData() : this.showNoData()
	}
	var e = a.seriesTypes,
		c = a.Chart.prototype,
		f = a.getOptions(),
		g = a.extend,
		i = a.each;
	g(f.lang, {
		noData: "No data to display"
	});
	f.noData = {
		position: {
			x: 0,
			y: 0,
			align: "center",
			verticalAlign: "middle"
		},
		attr: {},
		style: {
			fontWeight: "bold",
			fontSize: "12px",
			color: "#60606a"
		}
	};
	i(["pie", "gauge", "waterfall", "bubble", "treemap"],
		function(b) {
			if (e[b]) e[b].prototype.hasData = h
		});
	a.Series.prototype.hasData = function() {
		return this.visible &amp;&amp; this.dataMax !== void 0 &amp;&amp; this.dataMin !== void 0
	};
	c.showNoData = function(b) {
		var a = this.options,
			b = b || a.lang.noData,
			a = a.noData;
		if (!this.noDataLabel) this.noDataLabel = this.renderer.label(b, 0, 0, null, null, null, a.useHTML, null, "no-data").attr(a.attr).css(a.style).add(), this.noDataLabel.align(g(this.noDataLabel.getBBox(), a.position), !1, "plotBox")
	};
	c.hideNoData = function() {
		if (this.noDataLabel) this.noDataLabel =
			this.noDataLabel.destroy()
	};
	c.hasData = function() {
		for (var a = this.series, c = a.length; c--;)
			if (a[c].hasData() &amp;&amp; !a[c].options.isInternal) return !0;
		return !1
	};
	c.callbacks.push(function(b) {
		a.addEvent(b, "load", d);
		a.addEvent(b, "redraw", d)
	})
});]]&gt;&lt;/script&gt;&lt;script_name/&gt;&lt;sys_class_name&gt;sys_ui_script&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 21:59:08&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;false&lt;/sys_customer_update&gt;&lt;sys_id&gt;26c3854bdbd53200f687dfea5e9619ac&lt;/sys_id&gt;&lt;sys_mod_count&gt;2&lt;/sys_mod_count&gt;&lt;sys_name&gt;PE Highcharts No Data&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_ui_script_26c3854bdbd53200f687dfea5e9619ac&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 06:06:19&lt;/sys_updated_on&gt;&lt;use_scoped_format&gt;false&lt;/use_scoped_format&gt;&lt;/sys_ui_script&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>6bdbb59fdbd532002e5df2b6ae9619c6</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts No Data</target_name>
<type>UI Script</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_js_include_b3244d07db5932002e5df2b6ae96197e</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_js_include"><sp_js_include action="INSERT_OR_UPDATE"><display_name>PE highcharts-ng</display_name><source>local</source><sys_class_name>sp_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:00:58</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>b3244d07db5932002e5df2b6ae96197e</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE highcharts-ng</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_ui_script display_value="PE highcharts-ng">b9d1058bdbd53200f687dfea5e9619f6</sys_ui_script><sys_update_name>sp_js_include_b3244d07db5932002e5df2b6ae96197e</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:00:58</sys_updated_on><url/></sp_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>6fdbb59fdbd532002e5df2b6ae9619c5</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE highcharts-ng</target_name>
<type>JS Include</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ws_query_parameter_bdbc160bdbd932002e5df2b6ae961962</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ws_query_parameter"><sys_ws_query_parameter action="INSERT_OR_UPDATE"><example_value>process</example_value><name>function</name><required>false</required><short_description/><sys_class_name>sys_ws_query_parameter</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-09 04:27:50</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>bdbc160bdbd932002e5df2b6ae961962</sys_id><sys_mod_count>0</sys_mod_count><sys_name>function</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>sys_ws_query_parameter_bdbc160bdbd932002e5df2b6ae961962</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-09 04:27:50</sys_updated_on><web_service_definition display_value="PE Highcharts Helper">226c520bdbd932002e5df2b6ae961978</web_service_definition></sys_ws_query_parameter></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>73dbb59fdbd532002e5df2b6ae9619c8</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>function</target_name>
<type>Scripted REST Query Parameter</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ui_script_b9d1058bdbd53200f687dfea5e9619f6</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_ui_script"&gt;&lt;sys_ui_script action="INSERT_OR_UPDATE"&gt;&lt;active&gt;true&lt;/active&gt;&lt;description/&gt;&lt;global&gt;false&lt;/global&gt;&lt;name&gt;PE highcharts-ng&lt;/name&gt;&lt;script&gt;&lt;![CDATA[if (typeof module !== 'undefined' &amp;&amp; typeof exports !== 'undefined' &amp;&amp; module.exports === exports) {
	module.exports = 'highcharts-ng';
}

(function() {

	'use strict';
	/*global angular: false, Highcharts: false */

	angular.module('highcharts-ng', [])
		.provider('highchartsNG', highchartsNGProvider)
		.directive('highchart', ['highchartsNG', '$timeout', highchart])
		.factory('HighchartsConfigService', ['$interval', '$http', '$q', HighchartsConfigService]);

	function highchartsNGProvider() {
		var modules = [];
		var basePath = false;
		var lazyLoad = false;
		return {
			HIGHCHART: 'highcharts.js',
			HIGHSTOCK: 'stock/highstock.js',
			basePath: function(p) {
				basePath = p;
			},
			lazyLoad: function(list) {
				if (list === undefined) {
					modules = [this.HIGHCHART];
				} else {
					modules = list;
				}
				lazyLoad = true;
			},
			$get: ['$window', '$rootScope', function($window, $rootScope) {
				if (!basePath) {
					basePath = (window.location.protocol === 'https:' ? 'https' : 'http') + '://code.highcharts.com/';
				}
				return highchartsNG($window, $rootScope, lazyLoad, basePath, modules);
			}]
		};
	}

	function highchartsNG($window, $rootScope, lazyload, basePath, modules) {
		var readyQueue = [];
		var loading = false;
		return {
			lazyLoad: lazyload,
			ready: function(callback, thisArg) {
				if (typeof $window.Highcharts !== 'undefined' || !lazyload) {
					callback();
				} else {
					readyQueue.push([callback, thisArg]);
					if (loading) {
						return;
					}
					loading = true;
					var self = this;
					if (typeof jQuery === 'undefined') {
						modules.unshift('adapters/standalone-framework.js');
					}
					var doWork = function() {
						if (modules.length === 0) {
							loading = false;
							$rootScope.$apply(function() {
								angular.forEach(readyQueue, function(e) {
									// invoke callback passing 'thisArg'
									e[0].apply(e[1], []);
								});
							});
						} else {
							var s = modules.shift();
							self.loadScript(s, doWork);
						}
					};
					doWork();
				}
			},
			loadScript: function(path, callback) {
				var s = document.createElement('script');
				s.type = 'text/javascript';
				s.src = basePath + path;
				s.onload = callback;
				document.getElementsByTagName('body')[0].appendChild(s);
			},
			//IE8 support
			indexOf: function(arr, find, i /*opt*/ ) {
				if (i === undefined) i = 0;
				if (i &lt; 0) i += arr.length;
				if (i &lt; 0) i = 0;
				for (var n = arr.length; i &lt; n; i++)
					if (i in arr &amp;&amp; arr[i] === find)
						return i;
				return -1;
			},

			prependMethod: function(obj, method, func) {
				var original = obj[method];
				obj[method] = function() {
					var args = Array.prototype.slice.call(arguments);
					func.apply(this, args);
					if (original) {
						return original.apply(this, args);
					} else {
						return;
					}

				};
			},

			deepExtend: function deepExtend(destination, source) {
				//Slightly strange behaviour in edge cases (e.g. passing in non objects)
				//But does the job for current use cases.
				if (angular.isArray(source)) {
					destination = angular.isArray(destination) ? destination : [];
					for (var i = 0; i &lt; source.length; i++) {
						destination[i] = deepExtend(destination[i] || {}, source[i]);
					}
				} else if (angular.isObject(source)) {
					destination = angular.isObject(destination) ? destination : {};
					for (var property in source) {
						destination[property] = deepExtend(destination[property] || {}, source[property]);
					}
				} else {
					destination = source;
				}
				return destination;
			}
		};
	}

	function highchart(highchartsNGUtils, $timeout) {

		// acceptable shared state
		var seriesId = 0;
		var ensureIds = function(series) {
			var changed = false;
			angular.forEach(series, function(s) {
				if (!angular.isDefined(s.id)) {
					s.id = 'series-' + seriesId++;
					changed = true;
				}
			});
			return changed;
		};

		// immutable
		var axisNames = ['xAxis', 'yAxis'];
		var chartTypeMap = {
			'stock': 'StockChart',
			'map': 'Map',
			'chart': 'Chart'
		};

		var getMergedOptions = function(scope, element, config) {
			var mergedOptions = {};

			var defaultOptions = {
				chart: {
					events: {}
				},
				title: {},
				subtitle: {},
				series: [],
				credits: {},
				plotOptions: {},
				navigator: {
					enabled: false
				},
				xAxis: {
					events: {}
				},
				yAxis: {
					events: {}
				}
			};

			if (config.options) {
				mergedOptions = highchartsNGUtils.deepExtend(defaultOptions, config.options);
			} else {
				mergedOptions = defaultOptions;
			}
			mergedOptions.chart.renderTo = element[0];

			angular.forEach(axisNames, function(axisName) {
				if (angular.isDefined(config[axisName])) {
					mergedOptions[axisName] = highchartsNGUtils.deepExtend(mergedOptions[axisName] || {}, config[axisName]);

					if (angular.isDefined(config[axisName].currentMin) ||
						angular.isDefined(config[axisName].currentMax)) {

						highchartsNGUtils.prependMethod(mergedOptions.chart.events, 'selection', function(e) {
							var thisChart = this;
							if (e[axisName]) {
								scope.$apply(function() {
									scope.config[axisName].currentMin = e[axisName][0].min;
									scope.config[axisName].currentMax = e[axisName][0].max;
								});
							} else {
								//handle reset button - zoom out to all
								scope.$apply(function() {
									scope.config[axisName].currentMin = thisChart[axisName][0].dataMin;
									scope.config[axisName].currentMax = thisChart[axisName][0].dataMax;
								});
							}
						});

						highchartsNGUtils.prependMethod(mergedOptions.chart.events, 'addSeries', function(e) {
							scope.config[axisName].currentMin = this[axisName][0].min || scope.config[axisName].currentMin;
							scope.config[axisName].currentMax = this[axisName][0].max || scope.config[axisName].currentMax;
						});
						highchartsNGUtils.prependMethod(mergedOptions[axisName].events, 'setExtremes', function(e) {
							if (e.trigger &amp;&amp; e.trigger !== 'zoom') { // zoom trigger is handled by selection event
								$timeout(function() {
									scope.config[axisName].currentMin = e.min;
									scope.config[axisName].currentMax = e.max;
									scope.config[axisName].min = e.min; // set min and max to adjust scrollbar/navigator
									scope.config[axisName].max = e.max;
								}, 0);
							}
						});
					}
				}
			});

			if (config.title) {
				mergedOptions.title = config.title;
			}
			if (config.subtitle) {
				mergedOptions.subtitle = config.subtitle;
			}
			if (config.credits) {
				mergedOptions.credits = config.credits;
			}
			if (config.size) {
				if (config.size.width) {
					mergedOptions.chart.width = config.size.width;
				}
				if (config.size.height) {
					mergedOptions.chart.height = config.size.height;
				}
			}
			return mergedOptions;
		};

		var updateZoom = function(axis, modelAxis) {
			var extremes = axis.getExtremes();
			if (modelAxis.currentMin !== extremes.dataMin || modelAxis.currentMax !== extremes.dataMax) {
				if (axis.setExtremes) {
					axis.setExtremes(modelAxis.currentMin, modelAxis.currentMax, false);
				} else {
					axis.detachedsetExtremes(modelAxis.currentMin, modelAxis.currentMax, false);
				}
			}
		};

		var processExtremes = function(chart, axis, axisName) {
			if (axis.currentMin || axis.currentMax) {
				chart[axisName][0].setExtremes(axis.currentMin, axis.currentMax, true);
			}
		};

		var chartOptionsWithoutEasyOptions = function(options) {
			return angular.extend(
				highchartsNGUtils.deepExtend({}, options), {
					data: null,
					visible: null
				}
			);
		};

		var getChartType = function(scope) {
			if (scope.config === undefined) return 'Chart';
			return chartTypeMap[('' + scope.config.chartType).toLowerCase()] ||
				(scope.config.useHighStocks ? 'StockChart' : 'Chart');
		};

		var res = {
			restrict: 'EAC',
			replace: true,
			template: '&lt;div&gt;&lt;/div&gt;',
			scope: {
				config: '=',
				disableDataWatch: '='
			},
			link: function(scope, element, attrs) {
				// We keep some chart-specific variables here as a closure
				// instead of storing them on 'scope'.

				// prevSeriesOptions is maintained by processSeries
				var prevSeriesOptions = {};

				var processSeries = function(series) {
					var i;
					var ids = [];

					if (series) {
						var setIds = ensureIds(series);
						if (setIds &amp;&amp; !scope.disableDataWatch) {
							//If we have set some ids this will trigger another digest cycle.
							//In this scenario just return early and let the next cycle take care of changes
							return false;
						}

						//Find series to add or update
						angular.forEach(series, function(s) {
							ids.push(s.id);
							var chartSeries = chart.get(s.id);
							if (chartSeries) {
								if (!angular.equals(prevSeriesOptions[s.id], chartOptionsWithoutEasyOptions(s))) {
									chartSeries.update(angular.copy(s), false);
								} else {
									if (s.visible !== undefined &amp;&amp; chartSeries.visible !== s.visible) {
										chartSeries.setVisible(s.visible, false);
									}
									chartSeries.setData(angular.copy(s.data), false);
								}
							} else {
								chart.addSeries(angular.copy(s), false);
							}
							prevSeriesOptions[s.id] = chartOptionsWithoutEasyOptions(s);
						});

						//  Shows no data text if all series are empty
						if (scope.config.noData) {
							var chartContainsData = false;

							for (i = 0; i &lt; series.length; i++) {
								if (series[i].data &amp;&amp; series[i].data.length &gt; 0) {
									chartContainsData = true;

									break;
								}
							}

							if (!chartContainsData) {
								chart.showLoading(scope.config.noData);
							} else {
								chart.hideLoading();
							}
						}
					}

					//Now remove any missing series
					for (i = chart.series.length - 1; i &gt;= 0; i--) {
						var s = chart.series[i];
						if (s.options.id !== 'highcharts-navigator-series' &amp;&amp; highchartsNGUtils.indexOf(ids, s.options.id) &lt; 0) {
							s.remove(false);
						}
					}

					return true;
				};

				// chart is maintained by initChart
				var chart = false;
				var initChart = function() {
					if (chart) chart.destroy();
					prevSeriesOptions = {};
					var config = scope.config || {};
					var mergedOptions = getMergedOptions(scope, element, config);
					var func = config.func || undefined;
					var chartType = getChartType(scope);

					chart = new Highcharts[chartType](mergedOptions, func);

					for (var i = 0; i &lt; axisNames.length; i++) {
						if (config[axisNames[i]]) {
							processExtremes(chart, config[axisNames[i]], axisNames[i]);
						}
					}
					if (config.loading) {
						chart.showLoading();
					}
					config.getHighcharts = function() {
						return chart;
					};

				};
				initChart();


				if (scope.disableDataWatch) {
					scope.$watchCollection('config.series', function(newSeries, oldSeries) {
						processSeries(newSeries);
						chart.redraw();
					});
				} else {
					scope.$watch('config.series', function(newSeries, oldSeries) {
						var needsRedraw = processSeries(newSeries);
						if (needsRedraw) {
							chart.redraw();
						}
					}, true);
				}

				scope.$watch('config.title', function(newTitle) {
					chart.setTitle(newTitle, true);
				}, true);

				scope.$watch('config.subtitle', function(newSubtitle) {
					chart.setTitle(true, newSubtitle);
				}, true);

				scope.$watch('config.loading', function(loading) {
					if (loading) {
						chart.showLoading(loading === true ? null : loading);
					} else {
						chart.hideLoading();
					}
				});
				scope.$watch('config.noData', function(noData) {
					if (scope.config &amp;&amp; scope.config.loading) {
						chart.showLoading(noData);
					}
				}, true);

				scope.$watch('config.credits.enabled', function(enabled) {
					if (enabled) {
						chart.credits.show();
					} else if (chart.credits) {
						chart.credits.hide();
					}
				});

				scope.$watch(getChartType, function(chartType, oldChartType) {
					if (chartType === oldChartType) return;
					initChart();
				});

				angular.forEach(axisNames, function(axisName) {
					scope.$watch('config.' + axisName, function(newAxes, oldAxes) {
						if (newAxes === oldAxes || !newAxes) {
							return;
						}

						if (angular.isArray(newAxes)) {

							for (var axisIndex = 0; axisIndex &lt; newAxes.length; axisIndex++) {
								var axis = newAxes[axisIndex];

								if (axisIndex &lt; chart[axisName].length) {
									chart[axisName][axisIndex].update(axis, false);
									updateZoom(chart[axisName][axisIndex], angular.copy(axis));
								}

							}

						} else {
							// update single axis
							chart[axisName][0].update(newAxes, false);
							updateZoom(chart[axisName][0], angular.copy(newAxes));
						}

						chart.redraw();
					}, true);
				});
				scope.$watch('config.options', function(newOptions, oldOptions, scope) {
					//do nothing when called on registration
					if (newOptions === oldOptions) return;
					initChart();
					processSeries(scope.config.series);
					chart.redraw();
				}, true);

				scope.$watch('config.size', function(newSize, oldSize) {
					if (newSize === oldSize) return;
					if (newSize) {
						chart.setSize(newSize.width || chart.chartWidth, newSize.height || chart.chartHeight);
					}
				}, true);

				scope.$on('highchartsng.reflow', function() {
					chart.reflow();
				});

				scope.$on('$destroy', function() {
					if (chart) {
						try {
							chart.destroy();
						} catch (ex) {
							// fail silently as highcharts will throw exception if element doesn't exist
						}

						$timeout(function() {
							element.remove();
						}, 0);
					}
				});

			}
		};

		// override link fn if lazy loading is enabled
		if (highchartsNGUtils.lazyLoad) {
			var oldLink = res.link;
			res.link = function() {
				var args = arguments;
				highchartsNGUtils.ready(function() {
					oldLink.apply(this, args);
				}, this);
			};
		}
		return res;
	}

	function HighchartsConfigService($interval, $http, $q) {
		function setDataPoint(dataPoint, newValue) {
			if (typeof dataPoint == "number") {
				return newValue;
			}
			if (Array.isArray(dataPoint)) {
				dataPoint[1] = newValue[1];
				return dataPoint;
			}
			dataPoint.y = newValue.y;
			return dataPoint;
		}

		function getData(url) {
			var scope = this;
			var deferred = $q.defer();
			if (!scope.chartConfig.series) {
				scope.chartConfig.series = [];
			}
			$http({
					"method": "GET",
					"headers": {
						"X-UserToken": window.g_ck
					},
					"url": url
				})
				.success(function(data) {
					deferred.resolve(set.call(scope, data));
				})
				.error(function(data) {
					deferred.reject(setError.call(scope, data));
				});
			return deferred.promise;
		}

		function set(data) {
			if (this.options.table) {
				return setData.call(this, data);
			} else if (this.options.script_include) {
				return setScriptedData.call(this, data);
			}
		}

		function setScriptedData(data) {
			//Look for new columns
			var results = data.result;
			if (results.length == 0) {
				return setError(data);
			}
			if (this.chartConfig.series.length == 0) {
				this.chartConfig.series = results;
			} else {
				if (this.chartConfig.series.length &gt; results.length) {
					while (this.chartConfig.series.length &gt; results.length) {
						this.chartConfig.series.pop();
					}
				}
				this.chartConfig.series.forEach(function(currentSeries, seriesIndex) {
					var resultSeries = results[seriesIndex];
					currentSeries.data = resultSeries.data;
				});
				if (this.chartConfig.series.length &lt; results.length) {
					var startIndex = this.chartConfig.series.length;
					for (var x = startIndex; x != results.length; x++) {
						this.chartConfig.series.push(results[x]);
					}
				}
			}
			return this.chartConfig;
		}

		function setData(data) {
			var scope = this;
			var results = data.result;
			if (results.length == 0) {
				return setOnError(data);
			}
			scope.chartConfig.series.forEach(function(currentSeries) {
				currentSeries.data.forEach(function(currentData, index) {
					var resultData = results[index];
					currentData = setDataPoint(currentData, resultData);
				});
			});
			results.forEach(function(result) {
				var count = parseInt(result.stats.count);
				var fields = result.groupby_fields;
				fields.forEach(function(field) {
					var re = /(\b[a-z](?!\s))/g;
					var fieldName = field.field.replace(/_/g, " ").replace(re, function(x) {
						return x.toUpperCase();
					});
					var fieldValue = field.field;
					var fieldDisplay = field.display_value || "None";
					var currentSeriesIndex = scope.chartConfig.series.findIndex(function(seriesObject) {
						return seriesObject.name == fieldName;
					});
					if (currentSeriesIndex != -1) {
						var currentDataIndex = scope.chartConfig.series[currentSeriesIndex].data.findIndex(function(currentData) {
							return currentData.name == fieldDisplay;
						});
						if (currentDataIndex != -1) {
							scope.chartConfig.series[currentSeriesIndex].data[currentDataIndex].y = count;
						} else {
							scope.chartConfig.series[currentSeriesIndex].data.push({
								"name": fieldDisplay,
								"y": count,
								"id": fieldValue
							});
						}
					} else {
						var tempObject = {
							"name": fieldName,
							"data": [{
								"name": fieldDisplay,
								"y": count,
								"id": fieldValue
							}],
							"stack": scope.stackObject ? scope.stackObject[fieldValue] : fieldValue
						};
						scope.chartConfig.series.push(tempObject);
					}
				});
			});
			if (scope.chartConfig.options.chart.type == "solidgauge") {
				scope.chartConfig.series.forEach(function(currentSeries) {
					currentSeries.data.map(function(data, index, dataArray) {
						var width = (scope.options.outer_radius - scope.options.inner_radius) / dataArray.length;
						data.innerRadius = index * width + scope.options.inner_radius;
						data.radius = ((index + 1) == dataArray.length) ? scope.options.outer_radius : ((index + 1) * width + scope.options.inner_radius) - 1;
					});
				});
			}
			scope.chartConfig.loading = false;
			return scope.chartConfig;
		}

		function setError(data) {
			this.chartConfig.options.lang.noData = "No data to display&lt;br/&gt;" + (data.error ? (data.error.detail ? data.error.detail.toString() : data.error.message.toString()) : "");
			delete this.chartConfig.series;
			return this.chartConfig;
		}
		var hcs = function(options, type, data, stackObject) {
			var scope = this;
			scope.options = options;
			scope.data = data;
			scope.chartConfig = {
				"options": {
					"chart": {
						"borderWidth": 0,
						"type": type || "line",
						"zoomType": "xy",
						"events": {
							load: function() {
								if (options.interval &amp;&amp; options.interval != "1970-01-01 00:00:00") {
									var dateTime = moment(options.interval);
									var time = (dateTime.seconds() + ((dateTime.minutes() + (dateTime.hours() * 60)) * 60)) * 1000;
									$interval(function() {
										scope.get();
									}, time);
								}
							}
						}
					},
					"lang": {
						"noData": "No data to display"
					},
					"plotOptions": {
						"series": {
							"allowPointSelect": true,
						}
					},
				},
				"loading": data ? false : true,
				"credits": {
					"enabled": false
				}
			};
		};
		hcs.prototype.getChartConfig = function() {
			var scope = this;
			if (scope.options.advance) {
				scope.chartConfig = Highcharts.merge(scope.chartConfig, JSON.parse(scope.options.advance));
			}
			return scope.chartConfig;
		};
		hcs.prototype.setError = function(data) {
			return setError.call(this, data);
		};
		hcs.prototype.getData = function() {
			var url = "/api/now/stats/" + this.options.table.toLowerCase() + "?sysparm_display_value=all&amp;sysparm_count=true&amp;sysparm_group_by=" + this.options.fields;
			url += this.options.encoded_query ? "&amp;sysparm_query=" + this.options.encoded_query : "";
			return getData.call(this, url);
		};
		hcs.prototype.getScriptedData = function() {
			var url = "/api/snc/pe_highcharts_helper/get_data?script_include=" + this.options.script_include;
			url += "&amp;options=" + JSON.stringify(this.options);
			url += this.options.function_name ? "&amp;function_name=" + this.options.function_name : "";
			url += this.options.param1 ? "&amp;param1=" + this.options.param1 : "";
			return getData.call(this, url);
		};
		hcs.prototype.setScriptedData = function(data) {
			return setScriptedData.call(this, data);
		};
		hcs.prototype.setData = function(data) {
			return setData.call(this, data);
		};
		hcs.prototype.get = function() {
			var scope = this;
			if (scope.options.table) {
				return scope.getData();
			} else if (scope.options.script_include) {
				return scope.getScriptedData();
			}
			this.chartConfig.series = [{
				"data": scope.data
			}];
			return scope.getChartConfig();
		};
		hcs.prototype.set = function(data) {
			var scope = this;
			if (scope.options.table) {
				return scope.setData(data);
			} else if (scope.options.script_include) {
				return scope.setScriptedData(data);
			}
		};
		return hcs;
	}
}());]]&gt;&lt;/script&gt;&lt;script_name/&gt;&lt;sys_class_name&gt;sys_ui_script&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 21:50:36&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;true&lt;/sys_customer_update&gt;&lt;sys_id&gt;b9d1058bdbd53200f687dfea5e9619f6&lt;/sys_id&gt;&lt;sys_mod_count&gt;24&lt;/sys_mod_count&gt;&lt;sys_name&gt;PE highcharts-ng&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_ui_script_b9d1058bdbd53200f687dfea5e9619f6&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 16:53:50&lt;/sys_updated_on&gt;&lt;use_scoped_format&gt;false&lt;/use_scoped_format&gt;&lt;/sys_ui_script&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>77dbb59fdbd532002e5df2b6ae9619c7</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE highcharts-ng</target_name>
<type>UI Script</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>m2m_sp_dependency_js_include_c874cd07db5932002e5df2b6ae961919</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="m2m_sp_dependency_js_include"><m2m_sp_dependency_js_include action="INSERT_OR_UPDATE"><order>100</order><sp_dependency display_value="PE Highcharts 5.0.5">5a548d07db5932002e5df2b6ae9619bf</sp_dependency><sp_js_include display_value="PE Highcharts 5_0_5">6043c507db5932002e5df2b6ae96196c</sp_js_include><sys_class_name>m2m_sp_dependency_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:01:57</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>c874cd07db5932002e5df2b6ae961919</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE Highcharts 5.0.5.PE Highcharts 5_0_5</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>m2m_sp_dependency_js_include_c874cd07db5932002e5df2b6ae961919</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:01:57</sys_updated_on></m2m_sp_dependency_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>a3dbb59fdbd532002e5df2b6ae9619c4</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5.0.5.PE Highcharts 5_0_5</target_name>
<type>Dependency JS Includes</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>m2m_sp_dependency_js_include_5674cd07db5932002e5df2b6ae96193f</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="m2m_sp_dependency_js_include"><m2m_sp_dependency_js_include action="INSERT_OR_UPDATE"><order>150</order><sp_dependency display_value="PE Highcharts 5.0.5">5a548d07db5932002e5df2b6ae9619bf</sp_dependency><sp_js_include display_value="PE highcharts-more">6c74cd07db5932002e5df2b6ae961982</sp_js_include><sys_class_name>m2m_sp_dependency_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:02:06</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>5674cd07db5932002e5df2b6ae96193f</sys_id><sys_mod_count>1</sys_mod_count><sys_name>PE Highcharts 5.0.5.PE highcharts-more</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>m2m_sp_dependency_js_include_5674cd07db5932002e5df2b6ae96193f</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:02:13</sys_updated_on></m2m_sp_dependency_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>a7dbb59fdbd532002e5df2b6ae9619c3</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5.0.5.PE highcharts-more</target_name>
<type>Dependency JS Includes</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_script_include_c7ab5d83db9932002e5df2b6ae961969</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;&lt;sys_script_include action="INSERT_OR_UPDATE"&gt;&lt;access&gt;package_private&lt;/access&gt;&lt;active&gt;true&lt;/active&gt;&lt;api_name&gt;global.PEHighchartsExample&lt;/api_name&gt;&lt;client_callable&gt;false&lt;/client_callable&gt;&lt;description/&gt;&lt;name&gt;PEHighchartsExample&lt;/name&gt;&lt;script&gt;&lt;![CDATA[var PEHighchartsExample = Class.create();
PEHighchartsExample.prototype = {
	initialize: function(request, response) {
		this.json = new JSON();
	},
	getDemoData: function(param1) {
		var scope = this;
		return [{
			"name": "Random Data 1",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)],
				["Data Point 7", scope.randNumber(1, 100)],
				["Data Point 8", scope.randNumber(1, 100)],
				["Data Point 9", scope.randNumber(1, 100)]
			]
		}, {
			"name": "Random Data 2",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)]
			]
		}];
	},
	getPieDemoData: function(param1) {
		var scope = this;
		return [{
			"name": "Random Data 1",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)],
				["Data Point 7", scope.randNumber(1, 100)],
				["Data Point 8", scope.randNumber(1, 100)],
				["Data Point 9", scope.randNumber(1, 100)],
				["Data Point 10", scope.randNumber(1, 100)],
				["Data Point 11", scope.randNumber(1, 100)],
				["Data Point 12", scope.randNumber(1, 100)]
			]
		}];
	},
	getGaugeDemoData: function(param1) {
		var scope = this;
		var dataSeries = [{
			"name": "Random Data 1",
			"data": [{
				name: "Data Point 1",
				y: scope.randNumber(1, 100)
			}]
		}];
		return dataSeries;
	},
	getHeatmapDemoData: function(param1) {
		var scope = this;
		var series = [{
			data: [
				[0, 0, scope.randNumber(1, 100)],
				[0, 1, scope.randNumber(1, 100)],
				[0, 2, scope.randNumber(1, 100)],
				[1, 0, scope.randNumber(1, 100)],
				[1, 1, scope.randNumber(1, 100)],
				[1, 2, scope.randNumber(1, 100)],
				[2, 0, scope.randNumber(1, 100)],
				[2, 1, scope.randNumber(1, 100)],
				[2, 2, scope.randNumber(1, 100)]
			]
		}];
		return series;
	},
	getTreemapDemoData: function(param1) {
		var scope = this;
		var series = [{
			data: [
				{
					name:"A", 
					value:scope.randNumber(1, 100)
				},
				{
					name:"B", 
					value:scope.randNumber(1, 100)
				},
				{
					name:"C", 
					value:scope.randNumber(1, 100)
				},
				{
					name:"D",
					value:scope.randNumber(1, 100)
				},
				{
					name:"E", 
					value:scope.randNumber(1, 100)
				},
				{
					name:"F", 
					value:scope.randNumber(1, 100)
				},
				{
					name:"G", 
					value:scope.randNumber(1, 100)
				},
				{
					name:"H", 
					value:scope.randNumber(1, 100)
				},
				{
					name:"I", 
					value:scope.randNumber(1, 100)
				}
			]
		}];
		return series;
	},
	randNumber: function(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	},
	getParamAsString: function(paramName) {
		if (this.request.queryParams.hasOwnProperty(paramName)) {
			return this.request.queryParams[paramName] + '';
		}
		return false;
	},
	type: 'PEHighchartsExample'
};]]&gt;&lt;/script&gt;&lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 23:43:28&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;true&lt;/sys_customer_update&gt;&lt;sys_id&gt;c7ab5d83db9932002e5df2b6ae961969&lt;/sys_id&gt;&lt;sys_mod_count&gt;18&lt;/sys_mod_count&gt;&lt;sys_name&gt;PEHighchartsExample&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_script_include_c7ab5d83db9932002e5df2b6ae961969&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 20:25:42&lt;/sys_updated_on&gt;&lt;/sys_script_include&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>a7dbb59fdbd532002e5df2b6ae9619c6</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PEHighchartsExample</target_name>
<type>Script Include</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_js_include_9084cd07db5932002e5df2b6ae9619f0</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_js_include"><sp_js_include action="INSERT_OR_UPDATE"><display_name>PE Highcharts Export</display_name><source>local</source><sys_class_name>sp_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:02:25</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>9084cd07db5932002e5df2b6ae9619f0</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE Highcharts Export</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_ui_script display_value="PE Highcharts Export">85b3854bdbd53200f687dfea5e9619ab</sys_ui_script><sys_update_name>sp_js_include_9084cd07db5932002e5df2b6ae9619f0</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:02:25</sys_updated_on><url/></sp_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>abdbb59fdbd532002e5df2b6ae9619c5</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts Export</target_name>
<type>JS Include</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_dependency_c722c9c3db5932002e5df2b6ae96193b</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_dependency"><sp_dependency action="INSERT_OR_UPDATE"><module>pe-highcharts-ng</module><name>PE HighchartsNG</name><page_load>false</page_load><sp_portals/><sys_class_name>sp_dependency</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 21:52:03</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>c722c9c3db5932002e5df2b6ae96193b</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE HighchartsNG</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>sp_dependency_c722c9c3db5932002e5df2b6ae96193b</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 21:52:03</sys_updated_on></sp_dependency></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>afdbb59fdbd532002e5df2b6ae9619c4</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE HighchartsNG</target_name>
<type>Widget Dependency</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ui_script_85b3854bdbd53200f687dfea5e9619ab</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_ui_script"&gt;&lt;sys_ui_script action="INSERT_OR_UPDATE"&gt;&lt;active&gt;true&lt;/active&gt;&lt;description/&gt;&lt;global&gt;false&lt;/global&gt;&lt;name&gt;PE Highcharts Export&lt;/name&gt;&lt;script&gt;&lt;![CDATA[/*
 Highcharts JS v4.2.6 (2016-08-02)
 Exporting module

 (c) 2010-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function(f) {
	typeof module === "object" &amp;&amp; module.exports ? module.exports = f : f(Highcharts)
})(function(f) {
	var s = f.win,
		j = s.document,
		B = f.Chart,
		u = f.addEvent,
		C = f.removeEvent,
		D = f.fireEvent,
		r = f.createElement,
		t = f.discardElement,
		w = f.css,
		l = f.merge,
		m = f.each,
		q = f.extend,
		F = f.splat,
		G = Math.max,
		H = f.isTouchDevice,
		I = f.Renderer.prototype.symbols,
		z = f.getOptions(),
		A;
	q(z.lang, {
		printChart: "Print chart",
		downloadPNG: "Download PNG image",
		downloadJPEG: "Download JPEG image",
		downloadPDF: "Download PDF document",
		downloadSVG: "Download SVG vector image",
		contextButtonTitle: "Chart context menu"
	});
	z.navigation = {
		menuStyle: {
			border: "1px solid #A0A0A0",
			background: "#FFFFFF",
			padding: "5px 0"
		},
		menuItemStyle: {
			padding: "0 10px",
			background: "none",
			color: "#303030",
			fontSize: H ? "14px" : "11px"
		},
		menuItemHoverStyle: {
			background: "#4572A5",
			color: "#FFFFFF"
		},
		buttonOptions: {
			symbolFill: "#E0E0E0",
			symbolSize: 14,
			symbolStroke: "#666",
			symbolStrokeWidth: 3,
			symbolX: 12.5,
			symbolY: 10.5,
			align: "right",
			buttonSpacing: 3,
			height: 22,
			theme: {
				fill: "white",
				stroke: "none"
			},
			verticalAlign: "top",
			width: 24
		}
	};
	z.exporting = {
		type: "image/png",
		url: "https://export.highcharts.com/",
		printMaxWidth: 780,
		scale: 2,
		buttons: {
			contextButton: {
				menuClassName: "highcharts-contextmenu",
				symbol: "menu",
				_titleKey: "contextButtonTitle",
				menuItems: [{
						textKey: "printChart",
						onclick: function() {
							this.print()
						}
					}, {
						separator: !0
					}, {
						textKey: "downloadPNG",
						onclick: function() {
							this.exportChart()
						}
					}, {
						textKey: "downloadJPEG",
						onclick: function() {
							this.exportChart({
								type: "image/jpeg"
							})
						}
					}, {
						textKey: "downloadPDF",
						onclick: function() {
							this.exportChart({
								type: "application/pdf"
							})
						}
					},
					{
						textKey: "downloadSVG",
						onclick: function() {
							this.exportChart({
								type: "image/svg+xml"
							})
						}
					}
				]
			}
		}
	};
	f.post = function(a, b, e) {
		var c, a = r("form", l({
			method: "post",
			action: a,
			enctype: "multipart/form-data"
		}, e), {
			display: "none"
		}, j.body);
		for (c in b) r("input", {
			type: "hidden",
			name: c,
			value: b[c]
		}, null, a);
		a.submit();
		t(a)
	};
	q(B.prototype, {
		sanitizeSVG: function(a) {
			return a.replace(/zIndex="[^"]+"/g, "").replace(/isShadow="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\([^#]+#/g, "url(#").replace(/&lt;svg /,
				'&lt;svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (NS[0-9]+\:)?href=/g, " xlink:href=").replace(/\n/, " ").replace(/&lt;\/svg&gt;.*?$/, "&lt;/svg&gt;").replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&amp;nbsp;/g, "\u00a0").replace(/&amp;shy;/g, "\u00ad").replace(/&lt;IMG /g, "&lt;image ").replace(/&lt;(\/?)TITLE&gt;/g, "&lt;$1title&gt;").replace(/height=([^" ]+)/g, 'height="$1"').replace(/width=([^" ]+)/g, 'width="$1"').replace(/hc-svg-href="([^"]+)"&gt;/g, 'xlink:href="$1"/&gt;').replace(/ id=([^" &gt;]+)/g,
				' id="$1"').replace(/class=([^" &gt;]+)/g, 'class="$1"').replace(/ transform /g, " ").replace(/:(path|rect)/g, "$1").replace(/style="([^"]+)"/g, function(a) {
				return a.toLowerCase()
			})
		},
		getChartHTML: function() {
			return this.container.innerHTML
		},
		getSVG: function(a) {
			var b = this,
				e, c, g, k, h, d = l(b.options, a),
				n = d.exporting.allowHTML;
			if (!j.createElementNS) j.createElementNS = function(a, b) {
				return j.createElement(b)
			};
			c = r("div", null, {
				position: "absolute",
				top: "-9999em",
				width: b.chartWidth + "px",
				height: b.chartHeight + "px"
			}, j.body);
			g = b.renderTo.style.width;
			h = b.renderTo.style.height;
			g = d.exporting.sourceWidth || d.chart.width || /px$/.test(g) &amp;&amp; parseInt(g, 10) || 600;
			h = d.exporting.sourceHeight || d.chart.height || /px$/.test(h) &amp;&amp; parseInt(h, 10) || 400;
			q(d.chart, {
				animation: !1,
				renderTo: c,
				forExport: !0,
				renderer: "SVGRenderer",
				width: g,
				height: h
			});
			d.exporting.enabled = !1;
			delete d.data;
			d.series = [];
			m(b.series, function(a) {
				k = l(a.userOptions, {
					animation: !1,
					enableMouseTracking: !1,
					showCheckbox: !1,
					visible: a.visible
				});
				k.isInternal || d.series.push(k)
			});
			a &amp;&amp; m(["xAxis",
				"yAxis"
			], function(b) {
				m(F(a[b]), function(a, c) {
					d[b][c] = l(d[b][c], a)
				})
			});
			e = new f.Chart(d, b.callback);
			m(["xAxis", "yAxis"], function(a) {
				m(b[a], function(b, c) {
					var d = e[a][c],
						f = b.getExtremes(),
						g = f.userMin,
						f = f.userMax;
					d &amp;&amp; (g !== void 0 || f !== void 0) &amp;&amp; d.setExtremes(g, f, !0, !1)
				})
			});
			g = e.getChartHTML();
			d = null;
			e.destroy();
			t(c);
			if (n &amp;&amp; (c = g.match(/&lt;\/svg&gt;(.*?$)/))) c = '&lt;foreignObject x="0" y="0" width="200" height="200"&gt;&lt;body xmlns="http://www.w3.org/1999/xhtml"&gt;' + c[1] + "&lt;/body&gt;&lt;/foreignObject&gt;", g = g.replace("&lt;/svg&gt;", c + "&lt;/svg&gt;");
			g = this.sanitizeSVG(g);
			return g = g.replace(/(url\(#highcharts-[0-9]+)&amp;quot;/g, "$1").replace(/&amp;quot;/g, "'")
		},
		getSVGForExport: function(a, b) {
			var e = this.options.exporting;
			return this.getSVG(l({
				chart: {
					borderRadius: 0
				}
			}, e.chartOptions, b, {
				exporting: {
					sourceWidth: a &amp;&amp; a.sourceWidth || e.sourceWidth,
					sourceHeight: a &amp;&amp; a.sourceHeight || e.sourceHeight
				}
			}))
		},
		exportChart: function(a, b) {
			var e = this.getSVGForExport(a, b),
				a = l(this.options.exporting, a);
			f.post(a.url, {
				filename: a.filename || "chart",
				type: a.type,
				width: a.width || 0,
				scale: a.scale,
				svg: e
			}, a.formAttributes)
		},
		print: function() {
			var a = this,
				b = a.container,
				e = [],
				c = b.parentNode,
				f = j.body,
				k = f.childNodes,
				h = a.options.exporting.printMaxWidth,
				d, n;
			if (!a.isPrinting) {
				a.isPrinting = !0;
				a.pointer.reset(null, 0);
				D(a, "beforePrint");
				if (n = h &amp;&amp; a.chartWidth &gt; h) d = [a.options.chart.width, void 0, !1], a.setSize(h, void 0, !1);
				m(k, function(a, b) {
					if (a.nodeType === 1) e[b] = a.style.display, a.style.display = "none"
				});
				f.appendChild(b);
				s.focus();
				s.print();
				setTimeout(function() {
					c.appendChild(b);
					m(k, function(a, b) {
						if (a.nodeType ===
							1) a.style.display = e[b]
					});
					a.isPrinting = !1;
					n &amp;&amp; a.setSize.apply(a, d);
					D(a, "afterPrint")
				}, 1E3)
			}
		},
		contextMenu: function(a, b, e, c, f, k, h) {
			var d = this,
				n = d.options.navigation,
				l = n.menuItemStyle,
				o = d.chartWidth,
				p = d.chartHeight,
				E = "cache-" + a,
				i = d[E],
				v = G(f, k),
				x, y, s, t = function(b) {
					d.pointer.inClass(b.target, a) || y()
				};
			if (!i) d[E] = i = r("div", {
				className: a
			}, {
				position: "absolute",
				zIndex: 1E3,
				padding: v + "px"
			}, d.container), x = r("div", null, q({
					MozBoxShadow: "3px 3px 10px #888",
					WebkitBoxShadow: "3px 3px 10px #888",
					boxShadow: "3px 3px 10px #888"
				},
				n.menuStyle), i), y = function() {
				w(i, {
					display: "none"
				});
				h &amp;&amp; h.setState(0);
				d.openMenu = !1
			}, u(i, "mouseleave", function() {
				s = setTimeout(y, 500)
			}), u(i, "mouseenter", function() {
				clearTimeout(s)
			}), u(j, "mouseup", t), u(d, "destroy", function() {
				C(j, "mouseup", t)
			}), m(b, function(a) {
				if (a) {
					var b = a.separator ? r("hr", null, null, x) : r("div", {
						onmouseover: function() {
							w(this, n.menuItemHoverStyle)
						},
						onmouseout: function() {
							w(this, l)
						},
						onclick: function(b) {
							b &amp;&amp; b.stopPropagation();
							y();
							a.onclick &amp;&amp; a.onclick.apply(d, arguments)
						},
						innerHTML: a.text ||
							d.options.lang[a.textKey]
					}, q({
						cursor: "pointer"
					}, l), x);
					d.exportDivElements.push(b)
				}
			}), d.exportDivElements.push(x, i), d.exportMenuWidth = i.offsetWidth, d.exportMenuHeight = i.offsetHeight;
			b = {
				display: "block"
			};
			e + d.exportMenuWidth &gt; o ? b.right = o - e - f - v + "px" : b.left = e - v + "px";
			c + k + d.exportMenuHeight &gt; p &amp;&amp; h.alignOptions.verticalAlign !== "top" ? b.bottom = p - c - v + "px" : b.top = c + k - v + "px";
			w(i, b);
			d.openMenu = !0
		},
		addButton: function(a) {
			var b = this,
				e = b.renderer,
				c = l(b.options.navigation.buttonOptions, a),
				g = c.onclick,
				k = c.menuItems,
				h, d, n = {
					stroke: c.symbolStroke,
					fill: c.symbolFill
				},
				j = c.symbolSize || 12;
			if (!b.btnCount) b.btnCount = 0;
			if (!b.exportDivElements) b.exportDivElements = [], b.exportSVGElements = [];
			if (c.enabled !== !1) {
				var o = c.theme,
					p = o.states,
					m = p &amp;&amp; p.hover,
					p = p &amp;&amp; p.select,
					i;
				delete o.states;
				g ? i = function(a) {
					a.stopPropagation();
					g.call(b, a)
				} : k &amp;&amp; (i = function() {
					b.contextMenu(d.menuClassName, k, d.translateX, d.translateY, d.width, d.height, d);
					d.setState(2)
				});
				c.text &amp;&amp; c.symbol ? o.paddingLeft = f.pick(o.paddingLeft, 25) : c.text || q(o, {
					width: c.width,
					height: c.height,
					padding: 0
				});
				d = e.button(c.text, 0, 0, i, o, m, p).attr({
					title: b.options.lang[c._titleKey],
					"stroke-linecap": "round",
					zIndex: 3
				});
				d.menuClassName = a.menuClassName || "highcharts-menu-" + b.btnCount++;
				c.symbol &amp;&amp; (h = e.symbol(c.symbol, c.symbolX - j / 2, c.symbolY - j / 2, j, j).attr(q(n, {
					"stroke-width": c.symbolStrokeWidth || 1,
					zIndex: 1
				})).add(d));
				d.add().align(q(c, {
					width: d.width,
					x: f.pick(c.x, A)
				}), !0, "spacingBox");
				A += (d.width + c.buttonSpacing) * (c.align === "right" ? -1 : 1);
				b.exportSVGElements.push(d, h)
			}
		},
		destroyExport: function(a) {
			var a =
				a.target,
				b, e;
			for (b = 0; b &lt; a.exportSVGElements.length; b++)
				if (e = a.exportSVGElements[b]) e.onclick = e.ontouchstart = null, a.exportSVGElements[b] = e.destroy();
			for (b = 0; b &lt; a.exportDivElements.length; b++) e = a.exportDivElements[b], C(e, "mouseleave"), a.exportDivElements[b] = e.onmouseout = e.onmouseover = e.ontouchstart = e.onclick = null, t(e)
		}
	});
	I.menu = function(a, b, e, c) {
		return ["M", a, b + 2.5, "L", a + e, b + 2.5, "M", a, b + c / 2 + 0.5, "L", a + e, b + c / 2 + 0.5, "M", a, b + c - 1.5, "L", a + e, b + c - 1.5]
	};
	B.prototype.callbacks.push(function(a) {
		var b, e = a.options.exporting,
			c = e.buttons;
		A = 0;
		if (e.enabled !== !1) {
			for (b in c) a.addButton(c[b]);
			u(a, "destroy", a.destroyExport)
		}
	})
});]]&gt;&lt;/script&gt;&lt;script_name/&gt;&lt;sys_class_name&gt;sys_ui_script&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 21:58:45&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;false&lt;/sys_customer_update&gt;&lt;sys_id&gt;85b3854bdbd53200f687dfea5e9619ab&lt;/sys_id&gt;&lt;sys_mod_count&gt;2&lt;/sys_mod_count&gt;&lt;sys_name&gt;PE Highcharts Export&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_ui_script_85b3854bdbd53200f687dfea5e9619ab&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 06:06:12&lt;/sys_updated_on&gt;&lt;use_scoped_format&gt;false&lt;/use_scoped_format&gt;&lt;/sys_ui_script&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>b3dbb59fdbd532002e5df2b6ae9619c7</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts Export</target_name>
<type>UI Script</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ws_query_parameter_9acc160bdbd932002e5df2b6ae9619f8</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ws_query_parameter"><sys_ws_query_parameter action="INSERT_OR_UPDATE"><example_value>HighchartsHelper</example_value><name>script_include</name><required>false</required><short_description/><sys_class_name>sys_ws_query_parameter</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-09 04:28:12</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>9acc160bdbd932002e5df2b6ae9619f8</sys_id><sys_mod_count>0</sys_mod_count><sys_name>script_include</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>sys_ws_query_parameter_9acc160bdbd932002e5df2b6ae9619f8</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-09 04:28:12</sys_updated_on><web_service_definition display_value="PE Highcharts Helper">226c520bdbd932002e5df2b6ae961978</web_service_definition></sys_ws_query_parameter></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>bfdbb59fdbd532002e5df2b6ae9619c7</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>script_include</target_name>
<type>Scripted REST Query Parameter</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_script_include_a1bb59c3db9932002e5df2b6ae9619e4</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;&lt;sys_script_include action="INSERT_OR_UPDATE"&gt;&lt;access&gt;package_private&lt;/access&gt;&lt;active&gt;true&lt;/active&gt;&lt;api_name&gt;global.PEHighchartsHelper&lt;/api_name&gt;&lt;client_callable&gt;false&lt;/client_callable&gt;&lt;description/&gt;&lt;name&gt;PEHighchartsHelper&lt;/name&gt;&lt;script&gt;&lt;![CDATA[var PEHighchartsHelper = Class.create();
PEHighchartsHelper.prototype = {
	initialize: function(request, response) {
		this.request = request;
		this.response = response;
		this.json = new JSON();
		this.error = new sn_ws_err.ServiceError();
		this.script_include = this.getParamAsString("script_include");
		this.function_name = this.getParamAsString("function_name") || "process";
		this.param1 = this.getParamAsString("param1");
		this.options = this.decode(this.getParamAsString("options"));
	},
	process: function() {
		var scope = this;
		if (scope.script_include &amp;&amp; scope.function_name) {
			var scriptInc = new global[scope.script_include]();
			if (scriptInc) {
				if (scriptInc[scope.function_name]) {
					return scriptInc[scope.function_name](scope.param1, scope.options);
				}
				return scope.getError(400, "Invalid function_name has been sent", scope.function_name + " is not valid, verify that this function exist");
			}
		}
		return scope.getError(400, "Invalid Script Include has been sent", scope.script_include + " is not valid, verify that this Script Include exist");
	},
	getError: function(status, message, details) {
		var scope = this;
		scope.error.setStatus(status);
		scope.error.setMessage(message);
		scope.error.setDetail(details);
		return scope.error;
	},
	getDemoData: function() {
		var scope = this;
		return [{
			"name": "Random Data 1",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)],
				["Data Point 7", scope.randNumber(1, 100)],
				["Data Point 8", scope.randNumber(1, 100)],
				["Data Point 9", scope.randNumber(1, 100)],
				["Data Point 10", scope.randNumber(1, 100)],
				["Data Point 11", scope.randNumber(1, 100)],
				["Data Point 12", scope.randNumber(1, 100)]
			]
		}, {
			"name": "Random Data 2",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)],
				["Data Point 7", scope.randNumber(1, 100)],
				["Data Point 8", scope.randNumber(1, 100)],
				["Data Point 9", scope.randNumber(1, 100)],
				["Data Point 10", scope.randNumber(1, 100)],
				["Data Point 11", scope.randNumber(1, 100)],
				["Data Point 12", scope.randNumber(1, 100)]
			]
		}, {
			"name": "Random Data 3",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)],
				["Data Point 7", scope.randNumber(1, 100)],
				["Data Point 8", scope.randNumber(1, 100)],
				["Data Point 9", scope.randNumber(1, 100)],
				["Data Point 10", scope.randNumber(1, 100)],
				["Data Point 11", scope.randNumber(1, 100)],
				["Data Point 12", scope.randNumber(1, 100)]
			]
		}, {
			"name": "Random Data 4",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)],
				["Data Point 7", scope.randNumber(1, 100)],
				["Data Point 8", scope.randNumber(1, 100)],
				["Data Point 9", scope.randNumber(1, 100)],
				["Data Point 10", scope.randNumber(1, 100)],
				["Data Point 11", scope.randNumber(1, 100)],
				["Data Point 12", scope.randNumber(1, 100)]
			]
		}];
	},
	getPieDemoData: function() {
		var scope = this;
		return [{
			"name": "Random Data 1",
			"data": [
				["Data Point 1", scope.randNumber(1, 100)],
				["Data Point 2", scope.randNumber(1, 100)],
				["Data Point 3", scope.randNumber(1, 100)],
				["Data Point 4", scope.randNumber(1, 100)],
				["Data Point 5", scope.randNumber(1, 100)],
				["Data Point 6", scope.randNumber(1, 100)],
				["Data Point 7", scope.randNumber(1, 100)],
				["Data Point 8", scope.randNumber(1, 100)],
				["Data Point 9", scope.randNumber(1, 100)],
				["Data Point 10", scope.randNumber(1, 100)],
				["Data Point 11", scope.randNumber(1, 100)],
				["Data Point 12", scope.randNumber(1, 100)]
			]
		}];
	},
	getGaugeDemoData: function(radius) {
		radius = this.decode(radius);
		var scope = this;
		var dataSeries = [{
			"name": "Random Data 1",
			"data": [{
				name: "Data Point 1",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 2",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 3",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 4",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 5",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 6",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 7",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 8",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 9",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 10",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 11",
				y: scope.randNumber(1, 100)
			}, {
				name: "Data Point 12",
				y: scope.randNumber(1, 100)
			}]
		}];
		dataSeries.forEach(function(currentSeries) {
			currentSeries.data.map(function(data, index, dataArray) {
				var width = (radius.outer - radius.inner) / dataArray.length;
				data.innerRadius = index * width + radius.inner;
				data.radius = ((index + 1) == dataArray.length) ? radius.outer : ((index + 1) * width + radius.inner) - 1;
			});
		});
		return dataSeries;
	},
	encode: function(jsonObject) {
		return this.json.encode(jsonObject);
	},
	decode: function(jsonString) {
		return this.json.decode(jsonString);
	},
	randNumber: function(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	},
	log: function(message) {
		gs.log(message, "PEHighchartsHelper");
	},
	logObject: function(objectMessage) {
		this.log("\n" + this.objectToString(objectMessage));
	},
	objectToString: function(objectMessage, tabs) {
		tabs = tabs || "";
		var scope = this;
		var message = "{\n";
		var keyArray = Object.keys(objectMessage);
		for (var i = 0; i != keyArray.length; i++) {
			var key = keyArray[i];
			var value = objectMessage[key];
			var valueType = typeof value;
			message += tabs + "\t\"" + key + "\":";
			if (valueType == "object") {
				if (!Array.isArray(value)) {
					message += scope.objectToString(value, (tabs + "\t"));
				} else {
					message += "[";
					for (var x = 0; x != value.length; x++) {
						if (typeof value[x] != "object") {
							message += value[x];
						} else {
							message += "\n\t\t" + tabs + scope.objectToString(value[x], (tabs + "\t\t"));
							if (x == (value.length - 1)) {
								message += "\n\t" + tabs;
							}
						}
						if (x != (value.length - 1)) {
							message += ",\n" + (tabs + "\t\t");
						}
					}
					message += "]";
				}
			} else {
				message += "\"" + value.toString() + "\"";
			}
			if (i != (keyArray.length - 1)) {
				message += ",\n";
			}
		}
		return message + "\n" + tabs + "}";
	},
	getParamAsString: function(paramName) {
		if (this.request.queryParams.hasOwnProperty(paramName)) {
			return this.request.queryParams[paramName] + '';
		}
		return false;
	},
	type: 'PEHighchartsHelper'
};]]&gt;&lt;/script&gt;&lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 23:43:38&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;true&lt;/sys_customer_update&gt;&lt;sys_id&gt;a1bb59c3db9932002e5df2b6ae9619e4&lt;/sys_id&gt;&lt;sys_mod_count&gt;2&lt;/sys_mod_count&gt;&lt;sys_name&gt;PEHighchartsHelper&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_script_include_a1bb59c3db9932002e5df2b6ae9619e4&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-08 23:46:01&lt;/sys_updated_on&gt;&lt;/sys_script_include&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>e3dbb59fdbd532002e5df2b6ae9619c6</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PEHighchartsHelper</target_name>
<type>Script Include</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_js_include_6c74cd07db5932002e5df2b6ae961982</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_js_include"><sp_js_include action="INSERT_OR_UPDATE"><display_name>PE highcharts-more</display_name><source>local</source><sys_class_name>sp_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:02:06</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>6c74cd07db5932002e5df2b6ae961982</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE highcharts-more</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_ui_script display_value="PE highcharts-more">3793058bdbd53200f687dfea5e9619fb</sys_ui_script><sys_update_name>sp_js_include_6c74cd07db5932002e5df2b6ae961982</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:02:06</sys_updated_on><url/></sp_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>e7dbb59fdbd532002e5df2b6ae9619c5</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE highcharts-more</target_name>
<type>JS Include</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sp_dependency_5a548d07db5932002e5df2b6ae9619bf</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_dependency"><sp_dependency action="INSERT_OR_UPDATE"><module/><name>PE Highcharts 5.0.5</name><page_load>false</page_load><sp_portals/><sys_class_name>sp_dependency</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:01:46</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>5a548d07db5932002e5df2b6ae9619bf</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE Highcharts 5.0.5</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>sp_dependency_5a548d07db5932002e5df2b6ae9619bf</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:01:46</sys_updated_on></sp_dependency></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>ebdbb59fdbd532002e5df2b6ae9619c4</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5.0.5</target_name>
<type>Widget Dependency</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>m2m_sp_dependency_js_include_bd340d07db5932002e5df2b6ae9619ec</name>
<payload><![CDATA[<?xml version="1.0" encoding="UTF-8"?><record_update table="m2m_sp_dependency_js_include"><m2m_sp_dependency_js_include action="INSERT_OR_UPDATE"><order>100</order><sp_dependency display_value="PE HighchartsNG">c722c9c3db5932002e5df2b6ae96193b</sp_dependency><sp_js_include display_value="PE highcharts-ng">b3244d07db5932002e5df2b6ae96197e</sp_js_include><sys_class_name>m2m_sp_dependency_js_include</sys_class_name><sys_created_by>dachtman</sys_created_by><sys_created_on>2017-03-08 22:00:59</sys_created_on><sys_customer_update>true</sys_customer_update><sys_id>bd340d07db5932002e5df2b6ae9619ec</sys_id><sys_mod_count>0</sys_mod_count><sys_name>PE HighchartsNG.PE highcharts-ng</sys_name><sys_package display_value="Global" source="global">global</sys_package><sys_policy/><sys_replace_on_upgrade>false</sys_replace_on_upgrade><sys_scope display_value="Global">global</sys_scope><sys_update_name>m2m_sp_dependency_js_include_bd340d07db5932002e5df2b6ae9619ec</sys_update_name><sys_updated_by>dachtman</sys_updated_by><sys_updated_on>2017-03-08 22:00:59</sys_updated_on></m2m_sp_dependency_js_include></record_update>]]></payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>efdbb59fdbd532002e5df2b6ae9619c3</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE HighchartsNG.PE highcharts-ng</target_name>
<type>Dependency JS Includes</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ui_script_5752058bdbd53200f687dfea5e9619f8</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_ui_script"&gt;&lt;sys_ui_script action="INSERT_OR_UPDATE"&gt;&lt;active&gt;true&lt;/active&gt;&lt;description/&gt;&lt;global&gt;false&lt;/global&gt;&lt;name&gt;PE Highcharts 5_0_5&lt;/name&gt;&lt;script&gt;&lt;![CDATA[/*
 Highcharts JS v5.0.5 (2016-11-29)
 
 (c) 2009-2016 Torstein Honsi

 License: www.highcharts.com/license
*/
(function(M, a) {
	"object" === typeof module &amp;&amp; module.exports ? module.exports = M.document ? a(M) : a : M.Highcharts = a(M)
})("undefined" !== typeof window ? window : this, function(M) {
	M = function() {
		var a = window,
			E = a.document,
			A = a.navigator &amp;&amp; a.navigator.userAgent || "",
			F = E &amp;&amp; E.createElementNS &amp;&amp; !!E.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
			H = /(edge|msie|trident)/i.test(A) &amp;&amp; !window.opera,
			p = !F,
			d = /Firefox/.test(A),
			g = d &amp;&amp; 4 &gt; parseInt(A.split("Firefox/")[1], 10);
		return a.Highcharts ? a.Highcharts.error(16, !0) : {
			product: "Highcharts",
			version: "5.0.5",
			deg2rad: 2 * Math.PI / 360,
			doc: E,
			hasBidiBug: g,
			hasTouch: E &amp;&amp; void 0 !== E.documentElement.ontouchstart,
			isMS: H,
			isWebKit: /AppleWebKit/.test(A),
			isFirefox: d,
			isTouchDevice: /(Mobile|Android|Windows Phone)/.test(A),
			SVG_NS: "http://www.w3.org/2000/svg",
			chartCount: 0,
			seriesTypes: {},
			symbolSizes: {},
			svg: F,
			vml: p,
			win: a,
			charts: [],
			marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
			noop: function() {}
		}
	}();
	(function(a) {
		var E = [],
			A = a.charts,
			F = a.doc,
			H = a.win;
		a.error = function(a, d) {
			a = "Highcharts error #" +
				a + ": www.highcharts.com/errors/" + a;
			if (d) throw Error(a);
			H.console &amp;&amp; console.log(a)
		};
		a.Fx = function(a, d, g) {
			this.options = d;
			this.elem = a;
			this.prop = g
		};
		a.Fx.prototype = {
			dSetter: function() {
				var a = this.paths[0],
					d = this.paths[1],
					g = [],
					v = this.now,
					l = a.length,
					r;
				if (1 === v) g = this.toD;
				else if (l === d.length &amp;&amp; 1 &gt; v)
					for (; l--;) r = parseFloat(a[l]), g[l] = isNaN(r) ? a[l] : v * parseFloat(d[l] - r) + r;
				else g = d;
				this.elem.attr("d", g, null, !0)
			},
			update: function() {
				var a = this.elem,
					d = this.prop,
					g = this.now,
					v = this.options.step;
				if (this[d + "Setter"]) this[d +
					"Setter"]();
				else a.attr ? a.element &amp;&amp; a.attr(d, g, null, !0) : a.style[d] = g + this.unit;
				v &amp;&amp; v.call(a, g, this)
			},
			run: function(a, d, g) {
				var p = this,
					l = function(a) {
						return l.stopped ? !1 : p.step(a)
					},
					r;
				this.startTime = +new Date;
				this.start = a;
				this.end = d;
				this.unit = g;
				this.now = this.start;
				this.pos = 0;
				l.elem = this.elem;
				l.prop = this.prop;
				l() &amp;&amp; 1 === E.push(l) &amp;&amp; (l.timerId = setInterval(function() {
					for (r = 0; r &lt; E.length; r++) E[r]() || E.splice(r--, 1);
					E.length || clearInterval(l.timerId)
				}, 13))
			},
			step: function(a) {
				var d = +new Date,
					g, p = this.options;
				g = this.elem;
				var l = p.complete,
					r = p.duration,
					f = p.curAnim,
					b;
				if (g.attr &amp;&amp; !g.element) g = !1;
				else if (a || d &gt;= r + this.startTime) {
					this.now = this.end;
					this.pos = 1;
					this.update();
					a = f[this.prop] = !0;
					for (b in f) !0 !== f[b] &amp;&amp; (a = !1);
					a &amp;&amp; l &amp;&amp; l.call(g);
					g = !1
				} else this.pos = p.easing((d - this.startTime) / r), this.now = this.start + (this.end - this.start) * this.pos, this.update(), g = !0;
				return g
			},
			initPath: function(a, d, g) {
				function p(a) {
					var c, e;
					for (h = a.length; h--;) c = "M" === a[h] || "L" === a[h], e = /[a-zA-Z]/.test(a[h + 3]), c &amp;&amp; e &amp;&amp; a.splice(h + 1, 0, a[h + 1], a[h + 2], a[h + 1], a[h +
						2])
				}

				function l(a, c) {
					for (; a.length &lt; k;) {
						a[0] = c[k - a.length];
						var e = a.slice(0, t);
						[].splice.apply(a, [0, 0].concat(e));
						C &amp;&amp; (e = a.slice(a.length - t), [].splice.apply(a, [a.length, 0].concat(e)), h--)
					}
					a[0] = "M"
				}

				function r(a, c) {
					for (var b = (k - a.length) / t; 0 &lt; b &amp;&amp; b--;) e = a.slice().splice(a.length / u - t, t * u), e[0] = c[k - t - b * t], w &amp;&amp; (e[t - 6] = e[t - 2], e[t - 5] = e[t - 1]), [].splice.apply(a, [a.length / u, 0].concat(e)), C &amp;&amp; b--
				}
				d = d || "";
				var f, b = a.startX,
					n = a.endX,
					w = -1 &lt; d.indexOf("C"),
					t = w ? 7 : 3,
					k, e, h;
				d = d.split(" ");
				g = g.slice();
				var C = a.isArea,
					u = C ? 2 : 1,
					c;
				w &amp;&amp; (p(d), p(g));
				if (b &amp;&amp; n) {
					for (h = 0; h &lt; b.length; h++)
						if (b[h] === n[0]) {
							f = h;
							break
						} else if (b[0] === n[n.length - b.length + h]) {
						f = h;
						c = !0;
						break
					}
					void 0 === f &amp;&amp; (d = [])
				}
				d.length &amp;&amp; (k = g.length + (f || 0) * u * t, c ? (l(d, g), r(g, d)) : (l(g, d), r(d, g)));
				return [d, g]
			}
		};
		a.extend = function(a, d) {
			var g;
			a || (a = {});
			for (g in d) a[g] = d[g];
			return a
		};
		a.merge = function() {
			var p, d = arguments,
				g, v = {},
				l = function(d, f) {
					var b, n;
					"object" !== typeof d &amp;&amp; (d = {});
					for (n in f) f.hasOwnProperty(n) &amp;&amp; (b = f[n], a.isObject(b, !0) &amp;&amp; "renderTo" !== n &amp;&amp; "number" !== typeof b.nodeType ? d[n] =
						l(d[n] || {}, b) : d[n] = f[n]);
					return d
				};
			!0 === d[0] &amp;&amp; (v = d[1], d = Array.prototype.slice.call(d, 2));
			g = d.length;
			for (p = 0; p &lt; g; p++) v = l(v, d[p]);
			return v
		};
		a.pInt = function(a, d) {
			return parseInt(a, d || 10)
		};
		a.isString = function(a) {
			return "string" === typeof a
		};
		a.isArray = function(a) {
			a = Object.prototype.toString.call(a);
			return "[object Array]" === a || "[object Array Iterator]" === a
		};
		a.isObject = function(p, d) {
			return p &amp;&amp; "object" === typeof p &amp;&amp; (!d || !a.isArray(p))
		};
		a.isNumber = function(a) {
			return "number" === typeof a &amp;&amp; !isNaN(a)
		};
		a.erase = function(a,
			d) {
			for (var g = a.length; g--;)
				if (a[g] === d) {
					a.splice(g, 1);
					break
				}
		};
		a.defined = function(a) {
			return void 0 !== a &amp;&amp; null !== a
		};
		a.attr = function(p, d, g) {
			var v, l;
			if (a.isString(d)) a.defined(g) ? p.setAttribute(d, g) : p &amp;&amp; p.getAttribute &amp;&amp; (l = p.getAttribute(d));
			else if (a.defined(d) &amp;&amp; a.isObject(d))
				for (v in d) p.setAttribute(v, d[v]);
			return l
		};
		a.splat = function(p) {
			return a.isArray(p) ? p : [p]
		};
		a.syncTimeout = function(a, d, g) {
			if (d) return setTimeout(a, d, g);
			a.call(0, g)
		};
		a.pick = function() {
			var a = arguments,
				d, g, v = a.length;
			for (d = 0; d &lt; v; d++)
				if (g =
					a[d], void 0 !== g &amp;&amp; null !== g) return g
		};
		a.css = function(p, d) {
			a.isMS &amp;&amp; !a.svg &amp;&amp; d &amp;&amp; void 0 !== d.opacity &amp;&amp; (d.filter = "alpha(opacity\x3d" + 100 * d.opacity + ")");
			a.extend(p.style, d)
		};
		a.createElement = function(p, d, g, v, l) {
			p = F.createElement(p);
			var r = a.css;
			d &amp;&amp; a.extend(p, d);
			l &amp;&amp; r(p, {
				padding: 0,
				border: "none",
				margin: 0
			});
			g &amp;&amp; r(p, g);
			v &amp;&amp; v.appendChild(p);
			return p
		};
		a.extendClass = function(p, d) {
			var g = function() {};
			g.prototype = new p;
			a.extend(g.prototype, d);
			return g
		};
		a.pad = function(a, d, g) {
			return Array((d || 2) + 1 - String(a).length).join(g ||
				0) + a
		};
		a.relativeLength = function(a, d) {
			return /%$/.test(a) ? d * parseFloat(a) / 100 : parseFloat(a)
		};
		a.wrap = function(a, d, g) {
			var p = a[d];
			a[d] = function() {
				var a = Array.prototype.slice.call(arguments),
					d = arguments,
					f = this;
				f.proceed = function() {
					p.apply(f, arguments.length ? arguments : d)
				};
				a.unshift(p);
				a = g.apply(this, a);
				f.proceed = null;
				return a
			}
		};
		a.getTZOffset = function(p) {
			var d = a.Date;
			return 6E4 * (d.hcGetTimezoneOffset &amp;&amp; d.hcGetTimezoneOffset(p) || d.hcTimezoneOffset || 0)
		};
		a.dateFormat = function(p, d, g) {
			if (!a.defined(d) || isNaN(d)) return a.defaultOptions.lang.invalidDate ||
				"";
			p = a.pick(p, "%Y-%m-%d %H:%M:%S");
			var v = a.Date,
				l = new v(d - a.getTZOffset(d)),
				r, f = l[v.hcGetHours](),
				b = l[v.hcGetDay](),
				n = l[v.hcGetDate](),
				w = l[v.hcGetMonth](),
				t = l[v.hcGetFullYear](),
				k = a.defaultOptions.lang,
				e = k.weekdays,
				h = k.shortWeekdays,
				C = a.pad,
				v = a.extend({
					a: h ? h[b] : e[b].substr(0, 3),
					A: e[b],
					d: C(n),
					e: C(n, 2, " "),
					w: b,
					b: k.shortMonths[w],
					B: k.months[w],
					m: C(w + 1),
					y: t.toString().substr(2, 2),
					Y: t,
					H: C(f),
					k: f,
					I: C(f % 12 || 12),
					l: f % 12 || 12,
					M: C(l[v.hcGetMinutes]()),
					p: 12 &gt; f ? "AM" : "PM",
					P: 12 &gt; f ? "am" : "pm",
					S: C(l.getSeconds()),
					L: C(Math.round(d %
						1E3), 3)
				}, a.dateFormats);
			for (r in v)
				for (; - 1 !== p.indexOf("%" + r);) p = p.replace("%" + r, "function" === typeof v[r] ? v[r](d) : v[r]);
			return g ? p.substr(0, 1).toUpperCase() + p.substr(1) : p
		};
		a.formatSingle = function(p, d) {
			var g = /\.([0-9])/,
				v = a.defaultOptions.lang;
			/f$/.test(p) ? (g = (g = p.match(g)) ? g[1] : -1, null !== d &amp;&amp; (d = a.numberFormat(d, g, v.decimalPoint, -1 &lt; p.indexOf(",") ? v.thousandsSep : ""))) : d = a.dateFormat(p, d);
			return d
		};
		a.format = function(p, d) {
			for (var g = "{", v = !1, l, r, f, b, n = [], w; p;) {
				g = p.indexOf(g);
				if (-1 === g) break;
				l = p.slice(0,
					g);
				if (v) {
					l = l.split(":");
					r = l.shift().split(".");
					b = r.length;
					w = d;
					for (f = 0; f &lt; b; f++) w = w[r[f]];
					l.length &amp;&amp; (w = a.formatSingle(l.join(":"), w));
					n.push(w)
				} else n.push(l);
				p = p.slice(g + 1);
				g = (v = !v) ? "}" : "{"
			}
			n.push(p);
			return n.join("")
		};
		a.getMagnitude = function(a) {
			return Math.pow(10, Math.floor(Math.log(a) / Math.LN10))
		};
		a.normalizeTickInterval = function(p, d, g, v, l) {
			var r, f = p;
			g = a.pick(g, 1);
			r = p / g;
			d || (d = l ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === v &amp;&amp; (1 === g ? d = a.grep(d, function(a) {
				return 0 === a % 1
			}) : .1 &gt;= g &amp;&amp; (d = [1 / g])));
			for (v = 0; v &lt; d.length &amp;&amp; !(f = d[v], l &amp;&amp; f * g &gt;= p || !l &amp;&amp; r &lt;= (d[v] + (d[v + 1] || d[v])) / 2); v++);
			return f * g
		};
		a.stableSort = function(a, d) {
			var g = a.length,
				p, l;
			for (l = 0; l &lt; g; l++) a[l].safeI = l;
			a.sort(function(a, f) {
				p = d(a, f);
				return 0 === p ? a.safeI - f.safeI : p
			});
			for (l = 0; l &lt; g; l++) delete a[l].safeI
		};
		a.arrayMin = function(a) {
			for (var d = a.length, g = a[0]; d--;) a[d] &lt; g &amp;&amp; (g = a[d]);
			return g
		};
		a.arrayMax = function(a) {
			for (var d = a.length, g = a[0]; d--;) a[d] &gt; g &amp;&amp; (g = a[d]);
			return g
		};
		a.destroyObjectProperties = function(a, d) {
			for (var g in a) a[g] &amp;&amp; a[g] !== d &amp;&amp; a[g].destroy &amp;&amp;
				a[g].destroy(), delete a[g]
		};
		a.discardElement = function(p) {
			var d = a.garbageBin;
			d || (d = a.createElement("div"));
			p &amp;&amp; d.appendChild(p);
			d.innerHTML = ""
		};
		a.correctFloat = function(a, d) {
			return parseFloat(a.toPrecision(d || 14))
		};
		a.setAnimation = function(p, d) {
			d.renderer.globalAnimation = a.pick(p, d.options.chart.animation, !0)
		};
		a.animObject = function(p) {
			return a.isObject(p) ? a.merge(p) : {
				duration: p ? 500 : 0
			}
		};
		a.timeUnits = {
			millisecond: 1,
			second: 1E3,
			minute: 6E4,
			hour: 36E5,
			day: 864E5,
			week: 6048E5,
			month: 24192E5,
			year: 314496E5
		};
		a.numberFormat =
			function(p, d, g, v) {
				p = +p || 0;
				d = +d;
				var l = a.defaultOptions.lang,
					r = (p.toString().split(".")[1] || "").length,
					f, b, n = Math.abs(p); - 1 === d ? d = Math.min(r, 20) : a.isNumber(d) || (d = 2);
				f = String(a.pInt(n.toFixed(d)));
				b = 3 &lt; f.length ? f.length % 3 : 0;
				g = a.pick(g, l.decimalPoint);
				v = a.pick(v, l.thousandsSep);
				p = (0 &gt; p ? "-" : "") + (b ? f.substr(0, b) + v : "");
				p += f.substr(b).replace(/(\d{3})(?=\d)/g, "$1" + v);
				d &amp;&amp; (v = Math.abs(n - f + Math.pow(10, -Math.max(d, r) - 1)), p += g + v.toFixed(d).slice(2));
				return p
			};
		Math.easeInOutSine = function(a) {
			return -.5 * (Math.cos(Math.PI *
				a) - 1)
		};
		a.getStyle = function(p, d) {
			return "width" === d ? Math.min(p.offsetWidth, p.scrollWidth) - a.getStyle(p, "padding-left") - a.getStyle(p, "padding-right") : "height" === d ? Math.min(p.offsetHeight, p.scrollHeight) - a.getStyle(p, "padding-top") - a.getStyle(p, "padding-bottom") : (p = H.getComputedStyle(p, void 0)) &amp;&amp; a.pInt(p.getPropertyValue(d))
		};
		a.inArray = function(a, d) {
			return d.indexOf ? d.indexOf(a) : [].indexOf.call(d, a)
		};
		a.grep = function(a, d) {
			return [].filter.call(a, d)
		};
		a.map = function(a, d) {
			for (var g = [], v = 0, l = a.length; v &lt; l; v++) g[v] =
				d.call(a[v], a[v], v, a);
			return g
		};
		a.offset = function(a) {
			var d = F.documentElement;
			a = a.getBoundingClientRect();
			return {
				top: a.top + (H.pageYOffset || d.scrollTop) - (d.clientTop || 0),
				left: a.left + (H.pageXOffset || d.scrollLeft) - (d.clientLeft || 0)
			}
		};
		a.stop = function(a, d) {
			for (var g = E.length; g--;) E[g].elem !== a || d &amp;&amp; d !== E[g].prop || (E[g].stopped = !0)
		};
		a.each = function(a, d, g) {
			return Array.prototype.forEach.call(a, d, g)
		};
		a.addEvent = function(p, d, g) {
			function v(a) {
				a.target = a.srcElement || H;
				g.call(p, a)
			}
			var l = p.hcEvents = p.hcEvents || {};
			p.addEventListener ? p.addEventListener(d, g, !1) : p.attachEvent &amp;&amp; (p.hcEventsIE || (p.hcEventsIE = {}), p.hcEventsIE[g.toString()] = v, p.attachEvent("on" + d, v));
			l[d] || (l[d] = []);
			l[d].push(g);
			return function() {
				a.removeEvent(p, d, g)
			}
		};
		a.removeEvent = function(p, d, g) {
			function v(a, b) {
				p.removeEventListener ? p.removeEventListener(a, b, !1) : p.attachEvent &amp;&amp; (b = p.hcEventsIE[b.toString()], p.detachEvent("on" + a, b))
			}

			function l() {
				var a, b;
				if (p.nodeName)
					for (b in d ? (a = {}, a[d] = !0) : a = f, a)
						if (f[b])
							for (a = f[b].length; a--;) v(b, f[b][a])
			}
			var r,
				f = p.hcEvents,
				b;
			f &amp;&amp; (d ? (r = f[d] || [], g ? (b = a.inArray(g, r), -1 &lt; b &amp;&amp; (r.splice(b, 1), f[d] = r), v(d, g)) : (l(), f[d] = [])) : (l(), p.hcEvents = {}))
		};
		a.fireEvent = function(p, d, g, v) {
			var l;
			l = p.hcEvents;
			var r, f;
			g = g || {};
			if (F.createEvent &amp;&amp; (p.dispatchEvent || p.fireEvent)) l = F.createEvent("Events"), l.initEvent(d, !0, !0), a.extend(l, g), p.dispatchEvent ? p.dispatchEvent(l) : p.fireEvent(d, l);
			else if (l)
				for (l = l[d] || [], r = l.length, g.target || a.extend(g, {
						preventDefault: function() {
							g.defaultPrevented = !0
						},
						target: p,
						type: d
					}), d = 0; d &lt; r; d++)(f = l[d]) &amp;&amp;
					!1 === f.call(p, g) &amp;&amp; g.preventDefault();
			v &amp;&amp; !g.defaultPrevented &amp;&amp; v(g)
		};
		a.animate = function(p, d, g) {
			var v, l = "",
				r, f, b;
			a.isObject(g) || (v = arguments, g = {
				duration: v[2],
				easing: v[3],
				complete: v[4]
			});
			a.isNumber(g.duration) || (g.duration = 400);
			g.easing = "function" === typeof g.easing ? g.easing : Math[g.easing] || Math.easeInOutSine;
			g.curAnim = a.merge(d);
			for (b in d) a.stop(p, b), f = new a.Fx(p, g, b), r = null, "d" === b ? (f.paths = f.initPath(p, p.d, d.d), f.toD = d.d, v = 0, r = 1) : p.attr ? v = p.attr(b) : (v = parseFloat(a.getStyle(p, b)) || 0, "opacity" !== b &amp;&amp;
				(l = "px")), r || (r = d[b]), r.match &amp;&amp; r.match("px") &amp;&amp; (r = r.replace(/px/g, "")), f.run(v, r, l)
		};
		a.seriesType = function(p, d, g, v, l) {
			var r = a.getOptions(),
				f = a.seriesTypes;
			r.plotOptions[p] = a.merge(r.plotOptions[d], g);
			f[p] = a.extendClass(f[d] || function() {}, v);
			f[p].prototype.type = p;
			l &amp;&amp; (f[p].prototype.pointClass = a.extendClass(a.Point, l));
			return f[p]
		};
		a.uniqueKey = function() {
			var a = Math.random().toString(36).substring(2, 9),
				d = 0;
			return function() {
				return "highcharts-" + a + "-" + d++
			}
		}();
		H.jQuery &amp;&amp; (H.jQuery.fn.highcharts = function() {
			var p = [].slice.call(arguments);
			if (this[0]) return p[0] ? (new(a[a.isString(p[0]) ? p.shift() : "Chart"])(this[0], p[0], p[1]), this) : A[a.attr(this[0], "data-highcharts-chart")]
		});
		F &amp;&amp; !F.defaultView &amp;&amp; (a.getStyle = function(p, d) {
			var g = {
				width: "clientWidth",
				height: "clientHeight"
			}[d];
			if (p.style[d]) return a.pInt(p.style[d]);
			"opacity" === d &amp;&amp; (d = "filter");
			if (g) return p.style.zoom = 1, Math.max(p[g] - 2 * a.getStyle(p, "padding"), 0);
			p = p.currentStyle[d.replace(/\-(\w)/g, function(a, l) {
				return l.toUpperCase()
			})];
			"filter" === d &amp;&amp; (p = p.replace(/alpha\(opacity=([0-9]+)\)/,
				function(a, l) {
					return l / 100
				}));
			return "" === p ? 1 : a.pInt(p)
		});
		Array.prototype.forEach || (a.each = function(a, d, g) {
			for (var v = 0, l = a.length; v &lt; l; v++)
				if (!1 === d.call(g, a[v], v, a)) return v
		});
		Array.prototype.indexOf || (a.inArray = function(a, d) {
			var g, v = 0;
			if (d)
				for (g = d.length; v &lt; g; v++)
					if (d[v] === a) return v;
			return -1
		});
		Array.prototype.filter || (a.grep = function(a, d) {
			for (var g = [], v = 0, l = a.length; v &lt; l; v++) d(a[v], v) &amp;&amp; g.push(a[v]);
			return g
		})
	})(M);
	(function(a) {
		var E = a.each,
			A = a.isNumber,
			F = a.map,
			H = a.merge,
			p = a.pInt;
		a.Color = function(d) {
			if (!(this instanceof a.Color)) return new a.Color(d);
			this.init(d)
		};
		a.Color.prototype = {
			parsers: [{
				regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
				parse: function(a) {
					return [p(a[1]), p(a[2]), p(a[3]), parseFloat(a[4], 10)]
				}
			}, {
				regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
				parse: function(a) {
					return [p(a[1], 16), p(a[2], 16), p(a[3], 16), 1]
				}
			}, {
				regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
				parse: function(a) {
					return [p(a[1]), p(a[2]), p(a[3]), 1]
				}
			}],
			names: {
				white: "#ffffff",
				black: "#000000"
			},
			init: function(d) {
				var g, v, l, r;
				if ((this.input = d = this.names[d] || d) &amp;&amp; d.stops) this.stops = F(d.stops, function(f) {
					return new a.Color(f[1])
				});
				else
					for (l = this.parsers.length; l-- &amp;&amp; !v;) r = this.parsers[l], (g = r.regex.exec(d)) &amp;&amp; (v = r.parse(g));
				this.rgba = v || []
			},
			get: function(a) {
				var g = this.input,
					d = this.rgba,
					l;
				this.stops ? (l = H(g), l.stops = [].concat(l.stops), E(this.stops, function(d, f) {
						l.stops[f] = [l.stops[f][0], d.get(a)]
					})) : l = d &amp;&amp; A(d[0]) ? "rgb" === a || !a &amp;&amp; 1 === d[3] ? "rgb(" + d[0] + "," + d[1] + "," + d[2] + ")" : "a" === a ? d[3] :
					"rgba(" + d.join(",") + ")" : g;
				return l
			},
			brighten: function(a) {
				var d, v = this.rgba;
				if (this.stops) E(this.stops, function(l) {
					l.brighten(a)
				});
				else if (A(a) &amp;&amp; 0 !== a)
					for (d = 0; 3 &gt; d; d++) v[d] += p(255 * a), 0 &gt; v[d] &amp;&amp; (v[d] = 0), 255 &lt; v[d] &amp;&amp; (v[d] = 255);
				return this
			},
			setOpacity: function(a) {
				this.rgba[3] = a;
				return this
			}
		};
		a.color = function(d) {
			return new a.Color(d)
		}
	})(M);
	(function(a) {
		var E, A, F = a.addEvent,
			H = a.animate,
			p = a.attr,
			d = a.charts,
			g = a.color,
			v = a.css,
			l = a.createElement,
			r = a.defined,
			f = a.deg2rad,
			b = a.destroyObjectProperties,
			n = a.doc,
			w = a.each,
			t = a.extend,
			k = a.erase,
			e = a.grep,
			h = a.hasTouch,
			C = a.isArray,
			u = a.isFirefox,
			c = a.isMS,
			q = a.isObject,
			x = a.isString,
			K = a.isWebKit,
			I = a.merge,
			J = a.noop,
			D = a.pick,
			G = a.pInt,
			L = a.removeEvent,
			N = a.stop,
			m = a.svg,
			z = a.SVG_NS,
			O = a.symbolSizes,
			P = a.win;
		E = a.SVGElement = function() {
			return this
		};
		E.prototype = {
			opacity: 1,
			SVG_NS: z,
			textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textDecoration textOverflow textOutline".split(" "),
			init: function(a, B) {
				this.element = "span" === B ? l(B) : n.createElementNS(this.SVG_NS,
					B);
				this.renderer = a
			},
			animate: function(a, B, c) {
				(B = D(B, this.renderer.globalAnimation, !0)) ? (c &amp;&amp; (B.complete = c), H(this, a, B)) : this.attr(a, null, c);
				return this
			},
			colorGradient: function(y, B, c) {
				var m = this.renderer,
					b, e, z, q, k, Q, h, f, x, n, t, u = [],
					D;
				y.linearGradient ? e = "linearGradient" : y.radialGradient &amp;&amp; (e = "radialGradient");
				if (e) {
					z = y[e];
					k = m.gradients;
					h = y.stops;
					n = c.radialReference;
					C(z) &amp;&amp; (y[e] = z = {
						x1: z[0],
						y1: z[1],
						x2: z[2],
						y2: z[3],
						gradientUnits: "userSpaceOnUse"
					});
					"radialGradient" === e &amp;&amp; n &amp;&amp; !r(z.gradientUnits) &amp;&amp; (q = z, z = I(z, m.getRadialAttr(n,
						q), {
						gradientUnits: "userSpaceOnUse"
					}));
					for (t in z) "id" !== t &amp;&amp; u.push(t, z[t]);
					for (t in h) u.push(h[t]);
					u = u.join(",");
					k[u] ? n = k[u].attr("id") : (z.id = n = a.uniqueKey(), k[u] = Q = m.createElement(e).attr(z).add(m.defs), Q.radAttr = q, Q.stops = [], w(h, function(y) {
						0 === y[1].indexOf("rgba") ? (b = a.color(y[1]), f = b.get("rgb"), x = b.get("a")) : (f = y[1], x = 1);
						y = m.createElement("stop").attr({
							offset: y[0],
							"stop-color": f,
							"stop-opacity": x
						}).add(Q);
						Q.stops.push(y)
					}));
					D = "url(" + m.url + "#" + n + ")";
					c.setAttribute(B, D);
					c.gradient = u;
					y.toString = function() {
						return D
					}
				}
			},
			applyTextOutline: function(a) {
				var y = this.element,
					c, m, b; - 1 !== a.indexOf("contrast") &amp;&amp; (a = a.replace(/contrast/g, this.renderer.getContrast(y.style.fill)));
				this.fakeTS = !0;
				this.ySetter = this.xSetter;
				c = [].slice.call(y.getElementsByTagName("tspan"));
				a = a.split(" ");
				m = a[a.length - 1];
				(b = a[0]) &amp;&amp; "none" !== b &amp;&amp; (b = b.replace(/(^[\d\.]+)(.*?)$/g, function(a, y, B) {
					return 2 * y + B
				}), w(c, function(a) {
					"highcharts-text-outline" === a.getAttribute("class") &amp;&amp; k(c, y.removeChild(a))
				}), w(c, function(a, B) {
					0 === B &amp;&amp; (a.setAttribute("x", y.getAttribute("x")),
						B = y.getAttribute("y"), a.setAttribute("y", B || 0), null === B &amp;&amp; y.setAttribute("y", 0));
					a = a.cloneNode(1);
					p(a, {
						"class": "highcharts-text-outline",
						fill: m,
						stroke: m,
						"stroke-width": b,
						"stroke-linejoin": "round"
					});
					y.insertBefore(a, y.firstChild)
				}))
			},
			attr: function(a, B, c, m) {
				var y, b = this.element,
					e, z = this,
					q;
				"string" === typeof a &amp;&amp; void 0 !== B &amp;&amp; (y = a, a = {}, a[y] = B);
				if ("string" === typeof a) z = (this[a + "Getter"] || this._defaultGetter).call(this, a, b);
				else {
					for (y in a) B = a[y], q = !1, m || N(this, y), this.symbolName &amp;&amp; /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(y) &amp;&amp;
						(e || (this.symbolAttr(a), e = !0), q = !0), !this.rotation || "x" !== y &amp;&amp; "y" !== y || (this.doTransform = !0), q || (q = this[y + "Setter"] || this._defaultSetter, q.call(this, B, y, b), this.shadows &amp;&amp; /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(y) &amp;&amp; this.updateShadows(y, B, q));
					this.doTransform &amp;&amp; (this.updateTransform(), this.doTransform = !1)
				}
				c &amp;&amp; c();
				return z
			},
			updateShadows: function(a, B, c) {
				for (var y = this.shadows, m = y.length; m--;) c.call(y[m], "height" === a ? Math.max(B - (y[m].cutHeight || 0), 0) : "d" === a ? this.d : B, a, y[m])
			},
			addClass: function(a,
				B) {
				var y = this.attr("class") || ""; - 1 === y.indexOf(a) &amp;&amp; (B || (a = (y + (y ? " " : "") + a).replace("  ", " ")), this.attr("class", a));
				return this
			},
			hasClass: function(a) {
				return -1 !== p(this.element, "class").indexOf(a)
			},
			removeClass: function(a) {
				p(this.element, "class", (p(this.element, "class") || "").replace(a, ""));
				return this
			},
			symbolAttr: function(a) {
				var y = this;
				w("x y r start end width height innerR anchorX anchorY".split(" "), function(B) {
					y[B] = D(a[B], y[B])
				});
				y.attr({
					d: y.renderer.symbols[y.symbolName](y.x, y.y, y.width, y.height,
						y)
				})
			},
			clip: function(a) {
				return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none")
			},
			crisp: function(a, B) {
				var y, c = {},
					m;
				B = B || a.strokeWidth || 0;
				m = Math.round(B) % 2 / 2;
				a.x = Math.floor(a.x || this.x || 0) + m;
				a.y = Math.floor(a.y || this.y || 0) + m;
				a.width = Math.floor((a.width || this.width || 0) - 2 * m);
				a.height = Math.floor((a.height || this.height || 0) - 2 * m);
				r(a.strokeWidth) &amp;&amp; (a.strokeWidth = B);
				for (y in a) this[y] !== a[y] &amp;&amp; (this[y] = c[y] = a[y]);
				return c
			},
			css: function(a) {
				var y = this.styles,
					b = {},
					e = this.element,
					z, q, k = "";
				z = !y;
				a &amp;&amp; a.color &amp;&amp; (a.fill = a.color);
				if (y)
					for (q in a) a[q] !== y[q] &amp;&amp; (b[q] = a[q], z = !0);
				if (z) {
					z = this.textWidth = a &amp;&amp; a.width &amp;&amp; "text" === e.nodeName.toLowerCase() &amp;&amp; G(a.width) || this.textWidth;
					y &amp;&amp; (a = t(y, b));
					this.styles = a;
					z &amp;&amp; !m &amp;&amp; this.renderer.forExport &amp;&amp; delete a.width;
					if (c &amp;&amp; !m) v(this.element, a);
					else {
						y = function(a, y) {
							return "-" + y.toLowerCase()
						};
						for (q in a) k += q.replace(/([A-Z])/g, y) + ":" + a[q] + ";";
						p(e, "style", k)
					}
					this.added &amp;&amp; (z &amp;&amp; this.renderer.buildText(this), a &amp;&amp; a.textOutline &amp;&amp; this.applyTextOutline(a.textOutline))
				}
				return this
			},
			strokeWidth: function() {
				return this["stroke-width"] || 0
			},
			on: function(a, B) {
				var y = this,
					c = y.element;
				h &amp;&amp; "click" === a ? (c.ontouchstart = function(a) {
					y.touchEventFired = Date.now();
					a.preventDefault();
					B.call(c, a)
				}, c.onclick = function(a) {
					(-1 === P.navigator.userAgent.indexOf("Android") || 1100 &lt; Date.now() - (y.touchEventFired || 0)) &amp;&amp; B.call(c, a)
				}) : c["on" + a] = B;
				return this
			},
			setRadialReference: function(a) {
				var y = this.renderer.gradients[this.element.gradient];
				this.element.radialReference = a;
				y &amp;&amp; y.radAttr &amp;&amp; y.animate(this.renderer.getRadialAttr(a,
					y.radAttr));
				return this
			},
			translate: function(a, B) {
				return this.attr({
					translateX: a,
					translateY: B
				})
			},
			invert: function(a) {
				this.inverted = a;
				this.updateTransform();
				return this
			},
			updateTransform: function() {
				var a = this.translateX || 0,
					B = this.translateY || 0,
					c = this.scaleX,
					m = this.scaleY,
					b = this.inverted,
					e = this.rotation,
					z = this.element;
				b &amp;&amp; (a += this.attr("width"), B += this.attr("height"));
				a = ["translate(" + a + "," + B + ")"];
				b ? a.push("rotate(90) scale(-1,1)") : e &amp;&amp; a.push("rotate(" + e + " " + (z.getAttribute("x") || 0) + " " + (z.getAttribute("y") ||
					0) + ")");
				(r(c) || r(m)) &amp;&amp; a.push("scale(" + D(c, 1) + " " + D(m, 1) + ")");
				a.length &amp;&amp; z.setAttribute("transform", a.join(" "))
			},
			toFront: function() {
				var a = this.element;
				a.parentNode.appendChild(a);
				return this
			},
			align: function(a, B, c) {
				var y, m, b, e, z = {};
				m = this.renderer;
				b = m.alignedObjects;
				var q, h;
				if (a) {
					if (this.alignOptions = a, this.alignByTranslate = B, !c || x(c)) this.alignTo = y = c || "renderer", k(b, this), b.push(this), c = null
				} else a = this.alignOptions, B = this.alignByTranslate, y = this.alignTo;
				c = D(c, m[y], m);
				y = a.align;
				m = a.verticalAlign;
				b =
					(c.x || 0) + (a.x || 0);
				e = (c.y || 0) + (a.y || 0);
				"right" === y ? q = 1 : "center" === y &amp;&amp; (q = 2);
				q &amp;&amp; (b += (c.width - (a.width || 0)) / q);
				z[B ? "translateX" : "x"] = Math.round(b);
				"bottom" === m ? h = 1 : "middle" === m &amp;&amp; (h = 2);
				h &amp;&amp; (e += (c.height - (a.height || 0)) / h);
				z[B ? "translateY" : "y"] = Math.round(e);
				this[this.placed ? "animate" : "attr"](z);
				this.placed = !0;
				this.alignAttr = z;
				return this
			},
			getBBox: function(a, B) {
				var y, m = this.renderer,
					b, e = this.element,
					z = this.styles,
					q, k = this.textStr,
					h, x = m.cache,
					n = m.cacheKeys,
					u;
				B = D(B, this.rotation);
				b = B * f;
				q = z &amp;&amp; z.fontSize;
				void 0 !==
					k &amp;&amp; (u = k.toString(), -1 === u.indexOf("\x3c") &amp;&amp; (u = u.replace(/[0-9]/g, "0")), u += ["", B || 0, q, e.style.width, e.style["text-overflow"]].join());
				u &amp;&amp; !a &amp;&amp; (y = x[u]);
				if (!y) {
					if (e.namespaceURI === this.SVG_NS || m.forExport) {
						try {
							(h = this.fakeTS &amp;&amp; function(a) {
								w(e.querySelectorAll(".highcharts-text-outline"), function(y) {
									y.style.display = a
								})
							}) &amp;&amp; h("none"), y = e.getBBox ? t({}, e.getBBox()) : {
								width: e.offsetWidth,
								height: e.offsetHeight
							}, h &amp;&amp; h("")
						} catch (T) {}
						if (!y || 0 &gt; y.width) y = {
							width: 0,
							height: 0
						}
					} else y = this.htmlGetBBox();
					m.isSVG &amp;&amp; (a = y.width,
						m = y.height, c &amp;&amp; z &amp;&amp; "11px" === z.fontSize &amp;&amp; "16.9" === m.toPrecision(3) &amp;&amp; (y.height = m = 14), B &amp;&amp; (y.width = Math.abs(m * Math.sin(b)) + Math.abs(a * Math.cos(b)), y.height = Math.abs(m * Math.cos(b)) + Math.abs(a * Math.sin(b))));
					if (u &amp;&amp; 0 &lt; y.height) {
						for (; 250 &lt; n.length;) delete x[n.shift()];
						x[u] || n.push(u);
						x[u] = y
					}
				}
				return y
			},
			show: function(a) {
				return this.attr({
					visibility: a ? "inherit" : "visible"
				})
			},
			hide: function() {
				return this.attr({
					visibility: "hidden"
				})
			},
			fadeOut: function(a) {
				var y = this;
				y.animate({
					opacity: 0
				}, {
					duration: a || 150,
					complete: function() {
						y.attr({
							y: -9999
						})
					}
				})
			},
			add: function(a) {
				var y = this.renderer,
					c = this.element,
					m;
				a &amp;&amp; (this.parentGroup = a);
				this.parentInverted = a &amp;&amp; a.inverted;
				void 0 !== this.textStr &amp;&amp; y.buildText(this);
				this.added = !0;
				if (!a || a.handleZ || this.zIndex) m = this.zIndexSetter();
				m || (a ? a.element : y.box).appendChild(c);
				if (this.onAdd) this.onAdd();
				return this
			},
			safeRemoveChild: function(a) {
				var y = a.parentNode;
				y &amp;&amp; y.removeChild(a)
			},
			destroy: function() {
				var a = this.element || {},
					c = this.renderer.isSVG &amp;&amp; "SPAN" === a.nodeName &amp;&amp; this.parentGroup,
					m, b;
				a.onclick = a.onmouseout = a.onmouseover =
					a.onmousemove = a.point = null;
				N(this);
				this.clipPath &amp;&amp; (this.clipPath = this.clipPath.destroy());
				if (this.stops) {
					for (b = 0; b &lt; this.stops.length; b++) this.stops[b] = this.stops[b].destroy();
					this.stops = null
				}
				this.safeRemoveChild(a);
				for (this.destroyShadows(); c &amp;&amp; c.div &amp;&amp; 0 === c.div.childNodes.length;) a = c.parentGroup, this.safeRemoveChild(c.div), delete c.div, c = a;
				this.alignTo &amp;&amp; k(this.renderer.alignedObjects, this);
				for (m in this) delete this[m];
				return null
			},
			shadow: function(a, c, m) {
				var y = [],
					B, b, e = this.element,
					z, q, k, h;
				if (!a) this.destroyShadows();
				else if (!this.shadows) {
					q = D(a.width, 3);
					k = (a.opacity || .15) / q;
					h = this.parentInverted ? "(-1,-1)" : "(" + D(a.offsetX, 1) + ", " + D(a.offsetY, 1) + ")";
					for (B = 1; B &lt;= q; B++) b = e.cloneNode(0), z = 2 * q + 1 - 2 * B, p(b, {
						isShadow: "true",
						stroke: a.color || "#000000",
						"stroke-opacity": k * B,
						"stroke-width": z,
						transform: "translate" + h,
						fill: "none"
					}), m &amp;&amp; (p(b, "height", Math.max(p(b, "height") - z, 0)), b.cutHeight = z), c ? c.element.appendChild(b) : e.parentNode.insertBefore(b, e), y.push(b);
					this.shadows = y
				}
				return this
			},
			destroyShadows: function() {
				w(this.shadows || [], function(a) {
					this.safeRemoveChild(a)
				}, this);
				this.shadows = void 0
			},
			xGetter: function(a) {
				"circle" === this.element.nodeName &amp;&amp; ("x" === a ? a = "cx" : "y" === a &amp;&amp; (a = "cy"));
				return this._defaultGetter(a)
			},
			_defaultGetter: function(a) {
				a = D(this[a], this.element ? this.element.getAttribute(a) : null, 0);
				/^[\-0-9\.]+$/.test(a) &amp;&amp; (a = parseFloat(a));
				return a
			},
			dSetter: function(a, c, m) {
				a &amp;&amp; a.join &amp;&amp; (a = a.join(" "));
				/(NaN| {2}|^$)/.test(a) &amp;&amp; (a = "M 0 0");
				m.setAttribute(c, a);
				this[c] = a
			},
			dashstyleSetter: function(a) {
				var c, y = this["stroke-width"];
				"inherit" === y &amp;&amp; (y = 1);
				if (a = a &amp;&amp; a.toLowerCase()) {
					a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
					for (c = a.length; c--;) a[c] = G(a[c]) * y;
					a = a.join(",").replace(/NaN/g, "none");
					this.element.setAttribute("stroke-dasharray", a)
				}
			},
			alignSetter: function(a) {
				this.element.setAttribute("text-anchor", {
					left: "start",
					center: "middle",
					right: "end"
				}[a])
			},
			opacitySetter: function(a, c, m) {
				this[c] = a;
				m.setAttribute(c, a)
			},
			titleSetter: function(a) {
				var c = this.element.getElementsByTagName("title")[0];
				c || (c = n.createElementNS(this.SVG_NS, "title"), this.element.appendChild(c));
				c.firstChild &amp;&amp; c.removeChild(c.firstChild);
				c.appendChild(n.createTextNode(String(D(a), "").replace(/&lt;[^&gt;]*&gt;/g, "")))
			},
			textSetter: function(a) {
				a !== this.textStr &amp;&amp; (delete this.bBox, this.textStr = a, this.added &amp;&amp; this.renderer.buildText(this))
			},
			fillSetter: function(a, c, m) {
				"string" === typeof a ? m.setAttribute(c,
					a) : a &amp;&amp; this.colorGradient(a, c, m)
			},
			visibilitySetter: function(a, c, m) {
				"inherit" === a ? m.removeAttribute(c) : m.setAttribute(c, a)
			},
			zIndexSetter: function(a, c) {
				var m = this.renderer,
					y = this.parentGroup,
					b = (y || m).element || m.box,
					B, e = this.element,
					z;
				B = this.added;
				var q;
				r(a) &amp;&amp; (e.zIndex = a, a = +a, this[c] === a &amp;&amp; (B = !1), this[c] = a);
				if (B) {
					(a = this.zIndex) &amp;&amp; y &amp;&amp; (y.handleZ = !0);
					c = b.childNodes;
					for (q = 0; q &lt; c.length &amp;&amp; !z; q++) y = c[q], B = y.zIndex, y !== e &amp;&amp; (G(B) &gt; a || !r(a) &amp;&amp; r(B) || 0 &gt; a &amp;&amp; !r(B) &amp;&amp; b !== m.box) &amp;&amp; (b.insertBefore(e, y), z = !0);
					z || b.appendChild(e)
				}
				return z
			},
			_defaultSetter: function(a, c, m) {
				m.setAttribute(c, a)
			}
		};
		E.prototype.yGetter = E.prototype.xGetter;
		E.prototype.translateXSetter = E.prototype.translateYSetter = E.prototype.rotationSetter = E.prototype.verticalAlignSetter = E.prototype.scaleXSetter = E.prototype.scaleYSetter = function(a, c) {
			this[c] = a;
			this.doTransform = !0
		};
		E.prototype["stroke-widthSetter"] = E.prototype.strokeSetter = function(a, c, m) {
			this[c] = a;
			this.stroke &amp;&amp; this["stroke-width"] ? (E.prototype.fillSetter.call(this, this.stroke, "stroke", m), m.setAttribute("stroke-width",
				this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === c &amp;&amp; 0 === a &amp;&amp; this.hasStroke &amp;&amp; (m.removeAttribute("stroke"), this.hasStroke = !1)
		};
		A = a.SVGRenderer = function() {
			this.init.apply(this, arguments)
		};
		A.prototype = {
			Element: E,
			SVG_NS: z,
			init: function(a, c, m, b, e, z) {
				var y;
				b = this.createElement("svg").attr({
					version: "1.1",
					"class": "highcharts-root"
				}).css(this.getStyle(b));
				y = b.element;
				a.appendChild(y); - 1 === a.innerHTML.indexOf("xmlns") &amp;&amp; p(y, "xmlns", this.SVG_NS);
				this.isSVG = !0;
				this.box = y;
				this.boxWrapper = b;
				this.alignedObjects = [];
				this.url = (u || K) &amp;&amp; n.getElementsByTagName("base").length ? P.location.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
				this.createElement("desc").add().element.appendChild(n.createTextNode("Created with Highcharts 5.0.5"));
				this.defs = this.createElement("defs").add();
				this.allowHTML = z;
				this.forExport = e;
				this.gradients = {};
				this.cache = {};
				this.cacheKeys = [];
				this.imgCount = 0;
				this.setSize(c, m, !1);
				var B;
				u &amp;&amp; a.getBoundingClientRect &amp;&amp; (c = function() {
					v(a, {
						left: 0,
						top: 0
					});
					B = a.getBoundingClientRect();
					v(a, {
						left: Math.ceil(B.left) - B.left + "px",
						top: Math.ceil(B.top) - B.top + "px"
					})
				}, c(), this.unSubPixelFix = F(P, "resize", c))
			},
			getStyle: function(a) {
				return this.style = t({
					fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
					fontSize: "12px"
				}, a)
			},
			setStyle: function(a) {
				this.boxWrapper.css(this.getStyle(a))
			},
			isHidden: function() {
				return !this.boxWrapper.getBBox().width
			},
			destroy: function() {
				var a = this.defs;
				this.box = null;
				this.boxWrapper = this.boxWrapper.destroy();
				b(this.gradients || {});
				this.gradients =
					null;
				a &amp;&amp; (this.defs = a.destroy());
				this.unSubPixelFix &amp;&amp; this.unSubPixelFix();
				return this.alignedObjects = null
			},
			createElement: function(a) {
				var c = new this.Element;
				c.init(this, a);
				return c
			},
			draw: J,
			getRadialAttr: function(a, c) {
				return {
					cx: a[0] - a[2] / 2 + c.cx * a[2],
					cy: a[1] - a[2] / 2 + c.cy * a[2],
					r: c.r * a[2]
				}
			},
			buildText: function(a) {
				for (var c = a.element, b = this, y = b.forExport, q = D(a.textStr, "").toString(), k = -1 !== q.indexOf("\x3c"), h = c.childNodes, x, f, t, u, l = p(c, "x"), d = a.styles, C = a.textWidth, g = d &amp;&amp; d.lineHeight, r = d &amp;&amp; d.textOutline, K = d &amp;&amp;
						"ellipsis" === d.textOverflow, I = h.length, L = C &amp;&amp; !a.added &amp;&amp; this.box, P = function(a) {
							var m;
							m = /(px|em)$/.test(a &amp;&amp; a.style.fontSize) ? a.style.fontSize : d &amp;&amp; d.fontSize || b.style.fontSize || 12;
							return g ? G(g) : b.fontMetrics(m, a.getAttribute("style") ? a : c).h
						}; I--;) c.removeChild(h[I]);
				k || r || K || C || -1 !== q.indexOf(" ") ? (x = /&lt;.*class="([^"]+)".*&gt;/, f = /&lt;.*style="([^"]+)".*&gt;/, t = /&lt;.*href="(http[^"]+)".*&gt;/, L &amp;&amp; L.appendChild(c), q = k ? q.replace(/&lt;(b|strong)&gt;/g, '\x3cspan style\x3d"font-weight:bold"\x3e').replace(/&lt;(i|em)&gt;/g, '\x3cspan style\x3d"font-style:italic"\x3e').replace(/&lt;a/g,
					"\x3cspan").replace(/&lt;\/(b|strong|i|em|a)&gt;/g, "\x3c/span\x3e").split(/&lt;br.*?&gt;/g) : [q], q = e(q, function(a) {
					return "" !== a
				}), w(q, function(e, B) {
					var q, k = 0;
					e = e.replace(/^\s+|\s+$/g, "").replace(/&lt;span/g, "|||\x3cspan").replace(/&lt;\/span&gt;/g, "\x3c/span\x3e|||");
					q = e.split("|||");
					w(q, function(e) {
						if ("" !== e || 1 === q.length) {
							var h = {},
								D = n.createElementNS(b.SVG_NS, "tspan"),
								G, g;
							x.test(e) &amp;&amp; (G = e.match(x)[1], p(D, "class", G));
							f.test(e) &amp;&amp; (g = e.match(f)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), p(D, "style", g));
							t.test(e) &amp;&amp; !y &amp;&amp; (p(D,
								"onclick", 'location.href\x3d"' + e.match(t)[1] + '"'), v(D, {
								cursor: "pointer"
							}));
							e = (e.replace(/&lt;(.|\n)*?&gt;/g, "") || " ").replace(/&amp;lt;/g, "\x3c").replace(/&amp;gt;/g, "\x3e");
							if (" " !== e) {
								D.appendChild(n.createTextNode(e));
								k ? h.dx = 0 : B &amp;&amp; null !== l &amp;&amp; (h.x = l);
								p(D, h);
								c.appendChild(D);
								!k &amp;&amp; B &amp;&amp; (!m &amp;&amp; y &amp;&amp; v(D, {
									display: "block"
								}), p(D, "dy", P(D)));
								if (C) {
									h = e.replace(/([^\^])-/g, "$1- ").split(" ");
									G = "nowrap" === d.whiteSpace;
									for (var Q = 1 &lt; q.length || B || 1 &lt; h.length &amp;&amp; !G, r, I, w = [], L = P(D), S = a.rotation, O = e, R = O.length;
										(Q || K) &amp;&amp; (h.length || w.length);) a.rotation =
										0, r = a.getBBox(!0), I = r.width, !m &amp;&amp; b.forExport &amp;&amp; (I = b.measureSpanWidth(D.firstChild.data, a.styles)), r = I &gt; C, void 0 === u &amp;&amp; (u = r), K &amp;&amp; u ? (R /= 2, "" === O || !r &amp;&amp; .5 &gt; R ? h = [] : (O = e.substring(0, O.length + (r ? -1 : 1) * Math.ceil(R)), h = [O + (3 &lt; C ? "\u2026" : "")], D.removeChild(D.firstChild))) : r &amp;&amp; 1 !== h.length ? (D.removeChild(D.firstChild), w.unshift(h.pop())) : (h = w, w = [], h.length &amp;&amp; !G &amp;&amp; (D = n.createElementNS(z, "tspan"), p(D, {
											dy: L,
											x: l
										}), g &amp;&amp; p(D, "style", g), c.appendChild(D)), I &gt; C &amp;&amp; (C = I)), h.length &amp;&amp; D.appendChild(n.createTextNode(h.join(" ").replace(/- /g,
											"-")));
									a.rotation = S
								}
								k++
							}
						}
					})
				}), u &amp;&amp; a.attr("title", a.textStr), L &amp;&amp; L.removeChild(c), r &amp;&amp; a.applyTextOutline &amp;&amp; a.applyTextOutline(r)) : c.appendChild(n.createTextNode(q.replace(/&amp;lt;/g, "\x3c").replace(/&amp;gt;/g, "\x3e")))
			},
			getContrast: function(a) {
				a = g(a).rgba;
				return 510 &lt; a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF"
			},
			button: function(a, m, b, e, z, q, h, k, x) {
				var B = this.label(a, m, b, x, null, null, null, null, "button"),
					y = 0;
				B.attr(I({
					padding: 8,
					r: 2
				}, z));
				var f, n, u, D;
				z = I({
					fill: "#f7f7f7",
					stroke: "#cccccc",
					"stroke-width": 1,
					style: {
						color: "#333333",
						cursor: "pointer",
						fontWeight: "normal"
					}
				}, z);
				f = z.style;
				delete z.style;
				q = I(z, {
					fill: "#e6e6e6"
				}, q);
				n = q.style;
				delete q.style;
				h = I(z, {
					fill: "#e6ebf5",
					style: {
						color: "#000000",
						fontWeight: "bold"
					}
				}, h);
				u = h.style;
				delete h.style;
				k = I(z, {
					style: {
						color: "#cccccc"
					}
				}, k);
				D = k.style;
				delete k.style;
				F(B.element, c ? "mouseover" : "mouseenter", function() {
					3 !== y &amp;&amp; B.setState(1)
				});
				F(B.element, c ? "mouseout" : "mouseleave", function() {
					3 !== y &amp;&amp; B.setState(y)
				});
				B.setState = function(a) {
					1 !== a &amp;&amp; (B.state = y = a);
					B.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]);
					B.attr([z, q, h, k][a || 0]).css([f, n, u, D][a || 0])
				};
				B.attr(z).css(t({
					cursor: "default"
				}, f));
				return B.on("click", function(a) {
					3 !== y &amp;&amp; e.call(B, a)
				})
			},
			crispLine: function(a, c) {
				a[1] === a[4] &amp;&amp; (a[1] = a[4] = Math.round(a[1]) - c % 2 / 2);
				a[2] === a[5] &amp;&amp; (a[2] = a[5] = Math.round(a[2]) + c % 2 / 2);
				return a
			},
			path: function(a) {
				var c = {
					fill: "none"
				};
				C(a) ? c.d = a : q(a) &amp;&amp; t(c, a);
				return this.createElement("path").attr(c)
			},
			circle: function(a, c, m) {
				a = q(a) ? a : {
					x: a,
					y: c,
					r: m
				};
				c = this.createElement("circle");
				c.xSetter =
					c.ySetter = function(a, c, m) {
						m.setAttribute("c" + c, a)
					};
				return c.attr(a)
			},
			arc: function(a, c, m, b, e, z) {
				q(a) &amp;&amp; (c = a.y, m = a.r, b = a.innerR, e = a.start, z = a.end, a = a.x);
				a = this.symbol("arc", a || 0, c || 0, m || 0, m || 0, {
					innerR: b || 0,
					start: e || 0,
					end: z || 0
				});
				a.r = m;
				return a
			},
			rect: function(a, c, m, b, e, z) {
				e = q(a) ? a.r : e;
				var B = this.createElement("rect");
				a = q(a) ? a : void 0 === a ? {} : {
					x: a,
					y: c,
					width: Math.max(m, 0),
					height: Math.max(b, 0)
				};
				void 0 !== z &amp;&amp; (a.strokeWidth = z, a = B.crisp(a));
				a.fill = "none";
				e &amp;&amp; (a.r = e);
				B.rSetter = function(a, c, m) {
					p(m, {
						rx: a,
						ry: a
					})
				};
				return B.attr(a)
			},
			setSize: function(a, c, m) {
				var b = this.alignedObjects,
					e = b.length;
				this.width = a;
				this.height = c;
				for (this.boxWrapper.animate({
						width: a,
						height: c
					}, {
						step: function() {
							this.attr({
								viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
							})
						},
						duration: D(m, !0) ? void 0 : 0
					}); e--;) b[e].align()
			},
			g: function(a) {
				var c = this.createElement("g");
				return a ? c.attr({
					"class": "highcharts-" + a
				}) : c
			},
			image: function(a, c, m, b, e) {
				var z = {
					preserveAspectRatio: "none"
				};
				1 &lt; arguments.length &amp;&amp; t(z, {
					x: c,
					y: m,
					width: b,
					height: e
				});
				z = this.createElement("image").attr(z);
				z.element.setAttributeNS ? z.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : z.element.setAttribute("hc-svg-href", a);
				return z
			},
			symbol: function(a, c, m, b, e, z) {
				var q = this,
					B, y = this.symbols[a],
					h = r(c) &amp;&amp; y &amp;&amp; y(Math.round(c), Math.round(m), b, e, z),
					k = /^url\((.*?)\)$/,
					x, f;
				y ? (B = this.path(h), B.attr("fill", "none"), t(B, {
					symbolName: a,
					x: c,
					y: m,
					width: b,
					height: e
				}), z &amp;&amp; t(B, z)) : k.test(a) &amp;&amp; (x = a.match(k)[1], B = this.image(x), B.imgwidth = D(O[x] &amp;&amp; O[x].width, z &amp;&amp; z.width), B.imgheight = D(O[x] &amp;&amp; O[x].height, z &amp;&amp; z.height), f =
					function() {
						B.attr({
							width: B.width,
							height: B.height
						})
					}, w(["width", "height"], function(a) {
						B[a + "Setter"] = function(a, c) {
							var m = {},
								b = this["img" + c],
								e = "width" === c ? "translateX" : "translateY";
							this[c] = a;
							r(b) &amp;&amp; (this.element &amp;&amp; this.element.setAttribute(c, b), this.alignByTranslate || (m[e] = ((this[c] || 0) - b) / 2, this.attr(m)))
						}
					}), r(c) &amp;&amp; B.attr({
						x: c,
						y: m
					}), B.isImg = !0, r(B.imgwidth) &amp;&amp; r(B.imgheight) ? f() : (B.attr({
						width: 0,
						height: 0
					}), l("img", {
						onload: function() {
							var a = d[q.chartIndex];
							0 === this.width &amp;&amp; (v(this, {
									position: "absolute",
									top: "-999em"
								}),
								n.body.appendChild(this));
							O[x] = {
								width: this.width,
								height: this.height
							};
							B.imgwidth = this.width;
							B.imgheight = this.height;
							B.element &amp;&amp; f();
							this.parentNode &amp;&amp; this.parentNode.removeChild(this);
							q.imgCount--;
							if (!q.imgCount &amp;&amp; a &amp;&amp; a.onload) a.onload()
						},
						src: x
					}), this.imgCount++));
				return B
			},
			symbols: {
				circle: function(a, c, m, b) {
					var e = .166 * m;
					return ["M", a + m / 2, c, "C", a + m + e, c, a + m + e, c + b, a + m / 2, c + b, "C", a - e, c + b, a - e, c, a + m / 2, c, "Z"]
				},
				square: function(a, c, m, b) {
					return ["M", a, c, "L", a + m, c, a + m, c + b, a, c + b, "Z"]
				},
				triangle: function(a, c, m, b) {
					return ["M",
						a + m / 2, c, "L", a + m, c + b, a, c + b, "Z"
					]
				},
				"triangle-down": function(a, c, m, b) {
					return ["M", a, c, "L", a + m, c, a + m / 2, c + b, "Z"]
				},
				diamond: function(a, c, m, b) {
					return ["M", a + m / 2, c, "L", a + m, c + b / 2, a + m / 2, c + b, a, c + b / 2, "Z"]
				},
				arc: function(a, c, m, b, e) {
					var z = e.start;
					m = e.r || m || b;
					var q = e.end - .001;
					b = e.innerR;
					var B = e.open,
						h = Math.cos(z),
						k = Math.sin(z),
						y = Math.cos(q),
						q = Math.sin(q);
					e = e.end - z &lt; Math.PI ? 0 : 1;
					return ["M", a + m * h, c + m * k, "A", m, m, 0, e, 1, a + m * y, c + m * q, B ? "M" : "L", a + b * y, c + b * q, "A", b, b, 0, e, 0, a + b * h, c + b * k, B ? "" : "Z"]
				},
				callout: function(a, c, m, b, e) {
					var z =
						Math.min(e &amp;&amp; e.r || 0, m, b),
						q = z + 6,
						B = e &amp;&amp; e.anchorX;
					e = e &amp;&amp; e.anchorY;
					var h;
					h = ["M", a + z, c, "L", a + m - z, c, "C", a + m, c, a + m, c, a + m, c + z, "L", a + m, c + b - z, "C", a + m, c + b, a + m, c + b, a + m - z, c + b, "L", a + z, c + b, "C", a, c + b, a, c + b, a, c + b - z, "L", a, c + z, "C", a, c, a, c, a + z, c];
					B &amp;&amp; B &gt; m ? e &gt; c + q &amp;&amp; e &lt; c + b - q ? h.splice(13, 3, "L", a + m, e - 6, a + m + 6, e, a + m, e + 6, a + m, c + b - z) : h.splice(13, 3, "L", a + m, b / 2, B, e, a + m, b / 2, a + m, c + b - z) : B &amp;&amp; 0 &gt; B ? e &gt; c + q &amp;&amp; e &lt; c + b - q ? h.splice(33, 3, "L", a, e + 6, a - 6, e, a, e - 6, a, c + z) : h.splice(33, 3, "L", a, b / 2, B, e, a, b / 2, a, c + z) : e &amp;&amp; e &gt; b &amp;&amp; B &gt; a + q &amp;&amp; B &lt; a + m - q ? h.splice(23, 3, "L", B + 6, c +
						b, B, c + b + 6, B - 6, c + b, a + z, c + b) : e &amp;&amp; 0 &gt; e &amp;&amp; B &gt; a + q &amp;&amp; B &lt; a + m - q &amp;&amp; h.splice(3, 3, "L", B - 6, c, B, c - 6, B + 6, c, m - z, c);
					return h
				}
			},
			clipRect: function(c, m, b, e) {
				var z = a.uniqueKey(),
					q = this.createElement("clipPath").attr({
						id: z
					}).add(this.defs);
				c = this.rect(c, m, b, e, 0).add(q);
				c.id = z;
				c.clipPath = q;
				c.count = 0;
				return c
			},
			text: function(a, c, b, e) {
				var z = !m &amp;&amp; this.forExport,
					q = {};
				if (e &amp;&amp; (this.allowHTML || !this.forExport)) return this.html(a, c, b);
				q.x = Math.round(c || 0);
				b &amp;&amp; (q.y = Math.round(b));
				if (a || 0 === a) q.text = a;
				a = this.createElement("text").attr(q);
				z &amp;&amp; a.css({
					position: "absolute"
				});
				e || (a.xSetter = function(a, c, m) {
					var b = m.getElementsByTagName("tspan"),
						e, z = m.getAttribute(c),
						q;
					for (q = 0; q &lt; b.length; q++) e = b[q], e.getAttribute(c) === z &amp;&amp; e.setAttribute(c, a);
					m.setAttribute(c, a)
				});
				return a
			},
			fontMetrics: function(a, c) {
				a = a || c &amp;&amp; c.style &amp;&amp; c.style.fontSize || this.style &amp;&amp; this.style.fontSize;
				a = /px/.test(a) ? G(a) : /em/.test(a) ? parseFloat(a) * (c ? this.fontMetrics(null, c.parentNode).f : 16) : 12;
				c = 24 &gt; a ? a + 3 : Math.round(1.2 * a);
				return {
					h: c,
					b: Math.round(.8 * c),
					f: a
				}
			},
			rotCorr: function(a,
				c, m) {
				var b = a;
				c &amp;&amp; m &amp;&amp; (b = Math.max(b * Math.cos(c * f), 4));
				return {
					x: -a / 3 * Math.sin(c * f),
					y: b
				}
			},
			label: function(a, c, m, b, e, z, q, h, k) {
				var B = this,
					x = B.g("button" !== k &amp;&amp; "label"),
					f = x.text = B.text("", 0, 0, q).attr({
						zIndex: 1
					}),
					n, u, D = 0,
					y = 3,
					l = 0,
					G, d, C, g, K, P = {},
					O, v, N = /^url\((.*?)\)$/.test(b),
					Q = N,
					J, p, S, R;
				k &amp;&amp; x.addClass("highcharts-" + k);
				Q = N;
				J = function() {
					return (O || 0) % 2 / 2
				};
				p = function() {
					var a = f.element.style,
						c = {};
					u = (void 0 === G || void 0 === d || K) &amp;&amp; r(f.textStr) &amp;&amp; f.getBBox();
					x.width = (G || u.width || 0) + 2 * y + l;
					x.height = (d || u.height || 0) + 2 * y;
					v =
						y + B.fontMetrics(a &amp;&amp; a.fontSize, f).b;
					Q &amp;&amp; (n || (x.box = n = B.symbols[b] || N ? B.symbol(b) : B.rect(), n.addClass(("button" === k ? "" : "highcharts-label-box") + (k ? " highcharts-" + k + "-box" : "")), n.add(x), a = J(), c.x = a, c.y = (h ? -v : 0) + a), c.width = Math.round(x.width), c.height = Math.round(x.height), n.attr(t(c, P)), P = {})
				};
				S = function() {
					var a = l + y,
						c;
					c = h ? 0 : v;
					r(G) &amp;&amp; u &amp;&amp; ("center" === K || "right" === K) &amp;&amp; (a += {
						center: .5,
						right: 1
					}[K] * (G - u.width));
					if (a !== f.x || c !== f.y) f.attr("x", a), void 0 !== c &amp;&amp; f.attr("y", c);
					f.x = a;
					f.y = c
				};
				R = function(a, c) {
					n ? n.attr(a, c) :
						P[a] = c
				};
				x.onAdd = function() {
					f.add(x);
					x.attr({
						text: a || 0 === a ? a : "",
						x: c,
						y: m
					});
					n &amp;&amp; r(e) &amp;&amp; x.attr({
						anchorX: e,
						anchorY: z
					})
				};
				x.widthSetter = function(a) {
					G = a
				};
				x.heightSetter = function(a) {
					d = a
				};
				x["text-alignSetter"] = function(a) {
					K = a
				};
				x.paddingSetter = function(a) {
					r(a) &amp;&amp; a !== y &amp;&amp; (y = x.padding = a, S())
				};
				x.paddingLeftSetter = function(a) {
					r(a) &amp;&amp; a !== l &amp;&amp; (l = a, S())
				};
				x.alignSetter = function(a) {
					a = {
						left: 0,
						center: .5,
						right: 1
					}[a];
					a !== D &amp;&amp; (D = a, u &amp;&amp; x.attr({
						x: C
					}))
				};
				x.textSetter = function(a) {
					void 0 !== a &amp;&amp; f.textSetter(a);
					p();
					S()
				};
				x["stroke-widthSetter"] =
					function(a, c) {
						a &amp;&amp; (Q = !0);
						O = this["stroke-width"] = a;
						R(c, a)
					};
				x.strokeSetter = x.fillSetter = x.rSetter = function(a, c) {
					"fill" === c &amp;&amp; a &amp;&amp; (Q = !0);
					R(c, a)
				};
				x.anchorXSetter = function(a, c) {
					e = a;
					R(c, Math.round(a) - J() - C)
				};
				x.anchorYSetter = function(a, c) {
					z = a;
					R(c, a - g)
				};
				x.xSetter = function(a) {
					x.x = a;
					D &amp;&amp; (a -= D * ((G || u.width) + 2 * y));
					C = Math.round(a);
					x.attr("translateX", C)
				};
				x.ySetter = function(a) {
					g = x.y = Math.round(a);
					x.attr("translateY", g)
				};
				var V = x.css;
				return t(x, {
					css: function(a) {
						if (a) {
							var c = {};
							a = I(a);
							w(x.textProps, function(m) {
								void 0 !==
									a[m] &amp;&amp; (c[m] = a[m], delete a[m])
							});
							f.css(c)
						}
						return V.call(x, a)
					},
					getBBox: function() {
						return {
							width: u.width + 2 * y,
							height: u.height + 2 * y,
							x: u.x - y,
							y: u.y - y
						}
					},
					shadow: function(a) {
						a &amp;&amp; (p(), n &amp;&amp; n.shadow(a));
						return x
					},
					destroy: function() {
						L(x.element, "mouseenter");
						L(x.element, "mouseleave");
						f &amp;&amp; (f = f.destroy());
						n &amp;&amp; (n = n.destroy());
						E.prototype.destroy.call(x);
						x = B = p = S = R = null
					}
				})
			}
		};
		a.Renderer = A
	})(M);
	(function(a) {
		var E = a.attr,
			A = a.createElement,
			F = a.css,
			H = a.defined,
			p = a.each,
			d = a.extend,
			g = a.isFirefox,
			v = a.isMS,
			l = a.isWebKit,
			r = a.pInt,
			f =
			a.SVGRenderer,
			b = a.win,
			n = a.wrap;
		d(a.SVGElement.prototype, {
			htmlCss: function(a) {
				var b = this.element;
				if (b = a &amp;&amp; "SPAN" === b.tagName &amp;&amp; a.width) delete a.width, this.textWidth = b, this.updateTransform();
				a &amp;&amp; "ellipsis" === a.textOverflow &amp;&amp; (a.whiteSpace = "nowrap", a.overflow = "hidden");
				this.styles = d(this.styles, a);
				F(this.element, a);
				return this
			},
			htmlGetBBox: function() {
				var a = this.element;
				"text" === a.nodeName &amp;&amp; (a.style.position = "absolute");
				return {
					x: a.offsetLeft,
					y: a.offsetTop,
					width: a.offsetWidth,
					height: a.offsetHeight
				}
			},
			htmlUpdateTransform: function() {
				if (this.added) {
					var a =
						this.renderer,
						b = this.element,
						k = this.translateX || 0,
						e = this.translateY || 0,
						h = this.x || 0,
						f = this.y || 0,
						n = this.textAlign || "left",
						c = {
							left: 0,
							center: .5,
							right: 1
						}[n],
						q = this.styles;
					F(b, {
						marginLeft: k,
						marginTop: e
					});
					this.shadows &amp;&amp; p(this.shadows, function(a) {
						F(a, {
							marginLeft: k + 1,
							marginTop: e + 1
						})
					});
					this.inverted &amp;&amp; p(b.childNodes, function(c) {
						a.invertChild(c, b)
					});
					if ("SPAN" === b.tagName) {
						var x = this.rotation,
							d = r(this.textWidth),
							g = q &amp;&amp; q.whiteSpace,
							v = [x, n, b.innerHTML, this.textWidth, this.textAlign].join();
						v !== this.cTT &amp;&amp; (q = a.fontMetrics(b.style.fontSize).b,
							H(x) &amp;&amp; this.setSpanRotation(x, c, q), F(b, {
								width: "",
								whiteSpace: g || "nowrap"
							}), b.offsetWidth &gt; d &amp;&amp; /[ \-]/.test(b.textContent || b.innerText) &amp;&amp; F(b, {
								width: d + "px",
								display: "block",
								whiteSpace: g || "normal"
							}), this.getSpanCorrection(b.offsetWidth, q, c, x, n));
						F(b, {
							left: h + (this.xCorr || 0) + "px",
							top: f + (this.yCorr || 0) + "px"
						});
						l &amp;&amp; (q = b.offsetHeight);
						this.cTT = v
					}
				} else this.alignOnAdd = !0
			},
			setSpanRotation: function(a, f, k) {
				var e = {},
					h = v ? "-ms-transform" : l ? "-webkit-transform" : g ? "MozTransform" : b.opera ? "-o-transform" : "";
				e[h] = e.transform =
					"rotate(" + a + "deg)";
				e[h + (g ? "Origin" : "-origin")] = e.transformOrigin = 100 * f + "% " + k + "px";
				F(this.element, e)
			},
			getSpanCorrection: function(a, b, k) {
				this.xCorr = -a * k;
				this.yCorr = -b
			}
		});
		d(f.prototype, {
			html: function(a, b, k) {
				var e = this.createElement("span"),
					h = e.element,
					f = e.renderer,
					u = f.isSVG,
					c = function(a, c) {
						p(["opacity", "visibility"], function(b) {
							n(a, b + "Setter", function(a, b, e, q) {
								a.call(this, b, e, q);
								c[e] = b
							})
						})
					};
				e.textSetter = function(a) {
					a !== h.innerHTML &amp;&amp; delete this.bBox;
					h.innerHTML = this.textStr = a;
					e.htmlUpdateTransform()
				};
				u &amp;&amp; c(e, e.element.style);
				e.xSetter = e.ySetter = e.alignSetter = e.rotationSetter = function(a, c) {
					"align" === c &amp;&amp; (c = "textAlign");
					e[c] = a;
					e.htmlUpdateTransform()
				};
				e.attr({
					text: a,
					x: Math.round(b),
					y: Math.round(k)
				}).css({
					fontFamily: this.style.fontFamily,
					fontSize: this.style.fontSize,
					position: "absolute"
				});
				h.style.whiteSpace = "nowrap";
				e.css = e.htmlCss;
				u &amp;&amp; (e.add = function(a) {
					var b, q = f.box.parentNode,
						k = [];
					if (this.parentGroup = a) {
						if (b = a.div, !b) {
							for (; a;) k.push(a), a = a.parentGroup;
							p(k.reverse(), function(a) {
								var h, x = E(a.element,
									"class");
								x &amp;&amp; (x = {
									className: x
								});
								b = a.div = a.div || A("div", x, {
									position: "absolute",
									left: (a.translateX || 0) + "px",
									top: (a.translateY || 0) + "px",
									display: a.display,
									opacity: a.opacity,
									pointerEvents: a.styles &amp;&amp; a.styles.pointerEvents
								}, b || q);
								h = b.style;
								d(a, {
									on: function() {
										e.on.apply({
											element: k[0].div
										}, arguments);
										return a
									},
									translateXSetter: function(c, b) {
										h.left = c + "px";
										a[b] = c;
										a.doTransform = !0
									},
									translateYSetter: function(c, b) {
										h.top = c + "px";
										a[b] = c;
										a.doTransform = !0
									}
								});
								c(a, h)
							})
						}
					} else b = q;
					b.appendChild(h);
					e.added = !0;
					e.alignOnAdd &amp;&amp;
						e.htmlUpdateTransform();
					return e
				});
				return e
			}
		})
	})(M);
	(function(a) {
		var E, A, F = a.createElement,
			H = a.css,
			p = a.defined,
			d = a.deg2rad,
			g = a.discardElement,
			v = a.doc,
			l = a.each,
			r = a.erase,
			f = a.extend;
		E = a.extendClass;
		var b = a.isArray,
			n = a.isNumber,
			w = a.isObject,
			t = a.merge;
		A = a.noop;
		var k = a.pick,
			e = a.pInt,
			h = a.SVGElement,
			C = a.SVGRenderer,
			u = a.win;
		a.svg || (A = {
			docMode8: v &amp;&amp; 8 === v.documentMode,
			init: function(a, b) {
				var c = ["\x3c", b, ' filled\x3d"f" stroked\x3d"f"'],
					e = ["position: ", "absolute", ";"],
					q = "div" === b;
				("shape" === b || q) &amp;&amp; e.push("left:0;top:0;width:1px;height:1px;");
				e.push("visibility: ", q ? "hidden" : "visible");
				c.push(' style\x3d"', e.join(""), '"/\x3e');
				b &amp;&amp; (c = q || "span" === b || "img" === b ? c.join("") : a.prepVML(c), this.element = F(c));
				this.renderer = a
			},
			add: function(a) {
				var c = this.renderer,
					b = this.element,
					e = c.box,
					h = a &amp;&amp; a.inverted,
					e = a ? a.element || a : e;
				a &amp;&amp; (this.parentGroup = a);
				h &amp;&amp; c.invertChild(b, e);
				e.appendChild(b);
				this.added = !0;
				this.alignOnAdd &amp;&amp; !this.deferUpdateTransform &amp;&amp; this.updateTransform();
				if (this.onAdd) this.onAdd();
				this.className &amp;&amp; this.attr("class", this.className);
				return this
			},
			updateTransform: h.prototype.htmlUpdateTransform,
			setSpanRotation: function() {
				var a = this.rotation,
					b = Math.cos(a * d),
					e = Math.sin(a * d);
				H(this.element, {
					filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11\x3d", b, ", M12\x3d", -e, ", M21\x3d", e, ", M22\x3d", b, ", sizingMethod\x3d'auto expand')"].join("") : "none"
				})
			},
			getSpanCorrection: function(a, b, e, h, f) {
				var c = h ? Math.cos(h * d) : 1,
					q = h ? Math.sin(h * d) : 0,
					x = k(this.elemHeight, this.element.offsetHeight),
					n;
				this.xCorr = 0 &gt; c &amp;&amp; -a;
				this.yCorr = 0 &gt; q &amp;&amp; -x;
				n = 0 &gt; c * q;
				this.xCorr += q * b * (n ? 1 -
					e : e);
				this.yCorr -= c * b * (h ? n ? e : 1 - e : 1);
				f &amp;&amp; "left" !== f &amp;&amp; (this.xCorr -= a * e * (0 &gt; c ? -1 : 1), h &amp;&amp; (this.yCorr -= x * e * (0 &gt; q ? -1 : 1)), H(this.element, {
					textAlign: f
				}))
			},
			pathToVML: function(a) {
				for (var c = a.length, b = []; c--;) n(a[c]) ? b[c] = Math.round(10 * a[c]) - 5 : "Z" === a[c] ? b[c] = "x" : (b[c] = a[c], !a.isArc || "wa" !== a[c] &amp;&amp; "at" !== a[c] || (b[c + 5] === b[c + 7] &amp;&amp; (b[c + 7] += a[c + 7] &gt; a[c + 5] ? 1 : -1), b[c + 6] === b[c + 8] &amp;&amp; (b[c + 8] += a[c + 8] &gt; a[c + 6] ? 1 : -1)));
				return b.join(" ") || "x"
			},
			clip: function(a) {
				var c = this,
					b;
				a ? (b = a.members, r(b, c), b.push(c), c.destroyClip = function() {
					r(b,
						c)
				}, a = a.getCSS(c)) : (c.destroyClip &amp;&amp; c.destroyClip(), a = {
					clip: c.docMode8 ? "inherit" : "rect(auto)"
				});
				return c.css(a)
			},
			css: h.prototype.htmlCss,
			safeRemoveChild: function(a) {
				a.parentNode &amp;&amp; g(a)
			},
			destroy: function() {
				this.destroyClip &amp;&amp; this.destroyClip();
				return h.prototype.destroy.apply(this)
			},
			on: function(a, b) {
				this.element["on" + a] = function() {
					var a = u.event;
					a.target = a.srcElement;
					b(a)
				};
				return this
			},
			cutOffPath: function(a, b) {
				var c;
				a = a.split(/[ ,]/);
				c = a.length;
				if (9 === c || 11 === c) a[c - 4] = a[c - 2] = e(a[c - 2]) - 10 * b;
				return a.join(" ")
			},
			shadow: function(a, b, h) {
				var c = [],
					q, f = this.element,
					n = this.renderer,
					x, u = f.style,
					d, m = f.path,
					z, l, t, y;
				m &amp;&amp; "string" !== typeof m.value &amp;&amp; (m = "x");
				l = m;
				if (a) {
					t = k(a.width, 3);
					y = (a.opacity || .15) / t;
					for (q = 1; 3 &gt;= q; q++) z = 2 * t + 1 - 2 * q, h &amp;&amp; (l = this.cutOffPath(m.value, z + .5)), d = ['\x3cshape isShadow\x3d"true" strokeweight\x3d"', z, '" filled\x3d"false" path\x3d"', l, '" coordsize\x3d"10 10" style\x3d"', f.style.cssText, '" /\x3e'], x = F(n.prepVML(d), null, {
						left: e(u.left) + k(a.offsetX, 1),
						top: e(u.top) + k(a.offsetY, 1)
					}), h &amp;&amp; (x.cutOff = z + 1), d = ['\x3cstroke color\x3d"',
						a.color || "#000000", '" opacity\x3d"', y * q, '"/\x3e'
					], F(n.prepVML(d), null, null, x), b ? b.element.appendChild(x) : f.parentNode.insertBefore(x, f), c.push(x);
					this.shadows = c
				}
				return this
			},
			updateShadows: A,
			setAttr: function(a, b) {
				this.docMode8 ? this.element[a] = b : this.element.setAttribute(a, b)
			},
			classSetter: function(a) {
				(this.added ? this.element : this).className = a
			},
			dashstyleSetter: function(a, b, e) {
				(e.getElementsByTagName("stroke")[0] || F(this.renderer.prepVML(["\x3cstroke/\x3e"]), null, null, e))[b] = a || "solid";
				this[b] = a
			},
			dSetter: function(a,
				b, e) {
				var c = this.shadows;
				a = a || [];
				this.d = a.join &amp;&amp; a.join(" ");
				e.path = a = this.pathToVML(a);
				if (c)
					for (e = c.length; e--;) c[e].path = c[e].cutOff ? this.cutOffPath(a, c[e].cutOff) : a;
				this.setAttr(b, a)
			},
			fillSetter: function(a, b, e) {
				var c = e.nodeName;
				"SPAN" === c ? e.style.color = a : "IMG" !== c &amp;&amp; (e.filled = "none" !== a, this.setAttr("fillcolor", this.renderer.color(a, e, b, this)))
			},
			"fill-opacitySetter": function(a, b, e) {
				F(this.renderer.prepVML(["\x3c", b.split("-")[0], ' opacity\x3d"', a, '"/\x3e']), null, null, e)
			},
			opacitySetter: A,
			rotationSetter: function(a,
				b, e) {
				e = e.style;
				this[b] = e[b] = a;
				e.left = -Math.round(Math.sin(a * d) + 1) + "px";
				e.top = Math.round(Math.cos(a * d)) + "px"
			},
			strokeSetter: function(a, b, e) {
				this.setAttr("strokecolor", this.renderer.color(a, e, b, this))
			},
			"stroke-widthSetter": function(a, b, e) {
				e.stroked = !!a;
				this[b] = a;
				n(a) &amp;&amp; (a += "px");
				this.setAttr("strokeweight", a)
			},
			titleSetter: function(a, b) {
				this.setAttr(b, a)
			},
			visibilitySetter: function(a, b, e) {
				"inherit" === a &amp;&amp; (a = "visible");
				this.shadows &amp;&amp; l(this.shadows, function(c) {
					c.style[b] = a
				});
				"DIV" === e.nodeName &amp;&amp; (a = "hidden" ===
					a ? "-999em" : 0, this.docMode8 || (e.style[b] = a ? "visible" : "hidden"), b = "top");
				e.style[b] = a
			},
			xSetter: function(a, b, e) {
				this[b] = a;
				"x" === b ? b = "left" : "y" === b &amp;&amp; (b = "top");
				this.updateClipping ? (this[b] = a, this.updateClipping()) : e.style[b] = a
			},
			zIndexSetter: function(a, b, e) {
				e.style[b] = a
			}
		}, A["stroke-opacitySetter"] = A["fill-opacitySetter"], a.VMLElement = A = E(h, A), A.prototype.ySetter = A.prototype.widthSetter = A.prototype.heightSetter = A.prototype.xSetter, A = {
			Element: A,
			isIE8: -1 &lt; u.navigator.userAgent.indexOf("MSIE 8.0"),
			init: function(a,
				b, e) {
				var c, h;
				this.alignedObjects = [];
				c = this.createElement("div").css({
					position: "relative"
				});
				h = c.element;
				a.appendChild(c.element);
				this.isVML = !0;
				this.box = h;
				this.boxWrapper = c;
				this.gradients = {};
				this.cache = {};
				this.cacheKeys = [];
				this.imgCount = 0;
				this.setSize(b, e, !1);
				if (!v.namespaces.hcv) {
					v.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");
					try {
						v.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "
					} catch (J) {
						v.styleSheets[0].cssText +=
							"hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } "
					}
				}
			},
			isHidden: function() {
				return !this.box.offsetWidth
			},
			clipRect: function(a, b, e, h) {
				var c = this.createElement(),
					q = w(a);
				return f(c, {
					members: [],
					count: 0,
					left: (q ? a.x : a) + 1,
					top: (q ? a.y : b) + 1,
					width: (q ? a.width : e) - 1,
					height: (q ? a.height : h) - 1,
					getCSS: function(a) {
						var c = a.element,
							b = c.nodeName,
							e = a.inverted,
							m = this.top - ("shape" === b ? c.offsetTop : 0),
							z = this.left,
							c = z + this.width,
							h = m + this.height,
							m = {
								clip: "rect(" + Math.round(e ?
									z : m) + "px," + Math.round(e ? h : c) + "px," + Math.round(e ? c : h) + "px," + Math.round(e ? m : z) + "px)"
							};
						!e &amp;&amp; a.docMode8 &amp;&amp; "DIV" === b &amp;&amp; f(m, {
							width: c + "px",
							height: h + "px"
						});
						return m
					},
					updateClipping: function() {
						l(c.members, function(a) {
							a.element &amp;&amp; a.css(c.getCSS(a))
						})
					}
				})
			},
			color: function(c, b, e, h) {
				var q = this,
					k, f = /^rgba/,
					n, u, x = "none";
				c &amp;&amp; c.linearGradient ? u = "gradient" : c &amp;&amp; c.radialGradient &amp;&amp; (u = "pattern");
				if (u) {
					var m, z, d = c.linearGradient || c.radialGradient,
						t, y, B, C, g, r = "";
					c = c.stops;
					var w, v = [],
						K = function() {
							n = ['\x3cfill colors\x3d"' + v.join(",") +
								'" opacity\x3d"', B, '" o:opacity2\x3d"', y, '" type\x3d"', u, '" ', r, 'focus\x3d"100%" method\x3d"any" /\x3e'
							];
							F(q.prepVML(n), null, null, b)
						};
					t = c[0];
					w = c[c.length - 1];
					0 &lt; t[0] &amp;&amp; c.unshift([0, t[1]]);
					1 &gt; w[0] &amp;&amp; c.push([1, w[1]]);
					l(c, function(c, b) {
						f.test(c[1]) ? (k = a.color(c[1]), m = k.get("rgb"), z = k.get("a")) : (m = c[1], z = 1);
						v.push(100 * c[0] + "% " + m);
						b ? (B = z, C = m) : (y = z, g = m)
					});
					if ("fill" === e)
						if ("gradient" === u) e = d.x1 || d[0] || 0, c = d.y1 || d[1] || 0, t = d.x2 || d[2] || 0, d = d.y2 || d[3] || 0, r = 'angle\x3d"' + (90 - 180 * Math.atan((d - c) / (t - e)) / Math.PI) + '"',
							K();
						else {
							var x = d.r,
								p = 2 * x,
								A = 2 * x,
								E = d.cx,
								H = d.cy,
								U = b.radialReference,
								T, x = function() {
									U &amp;&amp; (T = h.getBBox(), E += (U[0] - T.x) / T.width - .5, H += (U[1] - T.y) / T.height - .5, p *= U[2] / T.width, A *= U[2] / T.height);
									r = 'src\x3d"' + a.getOptions().global.VMLRadialGradientURL + '" size\x3d"' + p + "," + A + '" origin\x3d"0.5,0.5" position\x3d"' + E + "," + H + '" color2\x3d"' + g + '" ';
									K()
								};
							h.added ? x() : h.onAdd = x;
							x = C
						}
					else x = m
				} else f.test(c) &amp;&amp; "IMG" !== b.tagName ? (k = a.color(c), h[e + "-opacitySetter"](k.get("a"), e, b), x = k.get("rgb")) : (x = b.getElementsByTagName(e),
					x.length &amp;&amp; (x[0].opacity = 1, x[0].type = "solid"), x = c);
				return x
			},
			prepVML: function(a) {
				var c = this.isIE8;
				a = a.join("");
				c ? (a = a.replace("/\x3e", ' xmlns\x3d"urn:schemas-microsoft-com:vml" /\x3e'), a = -1 === a.indexOf('style\x3d"') ? a.replace("/\x3e", ' style\x3d"display:inline-block;behavior:url(#default#VML);" /\x3e') : a.replace('style\x3d"', 'style\x3d"display:inline-block;behavior:url(#default#VML);')) : a = a.replace("\x3c", "\x3chcv:");
				return a
			},
			text: C.prototype.html,
			path: function(a) {
				var c = {
					coordsize: "10 10"
				};
				b(a) ? c.d =
					a : w(a) &amp;&amp; f(c, a);
				return this.createElement("shape").attr(c)
			},
			circle: function(a, b, e) {
				var c = this.symbol("circle");
				w(a) &amp;&amp; (e = a.r, b = a.y, a = a.x);
				c.isCircle = !0;
				c.r = e;
				return c.attr({
					x: a,
					y: b
				})
			},
			g: function(a) {
				var b;
				a &amp;&amp; (b = {
					className: "highcharts-" + a,
					"class": "highcharts-" + a
				});
				return this.createElement("div").attr(b)
			},
			image: function(a, b, e, h, k) {
				var c = this.createElement("img").attr({
					src: a
				});
				1 &lt; arguments.length &amp;&amp; c.attr({
					x: b,
					y: e,
					width: h,
					height: k
				});
				return c
			},
			createElement: function(a) {
				return "rect" === a ? this.symbol(a) : C.prototype.createElement.call(this,
					a)
			},
			invertChild: function(a, b) {
				var c = this;
				b = b.style;
				var h = "IMG" === a.tagName &amp;&amp; a.style;
				H(a, {
					flip: "x",
					left: e(b.width) - (h ? e(h.top) : 1),
					top: e(b.height) - (h ? e(h.left) : 1),
					rotation: -90
				});
				l(a.childNodes, function(b) {
					c.invertChild(b, a)
				})
			},
			symbols: {
				arc: function(a, b, e, h, k) {
					var c = k.start,
						f = k.end,
						q = k.r || e || h;
					e = k.innerR;
					h = Math.cos(c);
					var n = Math.sin(c),
						u = Math.cos(f),
						m = Math.sin(f);
					if (0 === f - c) return ["x"];
					c = ["wa", a - q, b - q, a + q, b + q, a + q * h, b + q * n, a + q * u, b + q * m];
					k.open &amp;&amp; !e &amp;&amp; c.push("e", "M", a, b);
					c.push("at", a - e, b - e, a + e, b + e, a + e * u,
						b + e * m, a + e * h, b + e * n, "x", "e");
					c.isArc = !0;
					return c
				},
				circle: function(a, b, e, h, k) {
					k &amp;&amp; p(k.r) &amp;&amp; (e = h = 2 * k.r);
					k &amp;&amp; k.isCircle &amp;&amp; (a -= e / 2, b -= h / 2);
					return ["wa", a, b, a + e, b + h, a + e, b + h / 2, a + e, b + h / 2, "e"]
				},
				rect: function(a, b, e, h, k) {
					return C.prototype.symbols[p(k) &amp;&amp; k.r ? "callout" : "square"].call(0, a, b, e, h, k)
				}
			}
		}, a.VMLRenderer = E = function() {
			this.init.apply(this, arguments)
		}, E.prototype = t(C.prototype, A), a.Renderer = E);
		C.prototype.measureSpanWidth = function(a, b) {
			var c = v.createElement("span");
			a = v.createTextNode(a);
			c.appendChild(a);
			H(c,
				b);
			this.box.appendChild(c);
			b = c.offsetWidth;
			g(c);
			return b
		}
	})(M);
	(function(a) {
		function E() {
			var v = a.defaultOptions.global,
				l, r = v.useUTC,
				f = r ? "getUTC" : "get",
				b = r ? "setUTC" : "set";
			a.Date = l = v.Date || g.Date;
			l.hcTimezoneOffset = r &amp;&amp; v.timezoneOffset;
			l.hcGetTimezoneOffset = r &amp;&amp; v.getTimezoneOffset;
			l.hcMakeTime = function(a, b, f, k, e, h) {
				var n;
				r ? (n = l.UTC.apply(0, arguments), n += H(n)) : n = (new l(a, b, d(f, 1), d(k, 0), d(e, 0), d(h, 0))).getTime();
				return n
			};
			F("Minutes Hours Day Date Month FullYear".split(" "), function(a) {
				l["hcGet" + a] = f +
					a
			});
			F("Milliseconds Seconds Minutes Hours Date Month FullYear".split(" "), function(a) {
				l["hcSet" + a] = b + a
			})
		}
		var A = a.color,
			F = a.each,
			H = a.getTZOffset,
			p = a.merge,
			d = a.pick,
			g = a.win;
		a.defaultOptions = {
			colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
			symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
			lang: {
				loading: "Loading...",
				months: "January February March April May June July August September October November December".split(" "),
				shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
				weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
				decimalPoint: ".",
				numericSymbols: "kMGTPE".split(""),
				resetZoom: "Reset zoom",
				resetZoomTitle: "Reset zoom level 1:1",
				thousandsSep: " "
			},
			global: {
				useUTC: !0,
				VMLRadialGradientURL: "http://code.highcharts.com/5.0.5/gfx/vml-radial-gradient.png"
			},
			chart: {
				borderRadius: 0,
				defaultSeriesType: "line",
				ignoreHiddenSeries: !0,
				spacing: [10, 10, 15, 10],
				resetZoomButton: {
					theme: {
						zIndex: 20
					},
					position: {
						align: "right",
						x: -10,
						y: 10
					}
				},
				width: null,
				height: null,
				borderColor: "#335cad",
				backgroundColor: "#ffffff",
				plotBorderColor: "#cccccc"
			},
			title: {
				text: "Chart title",
				align: "center",
				margin: 15,
				widthAdjust: -44
			},
			subtitle: {
				text: "",
				align: "center",
				widthAdjust: -44
			},
			plotOptions: {},
			labels: {
				style: {
					position: "absolute",
					color: "#333333"
				}
			},
			legend: {
				enabled: !0,
				align: "center",
				layout: "horizontal",
				labelFormatter: function() {
					return this.name
				},
				borderColor: "#999999",
				borderRadius: 0,
				navigation: {
					activeColor: "#003399",
					inactiveColor: "#cccccc"
				},
				itemStyle: {
					color: "#333333",
					fontSize: "12px",
					fontWeight: "bold"
				},
				itemHoverStyle: {
					color: "#000000"
				},
				itemHiddenStyle: {
					color: "#cccccc"
				},
				shadow: !1,
				itemCheckboxStyle: {
					position: "absolute",
					width: "13px",
					height: "13px"
				},
				squareSymbol: !0,
				symbolPadding: 5,
				verticalAlign: "bottom",
				x: 0,
				y: 0,
				title: {
					style: {
						fontWeight: "bold"
					}
				}
			},
			loading: {
				labelStyle: {
					fontWeight: "bold",
					position: "relative",
					top: "45%"
				},
				style: {
					position: "absolute",
					backgroundColor: "#ffffff",
					opacity: .5,
					textAlign: "center"
				}
			},
			tooltip: {
				enabled: !0,
				animation: a.svg,
				borderRadius: 3,
				dateTimeLabelFormats: {
					millisecond: "%A, %b %e, %H:%M:%S.%L",
					second: "%A, %b %e, %H:%M:%S",
					minute: "%A, %b %e, %H:%M",
					hour: "%A, %b %e, %H:%M",
					day: "%A, %b %e, %Y",
					week: "Week from %A, %b %e, %Y",
					month: "%B %Y",
					year: "%Y"
				},
				footerFormat: "",
				padding: 8,
				snap: a.isTouchDevice ? 25 : 10,
				backgroundColor: A("#f7f7f7").setOpacity(.85).get(),
				borderWidth: 1,
				headerFormat: '\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',
				pointFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e',
				shadow: !0,
				style: {
					color: "#333333",
					cursor: "default",
					fontSize: "12px",
					pointerEvents: "none",
					whiteSpace: "nowrap"
				}
			},
			credits: {
				enabled: !0,
				href: "http://www.highcharts.com",
				position: {
					align: "right",
					x: -10,
					verticalAlign: "bottom",
					y: -5
				},
				style: {
					cursor: "pointer",
					color: "#999999",
					fontSize: "9px"
				},
				text: "Highcharts.com"
			}
		};
		a.setOptions = function(d) {
			a.defaultOptions = p(!0, a.defaultOptions, d);
			E();
			return a.defaultOptions
		};
		a.getOptions = function() {
			return a.defaultOptions
		};
		a.defaultPlotOptions = a.defaultOptions.plotOptions;
		E()
	})(M);
	(function(a) {
		var E = a.arrayMax,
			A = a.arrayMin,
			F = a.defined,
			H = a.destroyObjectProperties,
			p = a.each,
			d = a.erase,
			g = a.merge,
			v = a.pick;
		a.PlotLineOrBand = function(a, d) {
			this.axis = a;
			d &amp;&amp; (this.options = d, this.id = d.id)
		};
		a.PlotLineOrBand.prototype = {
			render: function() {
				var a = this,
					d = a.axis,
					f = d.horiz,
					b = a.options,
					n = b.label,
					w = a.label,
					t = b.to,
					k = b.from,
					e = b.value,
					h = F(k) &amp;&amp; F(t),
					C = F(e),
					u = a.svgElem,
					c = !u,
					q = [],
					x, K = b.color,
					I = v(b.zIndex, 0),
					p = b.events,
					q = {
						"class": "highcharts-plot-" + (h ? "band " : "line ") + (b.className || "")
					},
					D = {},
					G = d.chart.renderer,
					L = h ? "bands" : "lines",
					N = d.log2lin;
				d.isLog &amp;&amp; (k = N(k), t =
					N(t), e = N(e));
				C ? (q = {
					stroke: K,
					"stroke-width": b.width
				}, b.dashStyle &amp;&amp; (q.dashstyle = b.dashStyle)) : h &amp;&amp; (K &amp;&amp; (q.fill = K), b.borderWidth &amp;&amp; (q.stroke = b.borderColor, q["stroke-width"] = b.borderWidth));
				D.zIndex = I;
				L += "-" + I;
				(K = d[L]) || (d[L] = K = G.g("plot-" + L).attr(D).add());
				c &amp;&amp; (a.svgElem = u = G.path().attr(q).add(K));
				if (C) q = d.getPlotLinePath(e, u.strokeWidth());
				else if (h) q = d.getPlotBandPath(k, t, b);
				else return;
				if (c &amp;&amp; q &amp;&amp; q.length) {
					if (u.attr({
							d: q
						}), p)
						for (x in b = function(b) {
								u.on(b, function(c) {
									p[b].apply(a, [c])
								})
							}, p) b(x)
				} else u &amp;&amp;
					(q ? (u.show(), u.animate({
						d: q
					})) : (u.hide(), w &amp;&amp; (a.label = w = w.destroy())));
				n &amp;&amp; F(n.text) &amp;&amp; q &amp;&amp; q.length &amp;&amp; 0 &lt; d.width &amp;&amp; 0 &lt; d.height &amp;&amp; !q.flat ? (n = g({
					align: f &amp;&amp; h &amp;&amp; "center",
					x: f ? !h &amp;&amp; 4 : 10,
					verticalAlign: !f &amp;&amp; h &amp;&amp; "middle",
					y: f ? h ? 16 : 10 : h ? 6 : -4,
					rotation: f &amp;&amp; !h &amp;&amp; 90
				}, n), this.renderLabel(n, q, h, I)) : w &amp;&amp; w.hide();
				return a
			},
			renderLabel: function(a, d, f, b) {
				var n = this.label,
					l = this.axis.chart.renderer;
				n || (n = {
						align: a.textAlign || a.align,
						rotation: a.rotation,
						"class": "highcharts-plot-" + (f ? "band" : "line") + "-label " + (a.className || "")
					}, n.zIndex = b,
					this.label = n = l.text(a.text, 0, 0, a.useHTML).attr(n).add(), n.css(a.style));
				b = [d[1], d[4], f ? d[6] : d[1]];
				d = [d[2], d[5], f ? d[7] : d[2]];
				f = A(b);
				l = A(d);
				n.align(a, !1, {
					x: f,
					y: l,
					width: E(b) - f,
					height: E(d) - l
				});
				n.show()
			},
			destroy: function() {
				d(this.axis.plotLinesAndBands, this);
				delete this.axis;
				H(this)
			}
		};
		a.AxisPlotLineOrBandExtension = {
			getPlotBandPath: function(a, d) {
				d = this.getPlotLinePath(d, null, null, !0);
				(a = this.getPlotLinePath(a, null, null, !0)) &amp;&amp; d ? (a.flat = a.toString() === d.toString(), a.push(d[4], d[5], d[1], d[2], "z")) : a = null;
				return a
			},
			addPlotBand: function(a) {
				return this.addPlotBandOrLine(a, "plotBands")
			},
			addPlotLine: function(a) {
				return this.addPlotBandOrLine(a, "plotLines")
			},
			addPlotBandOrLine: function(d, g) {
				var f = (new a.PlotLineOrBand(this, d)).render(),
					b = this.userOptions;
				f &amp;&amp; (g &amp;&amp; (b[g] = b[g] || [], b[g].push(d)), this.plotLinesAndBands.push(f));
				return f
			},
			removePlotBandOrLine: function(a) {
				for (var g = this.plotLinesAndBands, f = this.options, b = this.userOptions, n = g.length; n--;) g[n].id === a &amp;&amp; g[n].destroy();
				p([f.plotLines || [], b.plotLines || [], f.plotBands || [], b.plotBands || []], function(b) {
					for (n = b.length; n--;) b[n].id === a &amp;&amp; d(b, b[n])
				})
			}
		}
	})(M);
	(function(a) {
		var E = a.correctFloat,
			A = a.defined,
			F = a.destroyObjectProperties,
			H = a.isNumber,
			p = a.merge,
			d = a.pick,
			g = a.deg2rad;
		a.Tick = function(a, d, g, f) {
			this.axis = a;
			this.pos = d;
			this.type = g || "";
			this.isNew = !0;
			g || f || this.addLabel()
		};
		a.Tick.prototype = {
			addLabel: function() {
				var a = this.axis,
					g = a.options,
					r = a.chart,
					f = a.categories,
					b = a.names,
					n = this.pos,
					w = g.labels,
					t = a.tickPositions,
					k = n === t[0],
					e = n === t[t.length - 1],
					b = f ? d(f[n],
						b[n], n) : n,
					f = this.label,
					t = t.info,
					h;
				a.isDatetimeAxis &amp;&amp; t &amp;&amp; (h = g.dateTimeLabelFormats[t.higherRanks[n] || t.unitName]);
				this.isFirst = k;
				this.isLast = e;
				g = a.labelFormatter.call({
					axis: a,
					chart: r,
					isFirst: k,
					isLast: e,
					dateTimeLabelFormat: h,
					value: a.isLog ? E(a.lin2log(b)) : b
				});
				A(f) ? f &amp;&amp; f.attr({
					text: g
				}) : (this.labelLength = (this.label = f = A(g) &amp;&amp; w.enabled ? r.renderer.text(g, 0, 0, w.useHTML).css(p(w.style)).add(a.labelGroup) : null) &amp;&amp; f.getBBox().width, this.rotation = 0)
			},
			getLabelSize: function() {
				return this.label ? this.label.getBBox()[this.axis.horiz ?
					"height" : "width"] : 0
			},
			handleOverflow: function(a) {
				var l = this.axis,
					r = a.x,
					f = l.chart.chartWidth,
					b = l.chart.spacing,
					n = d(l.labelLeft, Math.min(l.pos, b[3])),
					b = d(l.labelRight, Math.max(l.pos + l.len, f - b[1])),
					w = this.label,
					t = this.rotation,
					k = {
						left: 0,
						center: .5,
						right: 1
					}[l.labelAlign],
					e = w.getBBox().width,
					h = l.getSlotWidth(),
					C = h,
					u = 1,
					c, q = {};
				if (t) 0 &gt; t &amp;&amp; r - k * e &lt; n ? c = Math.round(r / Math.cos(t * g) - n) : 0 &lt; t &amp;&amp; r + k * e &gt; b &amp;&amp; (c = Math.round((f - r) / Math.cos(t * g)));
				else if (f = r + (1 - k) * e, r - k * e &lt; n ? C = a.x + C * (1 - k) - n : f &gt; b &amp;&amp; (C = b - a.x + C * k, u = -1), C = Math.min(h,
						C), C &lt; h &amp;&amp; "center" === l.labelAlign &amp;&amp; (a.x += u * (h - C - k * (h - Math.min(e, C)))), e &gt; C || l.autoRotation &amp;&amp; (w.styles || {}).width) c = C;
				c &amp;&amp; (q.width = c, (l.options.labels.style || {}).textOverflow || (q.textOverflow = "ellipsis"), w.css(q))
			},
			getPosition: function(a, d, g, f) {
				var b = this.axis,
					n = b.chart,
					l = f &amp;&amp; n.oldChartHeight || n.chartHeight;
				return {
					x: a ? b.translate(d + g, null, null, f) + b.transB : b.left + b.offset + (b.opposite ? (f &amp;&amp; n.oldChartWidth || n.chartWidth) - b.right - b.left : 0),
					y: a ? l - b.bottom + b.offset - (b.opposite ? b.height : 0) : l - b.translate(d + g, null,
						null, f) - b.transB
				}
			},
			getLabelPosition: function(a, d, r, f, b, n, w, t) {
				var k = this.axis,
					e = k.transA,
					h = k.reversed,
					C = k.staggerLines,
					u = k.tickRotCorr || {
						x: 0,
						y: 0
					},
					c = b.y;
				A(c) || (c = 0 === k.side ? r.rotation ? -8 : -r.getBBox().height : 2 === k.side ? u.y + 8 : Math.cos(r.rotation * g) * (u.y - r.getBBox(!1, 0).height / 2));
				a = a + b.x + u.x - (n &amp;&amp; f ? n * e * (h ? -1 : 1) : 0);
				d = d + c - (n &amp;&amp; !f ? n * e * (h ? 1 : -1) : 0);
				C &amp;&amp; (r = w / (t || 1) % C, k.opposite &amp;&amp; (r = C - r - 1), d += k.labelOffset / C * r);
				return {
					x: a,
					y: Math.round(d)
				}
			},
			getMarkPath: function(a, d, g, f, b, n) {
				return n.crispLine(["M", a, d, "L", a + (b ?
					0 : -g), d + (b ? g : 0)], f)
			},
			render: function(a, g, r) {
				var f = this.axis,
					b = f.options,
					n = f.chart.renderer,
					l = f.horiz,
					t = this.type,
					k = this.label,
					e = this.pos,
					h = b.labels,
					C = this.gridLine,
					u = t ? t + "Tick" : "tick",
					c = f.tickSize(u),
					q = this.mark,
					x = !q,
					K = h.step,
					I = {},
					p = !0,
					D = f.tickmarkOffset,
					G = this.getPosition(l, e, D, g),
					L = G.x,
					G = G.y,
					v = l &amp;&amp; L === f.pos + f.len || !l &amp;&amp; G === f.pos ? -1 : 1,
					m = t ? t + "Grid" : "grid",
					z = b[m + "LineWidth"],
					O = b[m + "LineColor"],
					P = b[m + "LineDashStyle"],
					m = d(b[u + "Width"], !t &amp;&amp; f.isXAxis ? 1 : 0),
					u = b[u + "Color"];
				r = d(r, 1);
				this.isActive = !0;
				C || (I.stroke =
					O, I["stroke-width"] = z, P &amp;&amp; (I.dashstyle = P), t || (I.zIndex = 1), g &amp;&amp; (I.opacity = 0), this.gridLine = C = n.path().attr(I).addClass("highcharts-" + (t ? t + "-" : "") + "grid-line").add(f.gridGroup));
				if (!g &amp;&amp; C &amp;&amp; (e = f.getPlotLinePath(e + D, C.strokeWidth() * v, g, !0))) C[this.isNew ? "attr" : "animate"]({
					d: e,
					opacity: r
				});
				c &amp;&amp; (f.opposite &amp;&amp; (c[0] = -c[0]), x &amp;&amp; (this.mark = q = n.path().addClass("highcharts-" + (t ? t + "-" : "") + "tick").add(f.axisGroup), q.attr({
					stroke: u,
					"stroke-width": m
				})), q[x ? "attr" : "animate"]({
					d: this.getMarkPath(L, G, c[0], q.strokeWidth() *
						v, l, n),
					opacity: r
				}));
				k &amp;&amp; H(L) &amp;&amp; (k.xy = G = this.getLabelPosition(L, G, k, l, h, D, a, K), this.isFirst &amp;&amp; !this.isLast &amp;&amp; !d(b.showFirstLabel, 1) || this.isLast &amp;&amp; !this.isFirst &amp;&amp; !d(b.showLastLabel, 1) ? p = !1 : !l || f.isRadial || h.step || h.rotation || g || 0 === r || this.handleOverflow(G), K &amp;&amp; a % K &amp;&amp; (p = !1), p &amp;&amp; H(G.y) ? (G.opacity = r, k[this.isNew ? "attr" : "animate"](G)) : k.attr("y", -9999), this.isNew = !1)
			},
			destroy: function() {
				F(this, this.axis)
			}
		}
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.animObject,
			F = a.arrayMax,
			H = a.arrayMin,
			p = a.AxisPlotLineOrBandExtension,
			d = a.color,
			g = a.correctFloat,
			v = a.defaultOptions,
			l = a.defined,
			r = a.deg2rad,
			f = a.destroyObjectProperties,
			b = a.each,
			n = a.error,
			w = a.extend,
			t = a.fireEvent,
			k = a.format,
			e = a.getMagnitude,
			h = a.grep,
			C = a.inArray,
			u = a.isArray,
			c = a.isNumber,
			q = a.isString,
			x = a.merge,
			K = a.normalizeTickInterval,
			I = a.pick,
			J = a.PlotLineOrBand,
			D = a.removeEvent,
			G = a.splat,
			L = a.syncTimeout,
			N = a.Tick;
		a.Axis = function() {
			this.init.apply(this, arguments)
		};
		a.Axis.prototype = {
			defaultOptions: {
				dateTimeLabelFormats: {
					millisecond: "%H:%M:%S.%L",
					second: "%H:%M:%S",
					minute: "%H:%M",
					hour: "%H:%M",
					day: "%e. %b",
					week: "%e. %b",
					month: "%b '%y",
					year: "%Y"
				},
				endOnTick: !1,
				labels: {
					enabled: !0,
					style: {
						color: "#666666",
						cursor: "default",
						fontSize: "11px"
					},
					x: 0
				},
				minPadding: .01,
				maxPadding: .01,
				minorTickLength: 2,
				minorTickPosition: "outside",
				startOfWeek: 1,
				startOnTick: !1,
				tickLength: 10,
				tickmarkPlacement: "between",
				tickPixelInterval: 100,
				tickPosition: "outside",
				title: {
					align: "middle",
					style: {
						color: "#666666"
					}
				},
				type: "linear",
				minorGridLineColor: "#f2f2f2",
				minorGridLineWidth: 1,
				minorTickColor: "#999999",
				lineColor: "#ccd6eb",
				lineWidth: 1,
				gridLineColor: "#e6e6e6",
				tickColor: "#ccd6eb"
			},
			defaultYAxisOptions: {
				endOnTick: !0,
				tickPixelInterval: 72,
				showLastLabel: !0,
				labels: {
					x: -8
				},
				maxPadding: .05,
				minPadding: .05,
				startOnTick: !0,
				title: {
					rotation: 270,
					text: "Values"
				},
				stackLabels: {
					enabled: !1,
					formatter: function() {
						return a.numberFormat(this.total, -1)
					},
					style: {
						fontSize: "11px",
						fontWeight: "bold",
						color: "#000000",
						textOutline: "1px contrast"
					}
				},
				gridLineWidth: 1,
				lineWidth: 0
			},
			defaultLeftAxisOptions: {
				labels: {
					x: -15
				},
				title: {
					rotation: 270
				}
			},
			defaultRightAxisOptions: {
				labels: {
					x: 15
				},
				title: {
					rotation: 90
				}
			},
			defaultBottomAxisOptions: {
				labels: {
					autoRotation: [-45],
					x: 0
				},
				title: {
					rotation: 0
				}
			},
			defaultTopAxisOptions: {
				labels: {
					autoRotation: [-45],
					x: 0
				},
				title: {
					rotation: 0
				}
			},
			init: function(a, b) {
				var c = b.isX;
				this.chart = a;
				this.horiz = a.inverted ? !c : c;
				this.isXAxis = c;
				this.coll = this.coll || (c ? "xAxis" : "yAxis");
				this.opposite = b.opposite;
				this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
				this.setOptions(b);
				var e = this.options,
					m = e.type;
				this.labelFormatter = e.labels.formatter || this.defaultLabelFormatter;
				this.userOptions = b;
				this.minPixelPadding = 0;
				this.reversed = e.reversed;
				this.visible = !1 !== e.visible;
				this.zoomEnabled = !1 !== e.zoomEnabled;
				this.hasNames = "category" === m || !0 === e.categories;
				this.categories = e.categories || this.hasNames;
				this.names = this.names || [];
				this.isLog = "logarithmic" === m;
				this.isDatetimeAxis = "datetime" === m;
				this.isLinked = l(e.linkedTo);
				this.ticks = {};
				this.labelEdge = [];
				this.minorTicks = {};
				this.plotLinesAndBands = [];
				this.alternateBands = {};
				this.len = 0;
				this.minRange = this.userMinRange = e.minRange || e.maxZoom;
				this.range = e.range;
				this.offset = e.offset || 0;
				this.stacks = {};
				this.oldStacks = {};
				this.stacksTouched = 0;
				this.min = this.max = null;
				this.crosshair = I(e.crosshair, G(a.options.tooltip.crosshairs)[c ? 0 : 1], !1);
				var z;
				b = this.options.events; - 1 === C(this, a.axes) &amp;&amp; (c ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));
				this.series = this.series || [];
				a.inverted &amp;&amp; c &amp;&amp; void 0 === this.reversed &amp;&amp; (this.reversed = !0);
				this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;
				for (z in b) E(this, z, b[z]);
				this.isLog &amp;&amp; (this.val2lin = this.log2lin, this.lin2val = this.lin2log)
			},
			setOptions: function(a) {
				this.options = x(this.defaultOptions, "yAxis" === this.coll &amp;&amp; this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], x(v[this.coll], a))
			},
			defaultLabelFormatter: function() {
				var b = this.axis,
					c = this.value,
					e = b.categories,
					h = this.dateTimeLabelFormat,
					f = v.lang,
					B = f.numericSymbols,
					f = f.numericSymbolMagnitude || 1E3,
					q = B &amp;&amp; B.length,
					d, n = b.options.labels.format,
					b = b.isLog ? c : b.tickInterval;
				if (n) d = k(n, this);
				else if (e) d = c;
				else if (h) d = a.dateFormat(h, c);
				else if (q &amp;&amp; 1E3 &lt;= b)
					for (; q-- &amp;&amp; void 0 === d;) e = Math.pow(f, q + 1), b &gt;= e &amp;&amp; 0 === 10 * c % e &amp;&amp; null !== B[q] &amp;&amp; 0 !== c &amp;&amp; (d = a.numberFormat(c / e, -1) + B[q]);
				void 0 === d &amp;&amp; (d = 1E4 &lt;= Math.abs(c) ? a.numberFormat(c, -1) : a.numberFormat(c, -1, void 0, ""));
				return d
			},
			getSeriesExtremes: function() {
				var a = this,
					e = a.chart;
				a.hasVisibleSeries = !1;
				a.dataMin = a.dataMax = a.threshold = null;
				a.softThreshold = !a.isXAxis;
				a.buildStacks &amp;&amp; a.buildStacks();
				b(a.series, function(b) {
					if (b.visible ||
						!e.options.chart.ignoreHiddenSeries) {
						var m = b.options,
							z = m.threshold,
							k;
						a.hasVisibleSeries = !0;
						a.isLog &amp;&amp; 0 &gt;= z &amp;&amp; (z = null);
						if (a.isXAxis) m = b.xData, m.length &amp;&amp; (b = H(m), c(b) || b instanceof Date || (m = h(m, function(a) {
							return c(a)
						}), b = H(m)), a.dataMin = Math.min(I(a.dataMin, m[0]), b), a.dataMax = Math.max(I(a.dataMax, m[0]), F(m)));
						else if (b.getExtremes(), k = b.dataMax, b = b.dataMin, l(b) &amp;&amp; l(k) &amp;&amp; (a.dataMin = Math.min(I(a.dataMin, b), b), a.dataMax = Math.max(I(a.dataMax, k), k)), l(z) &amp;&amp; (a.threshold = z), !m.softThreshold || a.isLog) a.softThreshold = !1
					}
				})
			},
			translate: function(a, b, e, h, k, B) {
				var m = this.linkedParent || this,
					z = 1,
					f = 0,
					q = h ? m.oldTransA : m.transA;
				h = h ? m.oldMin : m.min;
				var d = m.minPixelPadding;
				k = (m.isOrdinal || m.isBroken || m.isLog &amp;&amp; k) &amp;&amp; m.lin2val;
				q || (q = m.transA);
				e &amp;&amp; (z *= -1, f = m.len);
				m.reversed &amp;&amp; (z *= -1, f -= z * (m.sector || m.len));
				b ? (a = (a * z + f - d) / q + h, k &amp;&amp; (a = m.lin2val(a))) : (k &amp;&amp; (a = m.val2lin(a)), a = z * (a - h) * q + f + z * d + (c(B) ? q * B : 0));
				return a
			},
			toPixels: function(a, b) {
				return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos)
			},
			toValue: function(a, b) {
				return this.translate(a -
					(b ? 0 : this.pos), !0, !this.horiz, null, !0)
			},
			getPlotLinePath: function(a, b, e, h, k) {
				var m = this.chart,
					z = this.left,
					f = this.top,
					q, d, n = e &amp;&amp; m.oldChartHeight || m.chartHeight,
					u = e &amp;&amp; m.oldChartWidth || m.chartWidth,
					g;
				q = this.transB;
				var t = function(a, b, c) {
					if (a &lt; b || a &gt; c) h ? a = Math.min(Math.max(b, a), c) : g = !0;
					return a
				};
				k = I(k, this.translate(a, null, null, e));
				a = e = Math.round(k + q);
				q = d = Math.round(n - k - q);
				c(k) ? this.horiz ? (q = f, d = n - this.bottom, a = e = t(a, z, z + this.width)) : (a = z, e = u - this.right, q = d = t(q, f, f + this.height)) : g = !0;
				return g &amp;&amp; !h ? null : m.renderer.crispLine(["M",
					a, q, "L", e, d
				], b || 1)
			},
			getLinearTickPositions: function(a, b, e) {
				var m, z = g(Math.floor(b / a) * a),
					h = g(Math.ceil(e / a) * a),
					k = [];
				if (b === e &amp;&amp; c(b)) return [b];
				for (b = z; b &lt;= h;) {
					k.push(b);
					b = g(b + a);
					if (b === m) break;
					m = b
				}
				return k
			},
			getMinorTickPositions: function() {
				var a = this.options,
					b = this.tickPositions,
					c = this.minorTickInterval,
					e = [],
					h, k = this.pointRangePadding || 0;
				h = this.min - k;
				var k = this.max + k,
					f = k - h;
				if (f &amp;&amp; f / c &lt; this.len / 3)
					if (this.isLog)
						for (k = b.length, h = 1; h &lt; k; h++) e = e.concat(this.getLogTickPositions(c, b[h - 1], b[h], !0));
					else if (this.isDatetimeAxis &amp;&amp;
					"auto" === a.minorTickInterval) e = e.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c), h, k, a.startOfWeek));
				else
					for (b = h + (b[0] - h) % c; b &lt;= k &amp;&amp; b !== e[0]; b += c) e.push(b);
				0 !== e.length &amp;&amp; this.trimTicks(e, a.startOnTick, a.endOnTick);
				return e
			},
			adjustForMinRange: function() {
				var a = this.options,
					c = this.min,
					e = this.max,
					h, k = this.dataMax - this.dataMin &gt;= this.minRange,
					f, q, d, n, u, g;
				this.isXAxis &amp;&amp; void 0 === this.minRange &amp;&amp; !this.isLog &amp;&amp; (l(a.min) || l(a.max) ? this.minRange = null : (b(this.series, function(a) {
					n = a.xData;
					for (q = u = a.xIncrement ?
						1 : n.length - 1; 0 &lt; q; q--)
						if (d = n[q] - n[q - 1], void 0 === f || d &lt; f) f = d
				}), this.minRange = Math.min(5 * f, this.dataMax - this.dataMin)));
				e - c &lt; this.minRange &amp;&amp; (g = this.minRange, h = (g - e + c) / 2, h = [c - h, I(a.min, c - h)], k &amp;&amp; (h[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), c = F(h), e = [c + g, I(a.max, c + g)], k &amp;&amp; (e[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), e = H(e), e - c &lt; g &amp;&amp; (h[0] = e - g, h[1] = I(a.min, e - g), c = F(h)));
				this.min = c;
				this.max = e
			},
			getClosest: function() {
				var a;
				this.categories ? a = 1 : b(this.series, function(b) {
					var c = b.closestPointRange,
						e = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
					!b.noSharedTooltip &amp;&amp; l(c) &amp;&amp; e &amp;&amp; (a = l(a) ? Math.min(a, c) : c)
				});
				return a
			},
			nameToX: function(a) {
				var b = u(this.categories),
					c = b ? this.categories : this.names,
					e = a.options.x,
					m;
				a.series.requireSorting = !1;
				l(e) || (e = !1 === this.options.uniqueNames ? a.series.autoIncrement() : C(a.name, c)); - 1 === e ? b || (m = c.length) : m = e;
				this.names[m] = a.name;
				return m
			},
			updateNames: function() {
				var a = this;
				0 &lt; this.names.length &amp;&amp; (this.names.length = 0, this.minRange = void 0, b(this.series || [], function(c) {
					c.xIncrement =
						null;
					if (!c.points || c.isDirtyData) c.processData(), c.generatePoints();
					b(c.points, function(b, e) {
						var m;
						b.options &amp;&amp; void 0 === b.options.x &amp;&amp; (m = a.nameToX(b), m !== b.x &amp;&amp; (b.x = m, c.xData[e] = m))
					})
				}))
			},
			setAxisTranslation: function(a) {
				var c = this,
					e = c.max - c.min,
					m = c.axisPointRange || 0,
					h, k = 0,
					f = 0,
					d = c.linkedParent,
					n = !!c.categories,
					u = c.transA,
					g = c.isXAxis;
				if (g || n || m) h = c.getClosest(), d ? (k = d.minPointOffset, f = d.pointRangePadding) : b(c.series, function(a) {
					var b = n ? 1 : g ? I(a.options.pointRange, h, 0) : c.axisPointRange || 0;
					a = a.options.pointPlacement;
					m = Math.max(m, b);
					c.single || (k = Math.max(k, q(a) ? 0 : b / 2), f = Math.max(f, "on" === a ? 0 : b))
				}), d = c.ordinalSlope &amp;&amp; h ? c.ordinalSlope / h : 1, c.minPointOffset = k *= d, c.pointRangePadding = f *= d, c.pointRange = Math.min(m, e), g &amp;&amp; (c.closestPointRange = h);
				a &amp;&amp; (c.oldTransA = u);
				c.translationSlope = c.transA = u = c.len / (e + f || 1);
				c.transB = c.horiz ? c.left : c.bottom;
				c.minPixelPadding = u * k
			},
			minFromRange: function() {
				return this.max - this.range
			},
			setTickInterval: function(a) {
				var m = this,
					h = m.chart,
					k = m.options,
					f = m.isLog,
					q = m.log2lin,
					d = m.isDatetimeAxis,
					u = m.isXAxis,
					D = m.isLinked,
					x = k.maxPadding,
					C = k.minPadding,
					G = k.tickInterval,
					r = k.tickPixelInterval,
					L = m.categories,
					w = m.threshold,
					p = m.softThreshold,
					v, N, J, A;
				d || L || D || this.getTickAmount();
				J = I(m.userMin, k.min);
				A = I(m.userMax, k.max);
				D ? (m.linkedParent = h[m.coll][k.linkedTo], h = m.linkedParent.getExtremes(), m.min = I(h.min, h.dataMin), m.max = I(h.max, h.dataMax), k.type !== m.linkedParent.options.type &amp;&amp; n(11, 1)) : (!p &amp;&amp; l(w) &amp;&amp; (m.dataMin &gt;= w ? (v = w, C = 0) : m.dataMax &lt;= w &amp;&amp; (N = w, x = 0)), m.min = I(J, v, m.dataMin), m.max = I(A, N, m.dataMax));
				f &amp;&amp; (!a &amp;&amp; 0 &gt;= Math.min(m.min,
					I(m.dataMin, m.min)) &amp;&amp; n(10, 1), m.min = g(q(m.min), 15), m.max = g(q(m.max), 15));
				m.range &amp;&amp; l(m.max) &amp;&amp; (m.userMin = m.min = J = Math.max(m.min, m.minFromRange()), m.userMax = A = m.max, m.range = null);
				t(m, "foundExtremes");
				m.beforePadding &amp;&amp; m.beforePadding();
				m.adjustForMinRange();
				!(L || m.axisPointRange || m.usePercentage || D) &amp;&amp; l(m.min) &amp;&amp; l(m.max) &amp;&amp; (q = m.max - m.min) &amp;&amp; (!l(J) &amp;&amp; C &amp;&amp; (m.min -= q * C), !l(A) &amp;&amp; x &amp;&amp; (m.max += q * x));
				c(k.floor) ? m.min = Math.max(m.min, k.floor) : c(k.softMin) &amp;&amp; (m.min = Math.min(m.min, k.softMin));
				c(k.ceiling) ? m.max = Math.min(m.max,
					k.ceiling) : c(k.softMax) &amp;&amp; (m.max = Math.max(m.max, k.softMax));
				p &amp;&amp; l(m.dataMin) &amp;&amp; (w = w || 0, !l(J) &amp;&amp; m.min &lt; w &amp;&amp; m.dataMin &gt;= w ? m.min = w : !l(A) &amp;&amp; m.max &gt; w &amp;&amp; m.dataMax &lt;= w &amp;&amp; (m.max = w));
				m.tickInterval = m.min === m.max || void 0 === m.min || void 0 === m.max ? 1 : D &amp;&amp; !G &amp;&amp; r === m.linkedParent.options.tickPixelInterval ? G = m.linkedParent.tickInterval : I(G, this.tickAmount ? (m.max - m.min) / Math.max(this.tickAmount - 1, 1) : void 0, L ? 1 : (m.max - m.min) * r / Math.max(m.len, r));
				u &amp;&amp; !a &amp;&amp; b(m.series, function(a) {
					a.processData(m.min !== m.oldMin || m.max !== m.oldMax)
				});
				m.setAxisTranslation(!0);
				m.beforeSetTickPositions &amp;&amp; m.beforeSetTickPositions();
				m.postProcessTickInterval &amp;&amp; (m.tickInterval = m.postProcessTickInterval(m.tickInterval));
				m.pointRange &amp;&amp; !G &amp;&amp; (m.tickInterval = Math.max(m.pointRange, m.tickInterval));
				a = I(k.minTickInterval, m.isDatetimeAxis &amp;&amp; m.closestPointRange);
				!G &amp;&amp; m.tickInterval &lt; a &amp;&amp; (m.tickInterval = a);
				d || f || G || (m.tickInterval = K(m.tickInterval, null, e(m.tickInterval), I(k.allowDecimals, !(.5 &lt; m.tickInterval &amp;&amp; 5 &gt; m.tickInterval &amp;&amp; 1E3 &lt; m.max &amp;&amp; 9999 &gt; m.max)), !!this.tickAmount));
				this.tickAmount || (m.tickInterval =
					m.unsquish());
				this.setTickPositions()
			},
			setTickPositions: function() {
				var a = this.options,
					b, c = a.tickPositions,
					e = a.tickPositioner,
					h = a.startOnTick,
					k = a.endOnTick,
					f;
				this.tickmarkOffset = this.categories &amp;&amp; "between" === a.tickmarkPlacement &amp;&amp; 1 === this.tickInterval ? .5 : 0;
				this.minorTickInterval = "auto" === a.minorTickInterval &amp;&amp; this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;
				this.tickPositions = b = c &amp;&amp; c.slice();
				!b &amp;&amp; (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units),
					this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length &gt; this.len &amp;&amp; (b = [b[0], b.pop()]), this.tickPositions = b, e &amp;&amp; (e = e.apply(this, [this.min, this.max]))) &amp;&amp; (this.tickPositions = b = e);
				this.isLinked || (this.trimTicks(b, h, k), this.min === this.max &amp;&amp; l(this.min) &amp;&amp; !this.tickAmount &amp;&amp; (f = !0, this.min -= .5, this.max += .5), this.single = f, c || e || this.adjustTickAmount())
			},
			trimTicks: function(a, b, c) {
				var e = a[0],
					m = a[a.length - 1],
					h = this.minPointOffset || 0;
				if (b) this.min = e;
				else
					for (; this.min - h &gt; a[0];) a.shift();
				if (c) this.max = m;
				else
					for (; this.max + h &lt; a[a.length - 1];) a.pop();
				0 === a.length &amp;&amp; l(e) &amp;&amp; a.push((m + e) / 2)
			},
			alignToOthers: function() {
				var a = {},
					c, e = this.options;
				!1 !== this.chart.options.chart.alignTicks &amp;&amp; !1 !== e.alignTicks &amp;&amp; b(this.chart[this.coll], function(b) {
					var e = b.options,
						e = [b.horiz ? e.left : e.top, e.width, e.height, e.pane].join();
					b.series.length &amp;&amp; (a[e] ? c = !0 : a[e] = 1)
				});
				return c
			},
			getTickAmount: function() {
				var a =
					this.options,
					b = a.tickAmount,
					c = a.tickPixelInterval;
				!l(a.tickInterval) &amp;&amp; this.len &lt; c &amp;&amp; !this.isRadial &amp;&amp; !this.isLog &amp;&amp; a.startOnTick &amp;&amp; a.endOnTick &amp;&amp; (b = 2);
				!b &amp;&amp; this.alignToOthers() &amp;&amp; (b = Math.ceil(this.len / c) + 1);
				4 &gt; b &amp;&amp; (this.finalTickAmt = b, b = 5);
				this.tickAmount = b
			},
			adjustTickAmount: function() {
				var a = this.tickInterval,
					b = this.tickPositions,
					c = this.tickAmount,
					e = this.finalTickAmt,
					h = b &amp;&amp; b.length;
				if (h &lt; c) {
					for (; b.length &lt; c;) b.push(g(b[b.length - 1] + a));
					this.transA *= (h - 1) / (c - 1);
					this.max = b[b.length - 1]
				} else h &gt; c &amp;&amp; (this.tickInterval *=
					2, this.setTickPositions());
				if (l(e)) {
					for (a = c = b.length; a--;)(3 === e &amp;&amp; 1 === a % 2 || 2 &gt;= e &amp;&amp; 0 &lt; a &amp;&amp; a &lt; c - 1) &amp;&amp; b.splice(a, 1);
					this.finalTickAmt = void 0
				}
			},
			setScale: function() {
				var a, c;
				this.oldMin = this.min;
				this.oldMax = this.max;
				this.oldAxisLength = this.len;
				this.setAxisSize();
				c = this.len !== this.oldAxisLength;
				b(this.series, function(b) {
					if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0
				});
				c || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks &amp;&amp;
					this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = c || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks &amp;&amp; this.cleanStacks()
			},
			setExtremes: function(a, c, e, h, k) {
				var m = this,
					f = m.chart;
				e = I(e, !0);
				b(m.series, function(a) {
					delete a.kdTree
				});
				k = w(k, {
					min: a,
					max: c
				});
				t(m, "setExtremes", k, function() {
					m.userMin = a;
					m.userMax = c;
					m.eventArgs = k;
					e &amp;&amp; f.redraw(h)
				})
			},
			zoom: function(a, b) {
				var c = this.dataMin,
					e = this.dataMax,
					m = this.options,
					h = Math.min(c, I(m.min, c)),
					m = Math.max(e, I(m.max, e));
				if (a !== this.min || b !== this.max) this.allowZoomOutside || (l(c) &amp;&amp; (a &lt; h &amp;&amp; (a = h), a &gt; m &amp;&amp; (a = m)), l(e) &amp;&amp; (b &lt; h &amp;&amp; (b = h), b &gt; m &amp;&amp; (b = m))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, {
					trigger: "zoom"
				});
				return !0
			},
			setAxisSize: function() {
				var a = this.chart,
					b = this.options,
					c = b.offsetLeft || 0,
					e = this.horiz,
					h = I(b.width, a.plotWidth - c + (b.offsetRight || 0)),
					k = I(b.height, a.plotHeight),
					f = I(b.top, a.plotTop),
					b = I(b.left, a.plotLeft + c),
					c = /%$/;
				c.test(k) &amp;&amp; (k = Math.round(parseFloat(k) / 100 * a.plotHeight));
				c.test(f) &amp;&amp; (f = Math.round(parseFloat(f) / 100 * a.plotHeight + a.plotTop));
				this.left = b;
				this.top = f;
				this.width = h;
				this.height = k;
				this.bottom = a.chartHeight - k - f;
				this.right = a.chartWidth - h - b;
				this.len = Math.max(e ? h : k, 0);
				this.pos = e ? b : f
			},
			getExtremes: function() {
				var a = this.isLog,
					b = this.lin2log;
				return {
					min: a ? g(b(this.min)) : this.min,
					max: a ? g(b(this.max)) : this.max,
					dataMin: this.dataMin,
					dataMax: this.dataMax,
					userMin: this.userMin,
					userMax: this.userMax
				}
			},
			getThreshold: function(a) {
				var b =
					this.isLog,
					c = this.lin2log,
					e = b ? c(this.min) : this.min,
					b = b ? c(this.max) : this.max;
				null === a ? a = e : e &gt; a ? a = e : b &lt; a &amp;&amp; (a = b);
				return this.translate(a, 0, 1, 0, 1)
			},
			autoLabelAlign: function(a) {
				a = (I(a, 0) - 90 * this.side + 720) % 360;
				return 15 &lt; a &amp;&amp; 165 &gt; a ? "right" : 195 &lt; a &amp;&amp; 345 &gt; a ? "left" : "center"
			},
			tickSize: function(a) {
				var b = this.options,
					c = b[a + "Length"],
					e = I(b[a + "Width"], "tick" === a &amp;&amp; this.isXAxis ? 1 : 0);
				if (e &amp;&amp; c) return "inside" === b[a + "Position"] &amp;&amp; (c = -c), [c, e]
			},
			labelMetrics: function() {
				return this.chart.renderer.fontMetrics(this.options.labels.style &amp;&amp;
					this.options.labels.style.fontSize, this.ticks[0] &amp;&amp; this.ticks[0].label)
			},
			unsquish: function() {
				var a = this.options.labels,
					c = this.horiz,
					e = this.tickInterval,
					h = e,
					k = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e),
					f, q = a.rotation,
					d = this.labelMetrics(),
					n, u = Number.MAX_VALUE,
					g, t = function(a) {
						a /= k || 1;
						a = 1 &lt; a ? Math.ceil(a) : 1;
						return a * e
					};
				c ? (g = !a.staggerLines &amp;&amp; !a.step &amp;&amp; (l(q) ? [q] : k &lt; I(a.autoRotationLimit, 80) &amp;&amp; a.autoRotation)) &amp;&amp; b(g, function(a) {
					var b;
					if (a === q || a &amp;&amp; -90 &lt;= a &amp;&amp; 90 &gt;= a) n = t(Math.abs(d.h / Math.sin(r * a))), b = n +
						Math.abs(a / 360), b &lt; u &amp;&amp; (u = b, f = a, h = n)
				}) : a.step || (h = t(d.h));
				this.autoRotation = g;
				this.labelRotation = I(f, q);
				return h
			},
			getSlotWidth: function() {
				var a = this.chart,
					b = this.horiz,
					c = this.options.labels,
					e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
					h = a.margin[3];
				return b &amp;&amp; 2 &gt; (c.step || 0) &amp;&amp; !c.rotation &amp;&amp; (this.staggerLines || 1) * a.plotWidth / e || !b &amp;&amp; (h &amp;&amp; h - a.spacing[3] || .33 * a.chartWidth)
			},
			renderUnsquish: function() {
				var a = this.chart,
					c = a.renderer,
					e = this.tickPositions,
					h = this.ticks,
					k = this.options.labels,
					f = this.horiz,
					d = this.getSlotWidth(),
					n = Math.max(1, Math.round(d - 2 * (k.padding || 5))),
					u = {},
					g = this.labelMetrics(),
					t = k.style &amp;&amp; k.style.textOverflow,
					D, C = 0,
					G, l;
				q(k.rotation) || (u.rotation = k.rotation || 0);
				b(e, function(a) {
					(a = h[a]) &amp;&amp; a.labelLength &gt; C &amp;&amp; (C = a.labelLength)
				});
				this.maxLabelLength = C;
				if (this.autoRotation) C &gt; n &amp;&amp; C &gt; g.h ? u.rotation = this.labelRotation : this.labelRotation = 0;
				else if (d &amp;&amp; (D = {
						width: n + "px"
					}, !t))
					for (D.textOverflow = "clip", G = e.length; !f &amp;&amp; G--;)
						if (l = e[G], n = h[l].label) n.styles &amp;&amp; "ellipsis" === n.styles.textOverflow ? n.css({
								textOverflow: "clip"
							}) :
							h[l].labelLength &gt; d &amp;&amp; n.css({
								width: d + "px"
							}), n.getBBox().height &gt; this.len / e.length - (g.h - g.f) &amp;&amp; (n.specCss = {
								textOverflow: "ellipsis"
							});
				u.rotation &amp;&amp; (D = {
					width: (C &gt; .5 * a.chartHeight ? .33 * a.chartHeight : a.chartHeight) + "px"
				}, t || (D.textOverflow = "ellipsis"));
				if (this.labelAlign = k.align || this.autoLabelAlign(this.labelRotation)) u.align = this.labelAlign;
				b(e, function(a) {
					var b = (a = h[a]) &amp;&amp; a.label;
					b &amp;&amp; (b.attr(u), D &amp;&amp; b.css(x(D, b.specCss)), delete b.specCss, a.rotation = u.rotation)
				});
				this.tickRotCorr = c.rotCorr(g.b, this.labelRotation ||
					0, 0 !== this.side)
			},
			hasData: function() {
				return this.hasVisibleSeries || l(this.min) &amp;&amp; l(this.max) &amp;&amp; !!this.tickPositions
			},
			getOffset: function() {
				var a = this,
					c = a.chart,
					e = c.renderer,
					h = a.options,
					k = a.tickPositions,
					f = a.ticks,
					q = a.horiz,
					d = a.side,
					n = c.inverted ? [1, 0, 3, 2][d] : d,
					u, g, t = 0,
					D, x = 0,
					C = h.title,
					G = h.labels,
					r = 0,
					L = a.opposite,
					w = c.axisOffset,
					c = c.clipOffset,
					p = [-1, 1, 1, -1][d],
					K, v = h.className,
					J = a.axisParent,
					A = this.tickSize("tick");
				u = a.hasData();
				a.showAxis = g = u || I(h.showEmpty, !0);
				a.staggerLines = a.horiz &amp;&amp; G.staggerLines;
				a.axisGroup ||
					(a.gridGroup = e.g("grid").attr({
						zIndex: h.gridZIndex || 1
					}).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (v || "")).add(J), a.axisGroup = e.g("axis").attr({
						zIndex: h.zIndex || 2
					}).addClass("highcharts-" + this.coll.toLowerCase() + " " + (v || "")).add(J), a.labelGroup = e.g("axis-labels").attr({
						zIndex: G.zIndex || 7
					}).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (v || "")).add(J));
				if (u || a.isLinked) b(k, function(b) {
					f[b] ? f[b].addLabel() : f[b] = new N(a, b)
				}), a.renderUnsquish(), !1 === G.reserveSpace || 0 !== d &amp;&amp; 2 !== d &amp;&amp; {
					1: "left",
					3: "right"
				}[d] !== a.labelAlign &amp;&amp; "center" !== a.labelAlign || b(k, function(a) {
					r = Math.max(f[a].getLabelSize(), r)
				}), a.staggerLines &amp;&amp; (r *= a.staggerLines, a.labelOffset = r * (a.opposite ? -1 : 1));
				else
					for (K in f) f[K].destroy(), delete f[K];
				C &amp;&amp; C.text &amp;&amp; !1 !== C.enabled &amp;&amp; (a.axisTitle || ((K = C.textAlign) || (K = (q ? {
						low: "left",
						middle: "center",
						high: "right"
					} : {
						low: L ? "right" : "left",
						middle: "center",
						high: L ? "left" : "right"
					})[C.align]), a.axisTitle = e.text(C.text, 0, 0, C.useHTML).attr({
						zIndex: 7,
						rotation: C.rotation || 0,
						align: K
					}).addClass("highcharts-axis-title").css(C.style).add(a.axisGroup),
					a.axisTitle.isNew = !0), g &amp;&amp; (t = a.axisTitle.getBBox()[q ? "height" : "width"], D = C.offset, x = l(D) ? 0 : I(C.margin, q ? 5 : 10)), a.axisTitle[g ? "show" : "hide"](!0));
				a.renderLine();
				a.offset = p * I(h.offset, w[d]);
				a.tickRotCorr = a.tickRotCorr || {
					x: 0,
					y: 0
				};
				e = 0 === d ? -a.labelMetrics().h : 2 === d ? a.tickRotCorr.y : 0;
				x = Math.abs(r) + x;
				r &amp;&amp; (x = x - e + p * (q ? I(G.y, a.tickRotCorr.y + 8 * p) : G.x));
				a.axisTitleMargin = I(D, x);
				w[d] = Math.max(w[d], a.axisTitleMargin + t + p * a.offset, x, u &amp;&amp; k.length &amp;&amp; A ? A[0] : 0);
				h = h.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
				c[n] =
					Math.max(c[n], h)
			},
			getLinePath: function(a) {
				var b = this.chart,
					c = this.opposite,
					e = this.offset,
					m = this.horiz,
					h = this.left + (c ? this.width : 0) + e,
					e = b.chartHeight - this.bottom - (c ? this.height : 0) + e;
				c &amp;&amp; (a *= -1);
				return b.renderer.crispLine(["M", m ? this.left : h, m ? e : this.top, "L", m ? b.chartWidth - this.right : h, m ? e : b.chartHeight - this.bottom], a)
			},
			renderLine: function() {
				this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.axisLine.attr({
					stroke: this.options.lineColor,
					"stroke-width": this.options.lineWidth,
					zIndex: 7
				}))
			},
			getTitlePosition: function() {
				var a = this.horiz,
					b = this.left,
					c = this.top,
					e = this.len,
					h = this.options.title,
					k = a ? b : c,
					f = this.opposite,
					q = this.offset,
					d = h.x || 0,
					n = h.y || 0,
					u = this.chart.renderer.fontMetrics(h.style &amp;&amp; h.style.fontSize, this.axisTitle).f,
					e = {
						low: k + (a ? 0 : e),
						middle: k + e / 2,
						high: k + (a ? e : 0)
					}[h.align],
					b = (a ? c + this.height : b) + (a ? 1 : -1) * (f ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? u : 0);
				return {
					x: a ? e + d : b + (f ? this.width : 0) + q + d,
					y: a ? b + n - (f ? this.height : 0) + q : e + n
				}
			},
			render: function() {
				var a =
					this,
					e = a.chart,
					h = e.renderer,
					k = a.options,
					f = a.isLog,
					q = a.lin2log,
					d = a.isLinked,
					n = a.tickPositions,
					u = a.axisTitle,
					g = a.ticks,
					t = a.minorTicks,
					D = a.alternateBands,
					C = k.stackLabels,
					x = k.alternateGridColor,
					G = a.tickmarkOffset,
					l = a.axisLine,
					r = e.hasRendered &amp;&amp; c(a.oldMin),
					w = a.showAxis,
					I = A(h.globalAnimation),
					p, K;
				a.labelEdge.length = 0;
				a.overlap = !1;
				b([g, t, D], function(a) {
					for (var b in a) a[b].isActive = !1
				});
				if (a.hasData() || d) a.minorTickInterval &amp;&amp; !a.categories &amp;&amp; b(a.getMinorTickPositions(), function(b) {
						t[b] || (t[b] = new N(a, b, "minor"));
						r &amp;&amp; t[b].isNew &amp;&amp; t[b].render(null, !0);
						t[b].render(null, !1, 1)
					}), n.length &amp;&amp; (b(n, function(b, c) {
						if (!d || b &gt;= a.min &amp;&amp; b &lt;= a.max) g[b] || (g[b] = new N(a, b)), r &amp;&amp; g[b].isNew &amp;&amp; g[b].render(c, !0, .1), g[b].render(c)
					}), G &amp;&amp; (0 === a.min || a.single) &amp;&amp; (g[-1] || (g[-1] = new N(a, -1, null, !0)), g[-1].render(-1))), x &amp;&amp; b(n, function(b, c) {
						K = void 0 !== n[c + 1] ? n[c + 1] + G : a.max - G;
						0 === c % 2 &amp;&amp; b &lt; a.max &amp;&amp; K &lt;= a.max + (e.polar ? -G : G) &amp;&amp; (D[b] || (D[b] = new J(a)), p = b + G, D[b].options = {
							from: f ? q(p) : p,
							to: f ? q(K) : K,
							color: x
						}, D[b].render(), D[b].isActive = !0)
					}), a._addedPlotLB ||
					(b((k.plotLines || []).concat(k.plotBands || []), function(b) {
						a.addPlotBandOrLine(b)
					}), a._addedPlotLB = !0);
				b([g, t, D], function(a) {
					var b, c, h = [],
						k = I.duration;
					for (b in a) a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive = !1, h.push(b));
					L(function() {
						for (c = h.length; c--;) a[h[c]] &amp;&amp; !a[h[c]].isActive &amp;&amp; (a[h[c]].destroy(), delete a[h[c]])
					}, a !== D &amp;&amp; e.hasRendered &amp;&amp; k ? k : 0)
				});
				l &amp;&amp; (l[l.isPlaced ? "animate" : "attr"]({
					d: this.getLinePath(l.strokeWidth())
				}), l.isPlaced = !0, l[w ? "show" : "hide"](!0));
				u &amp;&amp; w &amp;&amp; (u[u.isNew ? "attr" : "animate"](a.getTitlePosition()),
					u.isNew = !1);
				C &amp;&amp; C.enabled &amp;&amp; a.renderStackTotals();
				a.isDirty = !1
			},
			redraw: function() {
				this.visible &amp;&amp; (this.render(), b(this.plotLinesAndBands, function(a) {
					a.render()
				}));
				b(this.series, function(a) {
					a.isDirty = !0
				})
			},
			keepProps: "extKey hcEvents names series userMax userMin".split(" "),
			destroy: function(a) {
				var c = this,
					e = c.stacks,
					h, k = c.plotLinesAndBands,
					m;
				a || D(c);
				for (h in e) f(e[h]), e[h] = null;
				b([c.ticks, c.minorTicks, c.alternateBands], function(a) {
					f(a)
				});
				if (k)
					for (a = k.length; a--;) k[a].destroy();
				b("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "),
					function(a) {
						c[a] &amp;&amp; (c[a] = c[a].destroy())
					});
				for (m in c) c.hasOwnProperty(m) &amp;&amp; -1 === C(m, c.keepProps) &amp;&amp; delete c[m]
			},
			drawCrosshair: function(a, b) {
				var c, e = this.crosshair,
					h = I(e.snap, !0),
					k, m = this.cross;
				a || (a = this.cross &amp;&amp; this.cross.e);
				this.crosshair &amp;&amp; !1 !== (l(b) || !h) ? (h ? l(b) &amp;&amp; (k = this.isXAxis ? b.plotX : this.len - b.plotY) : k = a &amp;&amp; (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos), l(k) &amp;&amp; (c = this.getPlotLinePath(b &amp;&amp; (this.isXAxis ? b.x : I(b.stackY, b.y)), null, null, null, k) || null), l(c) ? (b = this.categories &amp;&amp; !this.isRadial,
					m || (this.cross = m = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (b ? "category " : "thin ") + e.className).attr({
						zIndex: I(e.zIndex, 2)
					}).add(), m.attr({
						stroke: e.color || (b ? d("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
						"stroke-width": I(e.width, 1)
					}), e.dashStyle &amp;&amp; m.attr({
						dashstyle: e.dashStyle
					})), m.show().attr({
						d: c
					}), b &amp;&amp; !e.width &amp;&amp; m.attr({
						"stroke-width": this.transA
					}), this.cross.e = a) : this.hideCrosshair()) : this.hideCrosshair()
			},
			hideCrosshair: function() {
				this.cross &amp;&amp; this.cross.hide()
			}
		};
		w(a.Axis.prototype, p)
	})(M);
	(function(a) {
		var E = a.Axis,
			A = a.Date,
			F = a.dateFormat,
			H = a.defaultOptions,
			p = a.defined,
			d = a.each,
			g = a.extend,
			v = a.getMagnitude,
			l = a.getTZOffset,
			r = a.normalizeTickInterval,
			f = a.pick,
			b = a.timeUnits;
		E.prototype.getTimeTicks = function(a, r, t, k) {
			var e = [],
				h = {},
				n = H.global.useUTC,
				u, c = new A(r - l(r)),
				q = A.hcMakeTime,
				x = a.unitRange,
				w = a.count,
				I;
			if (p(r)) {
				c[A.hcSetMilliseconds](x &gt;= b.second ? 0 : w * Math.floor(c.getMilliseconds() / w));
				if (x &gt;= b.second) c[A.hcSetSeconds](x &gt;= b.minute ? 0 : w * Math.floor(c.getSeconds() /
					w));
				if (x &gt;= b.minute) c[A.hcSetMinutes](x &gt;= b.hour ? 0 : w * Math.floor(c[A.hcGetMinutes]() / w));
				if (x &gt;= b.hour) c[A.hcSetHours](x &gt;= b.day ? 0 : w * Math.floor(c[A.hcGetHours]() / w));
				if (x &gt;= b.day) c[A.hcSetDate](x &gt;= b.month ? 1 : w * Math.floor(c[A.hcGetDate]() / w));
				x &gt;= b.month &amp;&amp; (c[A.hcSetMonth](x &gt;= b.year ? 0 : w * Math.floor(c[A.hcGetMonth]() / w)), u = c[A.hcGetFullYear]());
				if (x &gt;= b.year) c[A.hcSetFullYear](u - u % w);
				if (x === b.week) c[A.hcSetDate](c[A.hcGetDate]() - c[A.hcGetDay]() + f(k, 1));
				u = c[A.hcGetFullYear]();
				k = c[A.hcGetMonth]();
				var v = c[A.hcGetDate](),
					D = c[A.hcGetHours]();
				if (A.hcTimezoneOffset || A.hcGetTimezoneOffset) I = (!n || !!A.hcGetTimezoneOffset) &amp;&amp; (t - r &gt; 4 * b.month || l(r) !== l(t)), c = c.getTime(), c = new A(c + l(c));
				n = c.getTime();
				for (r = 1; n &lt; t;) e.push(n), n = x === b.year ? q(u + r * w, 0) : x === b.month ? q(u, k + r * w) : !I || x !== b.day &amp;&amp; x !== b.week ? I &amp;&amp; x === b.hour ? q(u, k, v, D + r * w) : n + x * w : q(u, k, v + r * w * (x === b.day ? 1 : 7)), r++;
				e.push(n);
				x &lt;= b.hour &amp;&amp; d(e, function(a) {
					"000000000" === F("%H%M%S%L", a) &amp;&amp; (h[a] = "day")
				})
			}
			e.info = g(a, {
				higherRanks: h,
				totalRange: x * w
			});
			return e
		};
		E.prototype.normalizeTimeTickInterval =
			function(a, f) {
				var d = f || [
					["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
					["second", [1, 2, 5, 10, 15, 30]],
					["minute", [1, 2, 5, 10, 15, 30]],
					["hour", [1, 2, 3, 4, 6, 8, 12]],
					["day", [1, 2]],
					["week", [1, 2]],
					["month", [1, 2, 3, 4, 6]],
					["year", null]
				];
				f = d[d.length - 1];
				var k = b[f[0]],
					e = f[1],
					h;
				for (h = 0; h &lt; d.length &amp;&amp; !(f = d[h], k = b[f[0]], e = f[1], d[h + 1] &amp;&amp; a &lt;= (k * e[e.length - 1] + b[d[h + 1][0]]) / 2); h++);
				k === b.year &amp;&amp; a &lt; 5 * k &amp;&amp; (e = [1, 2, 5]);
				a = r(a / k, e, "year" === f[0] ? Math.max(v(a / k), 1) : 1);
				return {
					unitRange: k,
					count: a,
					unitName: f[0]
				}
			}
	})(M);
	(function(a) {
		var E = a.Axis,
			A = a.getMagnitude,
			F = a.map,
			H = a.normalizeTickInterval,
			p = a.pick;
		E.prototype.getLogTickPositions = function(a, g, v, l) {
			var d = this.options,
				f = this.len,
				b = this.lin2log,
				n = this.log2lin,
				w = [];
			l || (this._minorAutoInterval = null);
			if (.5 &lt;= a) a = Math.round(a), w = this.getLinearTickPositions(a, g, v);
			else if (.08 &lt;= a)
				for (var f = Math.floor(g), t, k, e, h, C, d = .3 &lt; a ? [1, 2, 4] : .15 &lt; a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; f &lt; v + 1 &amp;&amp; !C; f++)
					for (k = d.length, t = 0; t &lt; k &amp;&amp; !C; t++) e = n(b(f) * d[t]), e &gt; g &amp;&amp; (!l || h &lt;= v) &amp;&amp; void 0 !== h &amp;&amp; w.push(h), h &gt; v &amp;&amp; (C = !0), h = e;
			else g = b(g), v =
				b(v), a = d[l ? "minorTickInterval" : "tickInterval"], a = p("auto" === a ? null : a, this._minorAutoInterval, d.tickPixelInterval / (l ? 5 : 1) * (v - g) / ((l ? f / this.tickPositions.length : f) || 1)), a = H(a, null, A(a)), w = F(this.getLinearTickPositions(a, g, v), n), l || (this._minorAutoInterval = a / 5);
			l || (this.tickInterval = a);
			return w
		};
		E.prototype.log2lin = function(a) {
			return Math.log(a) / Math.LN10
		};
		E.prototype.lin2log = function(a) {
			return Math.pow(10, a)
		}
	})(M);
	(function(a) {
		var E = a.dateFormat,
			A = a.each,
			F = a.extend,
			H = a.format,
			p = a.isNumber,
			d = a.map,
			g =
			a.merge,
			v = a.pick,
			l = a.splat,
			r = a.syncTimeout,
			f = a.timeUnits;
		a.Tooltip = function() {
			this.init.apply(this, arguments)
		};
		a.Tooltip.prototype = {
			init: function(a, f) {
				this.chart = a;
				this.options = f;
				this.crosshairs = [];
				this.now = {
					x: 0,
					y: 0
				};
				this.isHidden = !0;
				this.split = f.split &amp;&amp; !a.inverted;
				this.shared = f.shared || this.split
			},
			cleanSplit: function(a) {
				A(this.chart.series, function(b) {
					var f = b &amp;&amp; b.tt;
					f &amp;&amp; (!f.isActive || a ? b.tt = f.destroy() : f.isActive = !1)
				})
			},
			getLabel: function() {
				var a = this.chart.renderer,
					f = this.options;
				this.label || (this.split ?
					this.label = a.g("tooltip") : (this.label = a.label("", 0, 0, f.shape || "callout", null, null, f.useHTML, null, "tooltip").attr({
						padding: f.padding,
						r: f.borderRadius
					}), this.label.attr({
						fill: f.backgroundColor,
						"stroke-width": f.borderWidth
					}).css(f.style).shadow(f.shadow)), this.label.attr({
						zIndex: 8
					}).add());
				return this.label
			},
			update: function(a) {
				this.destroy();
				this.init(this.chart, g(!0, this.options, a))
			},
			destroy: function() {
				this.label &amp;&amp; (this.label = this.label.destroy());
				this.split &amp;&amp; this.tt &amp;&amp; (this.cleanSplit(this.chart, !0),
					this.tt = this.tt.destroy());
				clearTimeout(this.hideTimer);
				clearTimeout(this.tooltipTimeout)
			},
			move: function(a, f, d, g) {
				var b = this,
					e = b.now,
					h = !1 !== b.options.animation &amp;&amp; !b.isHidden &amp;&amp; (1 &lt; Math.abs(a - e.x) || 1 &lt; Math.abs(f - e.y)),
					n = b.followPointer || 1 &lt; b.len;
				F(e, {
					x: h ? (2 * e.x + a) / 3 : a,
					y: h ? (e.y + f) / 2 : f,
					anchorX: n ? void 0 : h ? (2 * e.anchorX + d) / 3 : d,
					anchorY: n ? void 0 : h ? (e.anchorY + g) / 2 : g
				});
				b.getLabel().attr(e);
				h &amp;&amp; (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
					b &amp;&amp; b.move(a, f, d, g)
				}, 32))
			},
			hide: function(a) {
				var b =
					this;
				clearTimeout(this.hideTimer);
				a = v(a, this.options.hideDelay, 500);
				this.isHidden || (this.hideTimer = r(function() {
					b.getLabel()[a ? "fadeOut" : "hide"]();
					b.isHidden = !0
				}, a))
			},
			getAnchor: function(a, f) {
				var b, n = this.chart,
					k = n.inverted,
					e = n.plotTop,
					h = n.plotLeft,
					g = 0,
					u = 0,
					c, q;
				a = l(a);
				b = a[0].tooltipPos;
				this.followPointer &amp;&amp; f &amp;&amp; (void 0 === f.chartX &amp;&amp; (f = n.pointer.normalize(f)), b = [f.chartX - n.plotLeft, f.chartY - e]);
				b || (A(a, function(a) {
					c = a.series.yAxis;
					q = a.series.xAxis;
					g += a.plotX + (!k &amp;&amp; q ? q.left - h : 0);
					u += (a.plotLow ? (a.plotLow + a.plotHigh) /
						2 : a.plotY) + (!k &amp;&amp; c ? c.top - e : 0)
				}), g /= a.length, u /= a.length, b = [k ? n.plotWidth - u : g, this.shared &amp;&amp; !k &amp;&amp; 1 &lt; a.length &amp;&amp; f ? f.chartY - e : k ? n.plotHeight - g : u]);
				return d(b, Math.round)
			},
			getPosition: function(a, f, d) {
				var b = this.chart,
					k = this.distance,
					e = {},
					h = d.h || 0,
					n, u = ["y", b.chartHeight, f, d.plotY + b.plotTop, b.plotTop, b.plotTop + b.plotHeight],
					c = ["x", b.chartWidth, a, d.plotX + b.plotLeft, b.plotLeft, b.plotLeft + b.plotWidth],
					q = !this.followPointer &amp;&amp; v(d.ttBelow, !b.inverted === !!d.negative),
					g = function(a, b, c, f, m, d) {
						var n = c &lt; f - k,
							u = f + k + c &lt; b,
							g =
							f - k - c;
						f += k;
						if (q &amp;&amp; u) e[a] = f;
						else if (!q &amp;&amp; n) e[a] = g;
						else if (n) e[a] = Math.min(d - c, 0 &gt; g - h ? g : g - h);
						else if (u) e[a] = Math.max(m, f + h + c &gt; b ? f : f + h);
						else return !1
					},
					l = function(a, b, c, h) {
						var m;
						h &lt; k || h &gt; b - k ? m = !1 : e[a] = h &lt; c / 2 ? 1 : h &gt; b - c / 2 ? b - c - 2 : h - c / 2;
						return m
					},
					r = function(a) {
						var b = u;
						u = c;
						c = b;
						n = a
					},
					p = function() {
						!1 !== g.apply(0, u) ? !1 !== l.apply(0, c) || n || (r(!0), p()) : n ? e.x = e.y = 0 : (r(!0), p())
					};
				(b.inverted || 1 &lt; this.len) &amp;&amp; r();
				p();
				return e
			},
			defaultFormatter: function(a) {
				var b = this.points || l(this),
					f;
				f = [a.tooltipFooterHeaderFormatter(b[0])];
				f = f.concat(a.bodyFormatter(b));
				f.push(a.tooltipFooterHeaderFormatter(b[0], !0));
				return f
			},
			refresh: function(a, f) {
				var b = this.chart,
					d, k = this.options,
					e, h, n = {},
					u = [];
				d = k.formatter || this.defaultFormatter;
				var n = b.hoverPoints,
					c = this.shared;
				clearTimeout(this.hideTimer);
				this.followPointer = l(a)[0].series.tooltipOptions.followPointer;
				h = this.getAnchor(a, f);
				f = h[0];
				e = h[1];
				!c || a.series &amp;&amp; a.series.noSharedTooltip ? n = a.getLabelConfig() : (b.hoverPoints = a, n &amp;&amp; A(n, function(a) {
						a.setState()
					}), A(a, function(a) {
						a.setState("hover");
						u.push(a.getLabelConfig())
					}),
					n = {
						x: a[0].category,
						y: a[0].y
					}, n.points = u, this.len = u.length, a = a[0]);
				n = d.call(n, this);
				c = a.series;
				this.distance = v(c.tooltipOptions.distance, 16);
				!1 === n ? this.hide() : (d = this.getLabel(), this.isHidden &amp;&amp; d.attr({
					opacity: 1
				}).show(), this.split ? this.renderSplit(n, b.hoverPoints) : (d.attr({
					text: n &amp;&amp; n.join ? n.join("") : n
				}), d.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + v(a.colorIndex, c.colorIndex)), d.attr({
					stroke: k.borderColor || a.color || c.color || "#666666"
				}), this.updatePosition({
					plotX: f,
					plotY: e,
					negative: a.negative,
					ttBelow: a.ttBelow,
					h: h[2] || 0
				})), this.isHidden = !1)
			},
			renderSplit: function(b, f) {
				var d = this,
					n = [],
					k = this.chart,
					e = k.renderer,
					h = !0,
					g = this.options,
					u, c = this.getLabel();
				A(b.slice(0, b.length - 1), function(a, b) {
					b = f[b - 1] || {
						isHeader: !0,
						plotX: f[0].plotX
					};
					var q = b.series || d,
						t = q.tt,
						x = b.series || {},
						D = "highcharts-color-" + v(b.colorIndex, x.colorIndex, "none");
					t || (q.tt = t = e.label(null, null, null, "callout").addClass("highcharts-tooltip-box " + D).attr({
						padding: g.padding,
						r: g.borderRadius,
						fill: g.backgroundColor,
						stroke: b.color || x.color || "#333333",
						"stroke-width": g.borderWidth
					}).add(c));
					t.isActive = !0;
					t.attr({
						text: a
					});
					t.css(g.style);
					a = t.getBBox();
					x = a.width + t.strokeWidth();
					b.isHeader ? (u = a.height, x = Math.max(0, Math.min(b.plotX + k.plotLeft - x / 2, k.chartWidth - x))) : x = b.plotX + k.plotLeft - v(g.distance, 16) - x;
					0 &gt; x &amp;&amp; (h = !1);
					a = (b.series &amp;&amp; b.series.yAxis &amp;&amp; b.series.yAxis.pos) + (b.plotY || 0);
					a -= k.plotTop;
					n.push({
						target: b.isHeader ? k.plotHeight + u : a,
						rank: b.isHeader ? 1 : 0,
						size: q.tt.getBBox().height + 1,
						point: b,
						x: x,
						tt: t
					})
				});
				this.cleanSplit();
				a.distribute(n, k.plotHeight + u);
				A(n, function(a) {
					var b = a.point;
					a.tt.attr({
						visibility: void 0 === a.pos ? "hidden" : "inherit",
						x: h || b.isHeader ? a.x : b.plotX + k.plotLeft + v(g.distance, 16),
						y: a.pos + k.plotTop,
						anchorX: b.plotX + k.plotLeft,
						anchorY: b.isHeader ? a.pos + k.plotTop - 15 : b.plotY + k.plotTop
					})
				})
			},
			updatePosition: function(a) {
				var b = this.chart,
					f = this.getLabel(),
					f = (this.options.positioner || this.getPosition).call(this, f.width, f.height, a);
				this.move(Math.round(f.x), Math.round(f.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop)
			},
			getXDateFormat: function(a, d, g) {
				var b;
				d = d.dateTimeLabelFormats;
				var k = g &amp;&amp; g.closestPointRange,
					e, h = {
						millisecond: 15,
						second: 12,
						minute: 9,
						hour: 6,
						day: 3
					},
					n, u = "millisecond";
				if (k) {
					n = E("%m-%d %H:%M:%S.%L", a.x);
					for (e in f) {
						if (k === f.week &amp;&amp; +E("%w", a.x) === g.options.startOfWeek &amp;&amp; "00:00:00.000" === n.substr(6)) {
							e = "week";
							break
						}
						if (f[e] &gt; k) {
							e = u;
							break
						}
						if (h[e] &amp;&amp; n.substr(h[e]) !== "01-01 00:00:00.000".substr(h[e])) break;
						"week" !== e &amp;&amp; (u = e)
					}
					e &amp;&amp; (b = d[e])
				} else b = d.day;
				return b || d.year
			},
			tooltipFooterHeaderFormatter: function(a, f) {
				var b =
					f ? "footer" : "header";
				f = a.series;
				var d = f.tooltipOptions,
					k = d.xDateFormat,
					e = f.xAxis,
					h = e &amp;&amp; "datetime" === e.options.type &amp;&amp; p(a.key),
					b = d[b + "Format"];
				h &amp;&amp; !k &amp;&amp; (k = this.getXDateFormat(a, d, e));
				h &amp;&amp; k &amp;&amp; (b = b.replace("{point.key}", "{point.key:" + k + "}"));
				return H(b, {
					point: a,
					series: f
				})
			},
			bodyFormatter: function(a) {
				return d(a, function(a) {
					var b = a.series.tooltipOptions;
					return (b.pointFormatter || a.point.tooltipFormatter).call(a.point, b.pointFormat)
				})
			}
		}
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.attr,
			F = a.charts,
			H = a.color,
			p = a.css,
			d =
			a.defined,
			g = a.doc,
			v = a.each,
			l = a.extend,
			r = a.fireEvent,
			f = a.offset,
			b = a.pick,
			n = a.removeEvent,
			w = a.splat,
			t = a.Tooltip,
			k = a.win;
		a.Pointer = function(a, b) {
			this.init(a, b)
		};
		a.Pointer.prototype = {
			init: function(a, h) {
				this.options = h;
				this.chart = a;
				this.runChartClick = h.chart.events &amp;&amp; !!h.chart.events.click;
				this.pinchDown = [];
				this.lastValidTouch = {};
				t &amp;&amp; h.tooltip.enabled &amp;&amp; (a.tooltip = new t(a, h.tooltip), this.followTouchMove = b(h.tooltip.followTouchMove, !0));
				this.setDOMEvents()
			},
			zoomOption: function(a) {
				var e = this.chart,
					f = e.options.chart,
					k = f.zoomType || "",
					e = e.inverted;
				/touch/.test(a.type) &amp;&amp; (k = b(f.pinchType, k));
				this.zoomX = a = /x/.test(k);
				this.zoomY = k = /y/.test(k);
				this.zoomHor = a &amp;&amp; !e || k &amp;&amp; e;
				this.zoomVert = k &amp;&amp; !e || a &amp;&amp; e;
				this.hasZoom = a || k
			},
			normalize: function(a, b) {
				var e, h;
				a = a || k.event;
				a.target || (a.target = a.srcElement);
				h = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;
				b || (this.chartPosition = b = f(this.chart.container));
				void 0 === h.pageX ? (e = Math.max(a.x, a.clientX - b.left), b = a.y) : (e = h.pageX - b.left, b = h.pageY - b.top);
				return l(a, {
					chartX: Math.round(e),
					chartY: Math.round(b)
				})
			},
			getCoordinates: function(a) {
				var b = {
					xAxis: [],
					yAxis: []
				};
				v(this.chart.axes, function(e) {
					b[e.isXAxis ? "xAxis" : "yAxis"].push({
						axis: e,
						value: e.toValue(a[e.horiz ? "chartX" : "chartY"])
					})
				});
				return b
			},
			runPointActions: function(e) {
				var h = this.chart,
					f = h.series,
					k = h.tooltip,
					c = k ? k.shared : !1,
					d = !0,
					n = h.hoverPoint,
					t = h.hoverSeries,
					l, r, D, G = [],
					L;
				if (!c &amp;&amp; !t)
					for (l = 0; l &lt; f.length; l++)
						if (f[l].directTouch || !f[l].options.stickyTracking) f = [];
				t &amp;&amp; (c ? t.noSharedTooltip : t.directTouch) &amp;&amp; n ? G = [n] : (c || !t || t.options.stickyTracking ||
					(f = [t]), v(f, function(a) {
						r = a.noSharedTooltip &amp;&amp; c;
						D = !c &amp;&amp; a.directTouch;
						a.visible &amp;&amp; !r &amp;&amp; !D &amp;&amp; b(a.options.enableMouseTracking, !0) &amp;&amp; (L = a.searchPoint(e, !r &amp;&amp; 1 === a.kdDimensions)) &amp;&amp; L.series &amp;&amp; G.push(L)
					}), G.sort(function(a, b) {
						var e = a.distX - b.distX,
							h = a.dist - b.dist,
							k = b.series.group.zIndex - a.series.group.zIndex;
						return 0 !== e &amp;&amp; c ? e : 0 !== h ? h : 0 !== k ? k : a.series.index &gt; b.series.index ? -1 : 1
					}));
				if (c)
					for (l = G.length; l--;)(G[l].x !== G[0].x || G[l].series.noSharedTooltip) &amp;&amp; G.splice(l, 1);
				if (G[0] &amp;&amp; (G[0] !== this.prevKDPoint || k &amp;&amp; k.isHidden)) {
					if (c &amp;&amp;
						!G[0].series.noSharedTooltip) {
						for (l = 0; l &lt; G.length; l++) G[l].onMouseOver(e, G[l] !== (t &amp;&amp; t.directTouch &amp;&amp; n || G[0]));
						G.length &amp;&amp; k &amp;&amp; k.refresh(G.sort(function(a, b) {
							return a.series.index - b.series.index
						}), e)
					} else if (k &amp;&amp; k.refresh(G[0], e), !t || !t.directTouch) G[0].onMouseOver(e);
					this.prevKDPoint = G[0];
					d = !1
				}
				d &amp;&amp; (f = t &amp;&amp; t.tooltipOptions.followPointer, k &amp;&amp; f &amp;&amp; !k.isHidden &amp;&amp; (f = k.getAnchor([{}], e), k.updatePosition({
					plotX: f[0],
					plotY: f[1]
				})));
				this.unDocMouseMove || (this.unDocMouseMove = E(g, "mousemove", function(b) {
					if (F[a.hoverChartIndex]) F[a.hoverChartIndex].pointer.onDocumentMouseMove(b)
				}));
				v(c ? G : [b(n, G[0])], function(a) {
					v(h.axes, function(b) {
						(!a || a.series &amp;&amp; a.series[b.coll] === b) &amp;&amp; b.drawCrosshair(e, a)
					})
				})
			},
			reset: function(a, b) {
				var e = this.chart,
					h = e.hoverSeries,
					c = e.hoverPoint,
					k = e.hoverPoints,
					f = e.tooltip,
					d = f &amp;&amp; f.shared ? k : c;
				a &amp;&amp; d &amp;&amp; v(w(d), function(b) {
					b.series.isCartesian &amp;&amp; void 0 === b.plotX &amp;&amp; (a = !1)
				});
				if (a) f &amp;&amp; d &amp;&amp; (f.refresh(d), c &amp;&amp; (c.setState(c.state, !0), v(e.axes, function(a) {
					a.crosshair &amp;&amp; a.drawCrosshair(null, c)
				})));
				else {
					if (c) c.onMouseOut();
					k &amp;&amp; v(k, function(a) {
						a.setState()
					});
					if (h) h.onMouseOut();
					f &amp;&amp; f.hide(b);
					this.unDocMouseMove &amp;&amp; (this.unDocMouseMove = this.unDocMouseMove());
					v(e.axes, function(a) {
						a.hideCrosshair()
					});
					this.hoverX = this.prevKDPoint = e.hoverPoints = e.hoverPoint = null
				}
			},
			scaleGroups: function(a, b) {
				var e = this.chart,
					h;
				v(e.series, function(c) {
					h = a || c.getPlotBox();
					c.xAxis &amp;&amp; c.xAxis.zoomEnabled &amp;&amp; c.group &amp;&amp; (c.group.attr(h), c.markerGroup &amp;&amp; (c.markerGroup.attr(h), c.markerGroup.clip(b ? e.clipRect : null)), c.dataLabelsGroup &amp;&amp; c.dataLabelsGroup.attr(h))
				});
				e.clipRect.attr(b || e.clipBox)
			},
			dragStart: function(a) {
				var b = this.chart;
				b.mouseIsDown = a.type;
				b.cancelClick = !1;
				b.mouseDownX = this.mouseDownX = a.chartX;
				b.mouseDownY = this.mouseDownY = a.chartY
			},
			drag: function(a) {
				var b = this.chart,
					e = b.options.chart,
					k = a.chartX,
					c = a.chartY,
					f = this.zoomHor,
					d = this.zoomVert,
					g = b.plotLeft,
					n = b.plotTop,
					t = b.plotWidth,
					D = b.plotHeight,
					l, r = this.selectionMarker,
					p = this.mouseDownX,
					m = this.mouseDownY,
					z = e.panKey &amp;&amp; a[e.panKey + "Key"];
				r &amp;&amp; r.touch || (k &lt; g ? k = g : k &gt; g + t &amp;&amp; (k = g + t), c &lt; n ? c = n : c &gt; n + D &amp;&amp; (c = n + D), this.hasDragged = Math.sqrt(Math.pow(p - k, 2) + Math.pow(m - c, 2)), 10 &lt; this.hasDragged &amp;&amp;
					(l = b.isInsidePlot(p - g, m - n), b.hasCartesianSeries &amp;&amp; (this.zoomX || this.zoomY) &amp;&amp; l &amp;&amp; !z &amp;&amp; !r &amp;&amp; (this.selectionMarker = r = b.renderer.rect(g, n, f ? 1 : t, d ? 1 : D, 0).attr({
						fill: e.selectionMarkerFill || H("#335cad").setOpacity(.25).get(),
						"class": "highcharts-selection-marker",
						zIndex: 7
					}).add()), r &amp;&amp; f &amp;&amp; (k -= p, r.attr({
						width: Math.abs(k),
						x: (0 &lt; k ? 0 : k) + p
					})), r &amp;&amp; d &amp;&amp; (k = c - m, r.attr({
						height: Math.abs(k),
						y: (0 &lt; k ? 0 : k) + m
					})), l &amp;&amp; !r &amp;&amp; e.panning &amp;&amp; b.pan(a, e.panning)))
			},
			drop: function(a) {
				var b = this,
					e = this.chart,
					k = this.hasPinched;
				if (this.selectionMarker) {
					var c = {
							originalEvent: a,
							xAxis: [],
							yAxis: []
						},
						f = this.selectionMarker,
						g = f.attr ? f.attr("x") : f.x,
						n = f.attr ? f.attr("y") : f.y,
						t = f.attr ? f.attr("width") : f.width,
						w = f.attr ? f.attr("height") : f.height,
						D;
					if (this.hasDragged || k) v(e.axes, function(e) {
						if (e.zoomEnabled &amp;&amp; d(e.min) &amp;&amp; (k || b[{
								xAxis: "zoomX",
								yAxis: "zoomY"
							}[e.coll]])) {
							var f = e.horiz,
								h = "touchend" === a.type ? e.minPixelPadding : 0,
								m = e.toValue((f ? g : n) + h),
								f = e.toValue((f ? g + t : n + w) - h);
							c[e.coll].push({
								axis: e,
								min: Math.min(m, f),
								max: Math.max(m, f)
							});
							D = !0
						}
					}), D &amp;&amp; r(e, "selection", c, function(a) {
						e.zoom(l(a,
							k ? {
								animation: !1
							} : null))
					});
					this.selectionMarker = this.selectionMarker.destroy();
					k &amp;&amp; this.scaleGroups()
				}
				e &amp;&amp; (p(e.container, {
					cursor: e._cursor
				}), e.cancelClick = 10 &lt; this.hasDragged, e.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])
			},
			onContainerMouseDown: function(a) {
				a = this.normalize(a);
				this.zoomOption(a);
				a.preventDefault &amp;&amp; a.preventDefault();
				this.dragStart(a)
			},
			onDocumentMouseUp: function(b) {
				F[a.hoverChartIndex] &amp;&amp; F[a.hoverChartIndex].pointer.drop(b)
			},
			onDocumentMouseMove: function(a) {
				var b = this.chart,
					e = this.chartPosition;
				a = this.normalize(a, e);
				!e || this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset()
			},
			onContainerMouseLeave: function(b) {
				var e = F[a.hoverChartIndex];
				e &amp;&amp; (b.relatedTarget || b.toElement) &amp;&amp; (e.pointer.reset(), e.pointer.chartPosition = null)
			},
			onContainerMouseMove: function(b) {
				var e = this.chart;
				d(a.hoverChartIndex) &amp;&amp; F[a.hoverChartIndex] &amp;&amp; F[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = e.index);
				b = this.normalize(b);
				b.returnValue = !1;
				"mousedown" === e.mouseIsDown &amp;&amp; this.drag(b);
				!this.inClass(b.target, "highcharts-tracker") &amp;&amp; !e.isInsidePlot(b.chartX - e.plotLeft, b.chartY - e.plotTop) || e.openMenu || this.runPointActions(b)
			},
			inClass: function(a, b) {
				for (var e; a;) {
					if (e = A(a, "class")) {
						if (-1 !== e.indexOf(b)) return !0;
						if (-1 !== e.indexOf("highcharts-container")) return !1
					}
					a = a.parentNode
				}
			},
			onTrackerMouseOut: function(a) {
				var b = this.chart.hoverSeries;
				a = a.relatedTarget || a.toElement;
				if (!(!b || !a || b.options.stickyTracking || this.inClass(a, "highcharts-tooltip") ||
						this.inClass(a, "highcharts-series-" + b.index) &amp;&amp; this.inClass(a, "highcharts-tracker"))) b.onMouseOut()
			},
			onContainerClick: function(a) {
				var b = this.chart,
					e = b.hoverPoint,
					f = b.plotLeft,
					c = b.plotTop;
				a = this.normalize(a);
				b.cancelClick || (e &amp;&amp; this.inClass(a.target, "highcharts-tracker") ? (r(e.series, "click", l(a, {
					point: e
				})), b.hoverPoint &amp;&amp; e.firePointEvent("click", a)) : (l(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - f, a.chartY - c) &amp;&amp; r(b, "click", a)))
			},
			setDOMEvents: function() {
				var b = this,
					f = b.chart.container;
				f.onmousedown =
					function(a) {
						b.onContainerMouseDown(a)
					};
				f.onmousemove = function(a) {
					b.onContainerMouseMove(a)
				};
				f.onclick = function(a) {
					b.onContainerClick(a)
				};
				E(f, "mouseleave", b.onContainerMouseLeave);
				1 === a.chartCount &amp;&amp; E(g, "mouseup", b.onDocumentMouseUp);
				a.hasTouch &amp;&amp; (f.ontouchstart = function(a) {
					b.onContainerTouchStart(a)
				}, f.ontouchmove = function(a) {
					b.onContainerTouchMove(a)
				}, 1 === a.chartCount &amp;&amp; E(g, "touchend", b.onDocumentTouchEnd))
			},
			destroy: function() {
				var b;
				n(this.chart.container, "mouseleave", this.onContainerMouseLeave);
				a.chartCount ||
					(n(g, "mouseup", this.onDocumentMouseUp), n(g, "touchend", this.onDocumentTouchEnd));
				clearInterval(this.tooltipTimeout);
				for (b in this) this[b] = null
			}
		}
	})(M);
	(function(a) {
		var E = a.charts,
			A = a.each,
			F = a.extend,
			H = a.map,
			p = a.noop,
			d = a.pick;
		F(a.Pointer.prototype, {
			pinchTranslate: function(a, d, l, r, f, b) {
				this.zoomHor &amp;&amp; this.pinchTranslateDirection(!0, a, d, l, r, f, b);
				this.zoomVert &amp;&amp; this.pinchTranslateDirection(!1, a, d, l, r, f, b)
			},
			pinchTranslateDirection: function(a, d, l, r, f, b, n, p) {
				var g = this.chart,
					k = a ? "x" : "y",
					e = a ? "X" : "Y",
					h = "chart" +
					e,
					v = a ? "width" : "height",
					u = g["plot" + (a ? "Left" : "Top")],
					c, q, x = p || 1,
					w = g.inverted,
					I = g.bounds[a ? "h" : "v"],
					J = 1 === d.length,
					D = d[0][h],
					G = l[0][h],
					L = !J &amp;&amp; d[1][h],
					N = !J &amp;&amp; l[1][h],
					m;
				l = function() {
					!J &amp;&amp; 20 &lt; Math.abs(D - L) &amp;&amp; (x = p || Math.abs(G - N) / Math.abs(D - L));
					q = (u - G) / x + D;
					c = g["plot" + (a ? "Width" : "Height")] / x
				};
				l();
				d = q;
				d &lt; I.min ? (d = I.min, m = !0) : d + c &gt; I.max &amp;&amp; (d = I.max - c, m = !0);
				m ? (G -= .8 * (G - n[k][0]), J || (N -= .8 * (N - n[k][1])), l()) : n[k] = [G, N];
				w || (b[k] = q - u, b[v] = c);
				b = w ? 1 / x : x;
				f[v] = c;
				f[k] = d;
				r[w ? a ? "scaleY" : "scaleX" : "scale" + e] = x;
				r["translate" + e] = b *
					u + (G - b * D)
			},
			pinch: function(a) {
				var g = this,
					l = g.chart,
					r = g.pinchDown,
					f = a.touches,
					b = f.length,
					n = g.lastValidTouch,
					w = g.hasZoom,
					t = g.selectionMarker,
					k = {},
					e = 1 === b &amp;&amp; (g.inClass(a.target, "highcharts-tracker") &amp;&amp; l.runTrackerClick || g.runChartClick),
					h = {};
				1 &lt; b &amp;&amp; (g.initiated = !0);
				w &amp;&amp; g.initiated &amp;&amp; !e &amp;&amp; a.preventDefault();
				H(f, function(a) {
					return g.normalize(a)
				});
				"touchstart" === a.type ? (A(f, function(a, b) {
					r[b] = {
						chartX: a.chartX,
						chartY: a.chartY
					}
				}), n.x = [r[0].chartX, r[1] &amp;&amp; r[1].chartX], n.y = [r[0].chartY, r[1] &amp;&amp; r[1].chartY], A(l.axes, function(a) {
					if (a.zoomEnabled) {
						var b =
							l.bounds[a.horiz ? "h" : "v"],
							c = a.minPixelPadding,
							e = a.toPixels(d(a.options.min, a.dataMin)),
							f = a.toPixels(d(a.options.max, a.dataMax)),
							k = Math.max(e, f);
						b.min = Math.min(a.pos, Math.min(e, f) - c);
						b.max = Math.max(a.pos + a.len, k + c)
					}
				}), g.res = !0) : g.followTouchMove &amp;&amp; 1 === b ? this.runPointActions(g.normalize(a)) : r.length &amp;&amp; (t || (g.selectionMarker = t = F({
					destroy: p,
					touch: !0
				}, l.plotBox)), g.pinchTranslate(r, f, k, t, h, n), g.hasPinched = w, g.scaleGroups(k, h), g.res &amp;&amp; (g.res = !1, this.reset(!1, 0)))
			},
			touch: function(g, p) {
				var l = this.chart,
					r, f;
				if (l.index !== a.hoverChartIndex) this.onContainerMouseLeave({
					relatedTarget: !0
				});
				a.hoverChartIndex = l.index;
				1 === g.touches.length ? (g = this.normalize(g), (f = l.isInsidePlot(g.chartX - l.plotLeft, g.chartY - l.plotTop)) &amp;&amp; !l.openMenu ? (p &amp;&amp; this.runPointActions(g), "touchmove" === g.type &amp;&amp; (p = this.pinchDown, r = p[0] ? 4 &lt;= Math.sqrt(Math.pow(p[0].chartX - g.chartX, 2) + Math.pow(p[0].chartY - g.chartY, 2)) : !1), d(r, !0) &amp;&amp; this.pinch(g)) : p &amp;&amp; this.reset()) : 2 === g.touches.length &amp;&amp; this.pinch(g)
			},
			onContainerTouchStart: function(a) {
				this.zoomOption(a);
				this.touch(a, !0)
			},
			onContainerTouchMove: function(a) {
				this.touch(a)
			},
			onDocumentTouchEnd: function(d) {
				E[a.hoverChartIndex] &amp;&amp; E[a.hoverChartIndex].pointer.drop(d)
			}
		})
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.charts,
			F = a.css,
			H = a.doc,
			p = a.extend,
			d = a.noop,
			g = a.Pointer,
			v = a.removeEvent,
			l = a.win,
			r = a.wrap;
		if (l.PointerEvent || l.MSPointerEvent) {
			var f = {},
				b = !!l.PointerEvent,
				n = function() {
					var a, b = [];
					b.item = function(a) {
						return this[a]
					};
					for (a in f) f.hasOwnProperty(a) &amp;&amp; b.push({
						pageX: f[a].pageX,
						pageY: f[a].pageY,
						target: f[a].target
					});
					return b
				},
				w = function(b, f, e, h) {
					"touch" !== b.pointerType &amp;&amp; b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !A[a.hoverChartIndex] || (h(b), h = A[a.hoverChartIndex].pointer, h[f]({
						type: e,
						target: b.currentTarget,
						preventDefault: d,
						touches: n()
					}))
				};
			p(g.prototype, {
				onContainerPointerDown: function(a) {
					w(a, "onContainerTouchStart", "touchstart", function(a) {
						f[a.pointerId] = {
							pageX: a.pageX,
							pageY: a.pageY,
							target: a.currentTarget
						}
					})
				},
				onContainerPointerMove: function(a) {
					w(a, "onContainerTouchMove", "touchmove", function(a) {
						f[a.pointerId] = {
							pageX: a.pageX,
							pageY: a.pageY
						};
						f[a.pointerId].target || (f[a.pointerId].target = a.currentTarget)
					})
				},
				onDocumentPointerUp: function(a) {
					w(a, "onDocumentTouchEnd", "touchend", function(a) {
						delete f[a.pointerId]
					})
				},
				batchMSEvents: function(a) {
					a(this.chart.container, b ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
					a(this.chart.container, b ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
					a(H, b ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp)
				}
			});
			r(g.prototype, "init", function(a, b, e) {
				a.call(this, b, e);
				this.hasZoom &amp;&amp;
					F(b.container, {
						"-ms-touch-action": "none",
						"touch-action": "none"
					})
			});
			r(g.prototype, "setDOMEvents", function(a) {
				a.apply(this);
				(this.hasZoom || this.followTouchMove) &amp;&amp; this.batchMSEvents(E)
			});
			r(g.prototype, "destroy", function(a) {
				this.batchMSEvents(v);
				a.call(this)
			})
		}
	})(M);
	(function(a) {
		var E, A = a.addEvent,
			F = a.css,
			H = a.discardElement,
			p = a.defined,
			d = a.each,
			g = a.extend,
			v = a.isFirefox,
			l = a.marginNames,
			r = a.merge,
			f = a.pick,
			b = a.setAnimation,
			n = a.stableSort,
			w = a.win,
			t = a.wrap;
		E = a.Legend = function(a, b) {
			this.init(a, b)
		};
		E.prototype = {
			init: function(a, b) {
				this.chart = a;
				this.setOptions(b);
				b.enabled &amp;&amp; (this.render(), A(this.chart, "endResize", function() {
					this.legend.positionCheckboxes()
				}))
			},
			setOptions: function(a) {
				var b = f(a.padding, 8);
				this.options = a;
				this.itemStyle = a.itemStyle;
				this.itemHiddenStyle = r(this.itemStyle, a.itemHiddenStyle);
				this.itemMarginTop = a.itemMarginTop || 0;
				this.initialItemX = this.padding = b;
				this.initialItemY = b - 5;
				this.itemHeight = this.maxItemWidth = 0;
				this.symbolWidth = f(a.symbolWidth, 16);
				this.pages = []
			},
			update: function(a, b) {
				var e =
					this.chart;
				this.setOptions(r(!0, this.options, a));
				this.destroy();
				e.isDirtyLegend = e.isDirtyBox = !0;
				f(b, !0) &amp;&amp; e.redraw()
			},
			colorizeItem: function(a, b) {
				a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
				var e = this.options,
					f = a.legendItem,
					k = a.legendLine,
					c = a.legendSymbol,
					d = this.itemHiddenStyle.color,
					e = b ? e.itemStyle.color : d,
					g = b ? a.color || d : d,
					n = a.options &amp;&amp; a.options.marker,
					l = {
						fill: g
					},
					t;
				f &amp;&amp; f.css({
					fill: e,
					color: e
				});
				k &amp;&amp; k.attr({
					stroke: g
				});
				if (c) {
					if (n &amp;&amp; c.isMarker &amp;&amp; (l = a.pointAttribs(), !b))
						for (t in l) l[t] =
							d;
					c.attr(l)
				}
			},
			positionItem: function(a) {
				var b = this.options,
					f = b.symbolPadding,
					b = !b.rtl,
					k = a._legendItemPos,
					d = k[0],
					k = k[1],
					c = a.checkbox;
				(a = a.legendGroup) &amp;&amp; a.element &amp;&amp; a.translate(b ? d : this.legendWidth - d - 2 * f - 4, k);
				c &amp;&amp; (c.x = d, c.y = k)
			},
			destroyItem: function(a) {
				var b = a.checkbox;
				d(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function(b) {
					a[b] &amp;&amp; (a[b] = a[b].destroy())
				});
				b &amp;&amp; H(a.checkbox)
			},
			destroy: function() {
				var a = this.group,
					b = this.box;
				b &amp;&amp; (this.box = b.destroy());
				d(this.getAllItems(), function(a) {
					d(["legendItem",
						"legendGroup"
					], function(b) {
						a[b] &amp;&amp; (a[b] = a[b].destroy())
					})
				});
				a &amp;&amp; (this.group = a.destroy());
				this.display = null
			},
			positionCheckboxes: function(a) {
				var b = this.group &amp;&amp; this.group.alignAttr,
					f, k = this.clipHeight || this.legendHeight,
					g = this.titleHeight;
				b &amp;&amp; (f = b.translateY, d(this.allItems, function(c) {
					var e = c.checkbox,
						h;
					e &amp;&amp; (h = f + g + e.y + (a || 0) + 3, F(e, {
						left: b.translateX + c.checkboxOffset + e.x - 20 + "px",
						top: h + "px",
						display: h &gt; f - 6 &amp;&amp; h &lt; f + k - 6 ? "" : "none"
					}))
				}))
			},
			renderTitle: function() {
				var a = this.padding,
					b = this.options.title,
					f = 0;
				b.text &amp;&amp;
					(this.title || (this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({
						zIndex: 1
					}).css(b.style).add(this.group)), a = this.title.getBBox(), f = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
						translateY: f
					}));
				this.titleHeight = f
			},
			setText: function(b) {
				var e = this.options;
				b.legendItem.attr({
					text: e.labelFormat ? a.format(e.labelFormat, b) : e.labelFormatter.call(b)
				})
			},
			renderItem: function(a) {
				var b = this.chart,
					h = b.renderer,
					k = this.options,
					d = "horizontal" === k.layout,
					c = this.symbolWidth,
					g = k.symbolPadding,
					n = this.itemStyle,
					l = this.itemHiddenStyle,
					t = this.padding,
					p = d ? f(k.itemDistance, 20) : 0,
					D = !k.rtl,
					G = k.width,
					L = k.itemMarginBottom || 0,
					w = this.itemMarginTop,
					m = this.initialItemX,
					z = a.legendItem,
					v = !a.series,
					P = !v &amp;&amp; a.series.drawLegendSymbol ? a.series : a,
					y = P.options,
					y = this.createCheckboxForItem &amp;&amp; y &amp;&amp; y.showCheckbox,
					B = k.useHTML;
				z || (a.legendGroup = h.g("legend-item").addClass("highcharts-" + P.type + "-series highcharts-color-" + a.colorIndex + (a.options.className ? " " + a.options.className : "") + (v ? " highcharts-series-" +
					a.index : "")).attr({
					zIndex: 1
				}).add(this.scrollGroup), a.legendItem = z = h.text("", D ? c + g : -g, this.baseline || 0, B).css(r(a.visible ? n : l)).attr({
					align: D ? "left" : "right",
					zIndex: 2
				}).add(a.legendGroup), this.baseline || (n = n.fontSize, this.fontMetrics = h.fontMetrics(n, z), this.baseline = this.fontMetrics.f + 3 + w, z.attr("y", this.baseline)), P.drawLegendSymbol(this, a), this.setItemEvents &amp;&amp; this.setItemEvents(a, z, B), y &amp;&amp; this.createCheckboxForItem(a));
				this.colorizeItem(a, a.visible);
				this.setText(a);
				h = z.getBBox();
				c = a.checkboxOffset =
					k.itemWidth || a.legendItemWidth || c + g + h.width + p + (y ? 20 : 0);
				this.itemHeight = g = Math.round(a.legendItemHeight || h.height);
				d &amp;&amp; this.itemX - m + c &gt; (G || b.chartWidth - 2 * t - m - k.x) &amp;&amp; (this.itemX = m, this.itemY += w + this.lastLineHeight + L, this.lastLineHeight = 0);
				this.maxItemWidth = Math.max(this.maxItemWidth, c);
				this.lastItemY = w + this.itemY + L;
				this.lastLineHeight = Math.max(g, this.lastLineHeight);
				a._legendItemPos = [this.itemX, this.itemY];
				d ? this.itemX += c : (this.itemY += w + g + L, this.lastLineHeight = g);
				this.offsetWidth = G || Math.max((d ? this.itemX -
					m - p : c) + t, this.offsetWidth)
			},
			getAllItems: function() {
				var a = [];
				d(this.chart.series, function(b) {
					var e = b &amp;&amp; b.options;
					b &amp;&amp; f(e.showInLegend, p(e.linkedTo) ? !1 : void 0, !0) &amp;&amp; (a = a.concat(b.legendItems || ("point" === e.legendType ? b.data : b)))
				});
				return a
			},
			adjustMargins: function(a, b) {
				var e = this.chart,
					k = this.options,
					g = k.align.charAt(0) + k.verticalAlign.charAt(0) + k.layout.charAt(0);
				k.floating || d([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function(c, d) {
					c.test(g) &amp;&amp; !p(a[d]) &amp;&amp; (e[l[d]] = Math.max(e[l[d]], e.legend[(d +
						1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][d] * k[d % 2 ? "x" : "y"] + f(k.margin, 12) + b[d]))
				})
			},
			render: function() {
				var a = this,
					b = a.chart,
					f = b.renderer,
					l = a.group,
					u, c, q, t, r = a.box,
					p = a.options,
					w = a.padding;
				a.itemX = a.initialItemX;
				a.itemY = a.initialItemY;
				a.offsetWidth = 0;
				a.lastItemY = 0;
				l || (a.group = l = f.g("legend").attr({
					zIndex: 7
				}).add(), a.contentGroup = f.g().attr({
					zIndex: 1
				}).add(l), a.scrollGroup = f.g().add(a.contentGroup));
				a.renderTitle();
				u = a.getAllItems();
				n(u, function(a, b) {
					return (a.options &amp;&amp; a.options.legendIndex || 0) -
						(b.options &amp;&amp; b.options.legendIndex || 0)
				});
				p.reversed &amp;&amp; u.reverse();
				a.allItems = u;
				a.display = c = !!u.length;
				a.lastLineHeight = 0;
				d(u, function(b) {
					a.renderItem(b)
				});
				q = (p.width || a.offsetWidth) + w;
				t = a.lastItemY + a.lastLineHeight + a.titleHeight;
				t = a.handleOverflow(t);
				t += w;
				r || (a.box = r = f.rect().addClass("highcharts-legend-box").attr({
					r: p.borderRadius
				}).add(l), r.isNew = !0);
				r.attr({
					stroke: p.borderColor,
					"stroke-width": p.borderWidth || 0,
					fill: p.backgroundColor || "none"
				}).shadow(p.shadow);
				0 &lt; q &amp;&amp; 0 &lt; t &amp;&amp; (r[r.isNew ? "attr" : "animate"](r.crisp({
					x: 0,
					y: 0,
					width: q,
					height: t
				}, r.strokeWidth())), r.isNew = !1);
				r[c ? "show" : "hide"]();
				a.legendWidth = q;
				a.legendHeight = t;
				d(u, function(b) {
					a.positionItem(b)
				});
				c &amp;&amp; l.align(g({
					width: q,
					height: t
				}, p), !0, "spacingBox");
				b.isResizing || this.positionCheckboxes()
			},
			handleOverflow: function(a) {
				var b = this,
					h = this.chart,
					k = h.renderer,
					g = this.options,
					c = g.y,
					h = h.spacingBox.height + ("top" === g.verticalAlign ? -c : c) - this.padding,
					c = g.maxHeight,
					n, l = this.clipRect,
					t = g.navigation,
					r = f(t.animation, !0),
					p = t.arrowSize || 12,
					D = this.nav,
					G = this.pages,
					L = this.padding,
					w, m = this.allItems,
					z = function(a) {
						a ? l.attr({
							height: a
						}) : l &amp;&amp; (b.clipRect = l.destroy(), b.contentGroup.clip());
						b.contentGroup.div &amp;&amp; (b.contentGroup.div.style.clip = a ? "rect(" + L + "px,9999px," + (L + a) + "px,0)" : "auto")
					};
				"horizontal" !== g.layout || "middle" === g.verticalAlign || g.floating || (h /= 2);
				c &amp;&amp; (h = Math.min(h, c));
				G.length = 0;
				a &gt; h &amp;&amp; !1 !== t.enabled ? (this.clipHeight = n = Math.max(h - 20 - this.titleHeight - L, 0), this.currentPage = f(this.currentPage, 1), this.fullHeight = a, d(m, function(a, b) {
						var c = a._legendItemPos[1];
						a = Math.round(a.legendItem.getBBox().height);
						var e = G.length;
						if (!e || c - G[e - 1] &gt; n &amp;&amp; (w || c) !== G[e - 1]) G.push(w || c), e++;
						b === m.length - 1 &amp;&amp; c + a - G[e - 1] &gt; n &amp;&amp; G.push(c);
						c !== w &amp;&amp; (w = c)
					}), l || (l = b.clipRect = k.clipRect(0, L, 9999, 0), b.contentGroup.clip(l)), z(n), D || (this.nav = D = k.g().attr({
						zIndex: 1
					}).add(this.group), this.up = k.symbol("triangle", 0, 0, p, p).on("click", function() {
						b.scroll(-1, r)
					}).add(D), this.pager = k.text("", 15, 10).addClass("highcharts-legend-navigation").css(t.style).add(D), this.down = k.symbol("triangle-down", 0, 0, p, p).on("click", function() {
						b.scroll(1, r)
					}).add(D)),
					b.scroll(0), a = h) : D &amp;&amp; (z(), D.hide(), this.scrollGroup.attr({
					translateY: 1
				}), this.clipHeight = 0);
				return a
			},
			scroll: function(a, e) {
				var f = this.pages,
					d = f.length;
				a = this.currentPage + a;
				var k = this.clipHeight,
					c = this.options.navigation,
					g = this.pager,
					n = this.padding;
				a &gt; d &amp;&amp; (a = d);
				0 &lt; a &amp;&amp; (void 0 !== e &amp;&amp; b(e, this.chart), this.nav.attr({
					translateX: n,
					translateY: k + this.padding + 7 + this.titleHeight,
					visibility: "visible"
				}), this.up.attr({
					"class": 1 === a ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
				}), g.attr({
					text: a + "/" +
						d
				}), this.down.attr({
					x: 18 + this.pager.getBBox().width,
					"class": a === d ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
				}), this.up.attr({
					fill: 1 === a ? c.inactiveColor : c.activeColor
				}).css({
					cursor: 1 === a ? "default" : "pointer"
				}), this.down.attr({
					fill: a === d ? c.inactiveColor : c.activeColor
				}).css({
					cursor: a === d ? "default" : "pointer"
				}), e = -f[a - 1] + this.initialItemY, this.scrollGroup.animate({
					translateY: e
				}), this.currentPage = a, this.positionCheckboxes(e))
			}
		};
		a.LegendSymbolMixin = {
			drawRectangle: function(a, b) {
				var e =
					a.options,
					d = e.symbolHeight || a.fontMetrics.f,
					e = e.squareSymbol;
				b.legendSymbol = this.chart.renderer.rect(e ? (a.symbolWidth - d) / 2 : 0, a.baseline - d + 1, e ? d : a.symbolWidth, d, f(a.options.symbolRadius, d / 2)).addClass("highcharts-point").attr({
					zIndex: 3
				}).add(b.legendGroup)
			},
			drawLineMarker: function(a) {
				var b = this.options,
					f = b.marker,
					d = a.symbolWidth,
					k = this.chart.renderer,
					c = this.legendGroup;
				a = a.baseline - Math.round(.3 * a.fontMetrics.b);
				var g;
				g = {
					"stroke-width": b.lineWidth || 0
				};
				b.dashStyle &amp;&amp; (g.dashstyle = b.dashStyle);
				this.legendLine =
					k.path(["M", 0, a, "L", d, a]).addClass("highcharts-graph").attr(g).add(c);
				f &amp;&amp; !1 !== f.enabled &amp;&amp; (b = 0 === this.symbol.indexOf("url") ? 0 : f.radius, this.legendSymbol = f = k.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b, f).addClass("highcharts-point").add(c), f.isMarker = !0)
			}
		};
		(/Trident\/7\.0/.test(w.navigator.userAgent) || v) &amp;&amp; t(E.prototype, "positionItem", function(a, b) {
			var e = this,
				f = function() {
					b._legendItemPos &amp;&amp; a.call(e, b)
				};
			f();
			setTimeout(f)
		})
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.animate,
			F = a.animObject,
			H = a.attr,
			p = a.doc,
			d = a.Axis,
			g = a.createElement,
			v = a.defaultOptions,
			l = a.discardElement,
			r = a.charts,
			f = a.css,
			b = a.defined,
			n = a.each,
			w = a.error,
			t = a.extend,
			k = a.fireEvent,
			e = a.getStyle,
			h = a.grep,
			C = a.isNumber,
			u = a.isObject,
			c = a.isString,
			q = a.Legend,
			x = a.marginNames,
			K = a.merge,
			I = a.Pointer,
			J = a.pick,
			D = a.pInt,
			G = a.removeEvent,
			L = a.seriesTypes,
			N = a.splat,
			m = a.svg,
			z = a.syncTimeout,
			O = a.win,
			P = a.Renderer,
			y = a.Chart = function() {
				this.getArgs.apply(this, arguments)
			};
		a.chart = function(a, b, c) {
			return new y(a, b, c)
		};
		y.prototype = {
			callbacks: [],
			getArgs: function() {
				var a = [].slice.call(arguments);
				if (c(a[0]) || a[0].nodeName) this.renderTo = a.shift();
				this.init(a[0], a[1])
			},
			init: function(b, c) {
				var e, f = b.series;
				b.series = null;
				e = K(v, b);
				e.series = b.series = f;
				this.userOptions = b;
				this.respRules = [];
				b = e.chart;
				f = b.events;
				this.margin = [];
				this.spacing = [];
				this.bounds = {
					h: {},
					v: {}
				};
				this.callback = c;
				this.isResizing = 0;
				this.options = e;
				this.axes = [];
				this.series = [];
				this.hasCartesianSeries = b.showAxes;
				var d;
				this.index = r.length;
				r.push(this);
				a.chartCount++;
				if (f)
					for (d in f) E(this, d, f[d]);
				this.xAxis = [];
				this.yAxis = [];
				this.pointCount =
					this.colorCounter = this.symbolCounter = 0;
				this.firstRender()
			},
			initSeries: function(a) {
				var b = this.options.chart;
				(b = L[a.type || b.type || b.defaultSeriesType]) || w(17, !0);
				b = new b;
				b.init(this, a);
				return b
			},
			isInsidePlot: function(a, b, c) {
				var e = c ? b : a;
				a = c ? a : b;
				return 0 &lt;= e &amp;&amp; e &lt;= this.plotWidth &amp;&amp; 0 &lt;= a &amp;&amp; a &lt;= this.plotHeight
			},
			redraw: function(b) {
				var c = this.axes,
					e = this.series,
					f = this.pointer,
					d = this.legend,
					m = this.isDirtyLegend,
					h, g, q = this.hasCartesianSeries,
					l = this.isDirtyBox,
					D = e.length,
					u = D,
					B = this.renderer,
					r = B.isHidden(),
					G = [];
				a.setAnimation(b,
					this);
				r &amp;&amp; this.cloneRenderTo();
				for (this.layOutTitles(); u--;)
					if (b = e[u], b.options.stacking &amp;&amp; (h = !0, b.isDirty)) {
						g = !0;
						break
					}
				if (g)
					for (u = D; u--;) b = e[u], b.options.stacking &amp;&amp; (b.isDirty = !0);
				n(e, function(a) {
					a.isDirty &amp;&amp; "point" === a.options.legendType &amp;&amp; (a.updateTotals &amp;&amp; a.updateTotals(), m = !0);
					a.isDirtyData &amp;&amp; k(a, "updatedData")
				});
				m &amp;&amp; d.options.enabled &amp;&amp; (d.render(), this.isDirtyLegend = !1);
				h &amp;&amp; this.getStacks();
				q &amp;&amp; n(c, function(a) {
					a.updateNames();
					a.setScale()
				});
				this.getMargins();
				q &amp;&amp; (n(c, function(a) {
					a.isDirty &amp;&amp; (l = !0)
				}), n(c,
					function(a) {
						var b = a.min + "," + a.max;
						a.extKey !== b &amp;&amp; (a.extKey = b, G.push(function() {
							k(a, "afterSetExtremes", t(a.eventArgs, a.getExtremes()));
							delete a.eventArgs
						}));
						(l || h) &amp;&amp; a.redraw()
					}));
				l &amp;&amp; this.drawChartBox();
				n(e, function(a) {
					(l || a.isDirty) &amp;&amp; a.visible &amp;&amp; a.redraw()
				});
				f &amp;&amp; f.reset(!0);
				B.draw();
				k(this, "redraw");
				r &amp;&amp; this.cloneRenderTo(!0);
				n(G, function(a) {
					a.call()
				})
			},
			get: function(a) {
				var b = this.axes,
					c = this.series,
					e, f;
				for (e = 0; e &lt; b.length; e++)
					if (b[e].options.id === a) return b[e];
				for (e = 0; e &lt; c.length; e++)
					if (c[e].options.id ===
						a) return c[e];
				for (e = 0; e &lt; c.length; e++)
					for (f = c[e].points || [], b = 0; b &lt; f.length; b++)
						if (f[b].id === a) return f[b];
				return null
			},
			getAxes: function() {
				var a = this,
					b = this.options,
					c = b.xAxis = N(b.xAxis || {}),
					b = b.yAxis = N(b.yAxis || {});
				n(c, function(a, b) {
					a.index = b;
					a.isX = !0
				});
				n(b, function(a, b) {
					a.index = b
				});
				c = c.concat(b);
				n(c, function(b) {
					new d(a, b)
				})
			},
			getSelectedPoints: function() {
				var a = [];
				n(this.series, function(b) {
					a = a.concat(h(b.points || [], function(a) {
						return a.selected
					}))
				});
				return a
			},
			getSelectedSeries: function() {
				return h(this.series,
					function(a) {
						return a.selected
					})
			},
			setTitle: function(a, b, c) {
				var e = this,
					f = e.options,
					d;
				d = f.title = K({
					style: {
						color: "#333333",
						fontSize: f.isStock ? "16px" : "18px"
					}
				}, f.title, a);
				f = f.subtitle = K({
					style: {
						color: "#666666"
					}
				}, f.subtitle, b);
				n([
					["title", a, d],
					["subtitle", b, f]
				], function(a, b) {
					var c = a[0],
						f = e[c],
						d = a[1];
					a = a[2];
					f &amp;&amp; d &amp;&amp; (e[c] = f = f.destroy());
					a &amp;&amp; a.text &amp;&amp; !f &amp;&amp; (e[c] = e.renderer.text(a.text, 0, 0, a.useHTML).attr({
						align: a.align,
						"class": "highcharts-" + c,
						zIndex: a.zIndex || 4
					}).add(), e[c].update = function(a) {
						e.setTitle(!b &amp;&amp; a, b &amp;&amp;
							a)
					}, e[c].css(a.style))
				});
				e.layOutTitles(c)
			},
			layOutTitles: function(a) {
				var b = 0,
					c, e = this.renderer,
					f = this.spacingBox;
				n(["title", "subtitle"], function(a) {
					var c = this[a],
						d = this.options[a],
						m;
					c &amp;&amp; (m = d.style.fontSize, m = e.fontMetrics(m, c).b, c.css({
						width: (d.width || f.width + d.widthAdjust) + "px"
					}).align(t({
						y: b + m + ("title" === a ? -3 : 2)
					}, d), !1, "spacingBox"), d.floating || d.verticalAlign || (b = Math.ceil(b + c.getBBox().height)))
				}, this);
				c = this.titleOffset !== b;
				this.titleOffset = b;
				!this.isDirtyBox &amp;&amp; c &amp;&amp; (this.isDirtyBox = c, this.hasRendered &amp;&amp;
					J(a, !0) &amp;&amp; this.isDirtyBox &amp;&amp; this.redraw())
			},
			getChartSize: function() {
				var a = this.options.chart,
					c = a.width,
					a = a.height,
					f = this.renderToClone || this.renderTo;
				b(c) || (this.containerWidth = e(f, "width"));
				b(a) || (this.containerHeight = e(f, "height"));
				this.chartWidth = Math.max(0, c || this.containerWidth || 600);
				this.chartHeight = Math.max(0, J(a, 19 &lt; this.containerHeight ? this.containerHeight : 400))
			},
			cloneRenderTo: function(a) {
				var b = this.renderToClone,
					c = this.container;
				if (a) {
					if (b) {
						for (; b.childNodes.length;) this.renderTo.appendChild(b.firstChild);
						l(b);
						delete this.renderToClone
					}
				} else c &amp;&amp; c.parentNode === this.renderTo &amp;&amp; this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), f(b, {
					position: "absolute",
					top: "-9999px",
					display: "block"
				}), b.style.setProperty &amp;&amp; b.style.setProperty("display", "block", "important"), p.body.appendChild(b), c &amp;&amp; b.appendChild(c)
			},
			setClassName: function(a) {
				this.container.className = "highcharts-container " + (a || "")
			},
			getContainer: function() {
				var b, e = this.options,
					f = e.chart,
					d, m;
				b = this.renderTo;
				var h = a.uniqueKey(),
					k;
				b ||
					(this.renderTo = b = f.renderTo);
				c(b) &amp;&amp; (this.renderTo = b = p.getElementById(b));
				b || w(13, !0);
				d = D(H(b, "data-highcharts-chart"));
				C(d) &amp;&amp; r[d] &amp;&amp; r[d].hasRendered &amp;&amp; r[d].destroy();
				H(b, "data-highcharts-chart", this.index);
				b.innerHTML = "";
				f.skipClone || b.offsetWidth || this.cloneRenderTo();
				this.getChartSize();
				d = this.chartWidth;
				m = this.chartHeight;
				k = t({
					position: "relative",
					overflow: "hidden",
					width: d + "px",
					height: m + "px",
					textAlign: "left",
					lineHeight: "normal",
					zIndex: 0,
					"-webkit-tap-highlight-color": "rgba(0,0,0,0)"
				}, f.style);
				this.container =
					b = g("div", {
						id: h
					}, k, this.renderToClone || b);
				this._cursor = b.style.cursor;
				this.renderer = new(a[f.renderer] || P)(b, d, m, null, f.forExport, e.exporting &amp;&amp; e.exporting.allowHTML);
				this.setClassName(f.className);
				this.renderer.setStyle(f.style);
				this.renderer.chartIndex = this.index
			},
			getMargins: function(a) {
				var c = this.spacing,
					e = this.margin,
					f = this.titleOffset;
				this.resetMargins();
				f &amp;&amp; !b(e[0]) &amp;&amp; (this.plotTop = Math.max(this.plotTop, f + this.options.title.margin + c[0]));
				this.legend.display &amp;&amp; this.legend.adjustMargins(e, c);
				this.extraBottomMargin &amp;&amp;
					(this.marginBottom += this.extraBottomMargin);
				this.extraTopMargin &amp;&amp; (this.plotTop += this.extraTopMargin);
				a || this.getAxisMargins()
			},
			getAxisMargins: function() {
				var a = this,
					c = a.axisOffset = [0, 0, 0, 0],
					e = a.margin;
				a.hasCartesianSeries &amp;&amp; n(a.axes, function(a) {
					a.visible &amp;&amp; a.getOffset()
				});
				n(x, function(f, d) {
					b(e[d]) || (a[f] += c[d])
				});
				a.setChartSize()
			},
			reflow: function(a) {
				var c = this,
					f = c.options.chart,
					d = c.renderTo,
					m = b(f.width),
					h = f.width || e(d, "width"),
					f = f.height || e(d, "height"),
					d = a ? a.target : O;
				if (!m &amp;&amp; !c.isPrinting &amp;&amp; h &amp;&amp; f &amp;&amp; (d ===
						O || d === p)) {
					if (h !== c.containerWidth || f !== c.containerHeight) clearTimeout(c.reflowTimeout), c.reflowTimeout = z(function() {
						c.container &amp;&amp; c.setSize(void 0, void 0, !1)
					}, a ? 100 : 0);
					c.containerWidth = h;
					c.containerHeight = f
				}
			},
			initReflow: function() {
				var a = this,
					b;
				b = E(O, "resize", function(b) {
					a.reflow(b)
				});
				E(a, "destroy", b)
			},
			setSize: function(b, c, e) {
				var d = this,
					m = d.renderer;
				d.isResizing += 1;
				a.setAnimation(e, d);
				d.oldChartHeight = d.chartHeight;
				d.oldChartWidth = d.chartWidth;
				void 0 !== b &amp;&amp; (d.options.chart.width = b);
				void 0 !== c &amp;&amp; (d.options.chart.height =
					c);
				d.getChartSize();
				b = m.globalAnimation;
				(b ? A : f)(d.container, {
					width: d.chartWidth + "px",
					height: d.chartHeight + "px"
				}, b);
				d.setChartSize(!0);
				m.setSize(d.chartWidth, d.chartHeight, e);
				n(d.axes, function(a) {
					a.isDirty = !0;
					a.setScale()
				});
				d.isDirtyLegend = !0;
				d.isDirtyBox = !0;
				d.layOutTitles();
				d.getMargins();
				d.setResponsive &amp;&amp; d.setResponsive(!1);
				d.redraw(e);
				d.oldChartHeight = null;
				k(d, "resize");
				z(function() {
					d &amp;&amp; k(d, "endResize", null, function() {
						--d.isResizing
					})
				}, F(b).duration)
			},
			setChartSize: function(a) {
				var b = this.inverted,
					c = this.renderer,
					e = this.chartWidth,
					f = this.chartHeight,
					d = this.options.chart,
					m = this.spacing,
					h = this.clipOffset,
					k, g, q, l;
				this.plotLeft = k = Math.round(this.plotLeft);
				this.plotTop = g = Math.round(this.plotTop);
				this.plotWidth = q = Math.max(0, Math.round(e - k - this.marginRight));
				this.plotHeight = l = Math.max(0, Math.round(f - g - this.marginBottom));
				this.plotSizeX = b ? l : q;
				this.plotSizeY = b ? q : l;
				this.plotBorderWidth = d.plotBorderWidth || 0;
				this.spacingBox = c.spacingBox = {
					x: m[3],
					y: m[0],
					width: e - m[3] - m[1],
					height: f - m[0] - m[2]
				};
				this.plotBox =
					c.plotBox = {
						x: k,
						y: g,
						width: q,
						height: l
					};
				e = 2 * Math.floor(this.plotBorderWidth / 2);
				b = Math.ceil(Math.max(e, h[3]) / 2);
				c = Math.ceil(Math.max(e, h[0]) / 2);
				this.clipBox = {
					x: b,
					y: c,
					width: Math.floor(this.plotSizeX - Math.max(e, h[1]) / 2 - b),
					height: Math.max(0, Math.floor(this.plotSizeY - Math.max(e, h[2]) / 2 - c))
				};
				a || n(this.axes, function(a) {
					a.setAxisSize();
					a.setAxisTranslation()
				})
			},
			resetMargins: function() {
				var a = this,
					b = a.options.chart;
				n(["margin", "spacing"], function(c) {
					var e = b[c],
						f = u(e) ? e : [e, e, e, e];
					n(["Top", "Right", "Bottom", "Left"],
						function(e, d) {
							a[c][d] = J(b[c + e], f[d])
						})
				});
				n(x, function(b, c) {
					a[b] = J(a.margin[c], a.spacing[c])
				});
				a.axisOffset = [0, 0, 0, 0];
				a.clipOffset = [0, 0, 0, 0]
			},
			drawChartBox: function() {
				var a = this.options.chart,
					b = this.renderer,
					c = this.chartWidth,
					e = this.chartHeight,
					f = this.chartBackground,
					d = this.plotBackground,
					m = this.plotBorder,
					h, k = this.plotBGImage,
					g = a.backgroundColor,
					n = a.plotBackgroundColor,
					q = a.plotBackgroundImage,
					l, D = this.plotLeft,
					u = this.plotTop,
					t = this.plotWidth,
					r = this.plotHeight,
					G = this.plotBox,
					p = this.clipRect,
					x = this.clipBox,
					z = "animate";
				f || (this.chartBackground = f = b.rect().addClass("highcharts-background").add(), z = "attr");
				h = a.borderWidth || 0;
				l = h + (a.shadow ? 8 : 0);
				g = {
					fill: g || "none"
				};
				if (h || f["stroke-width"]) g.stroke = a.borderColor, g["stroke-width"] = h;
				f.attr(g).shadow(a.shadow);
				f[z]({
					x: l / 2,
					y: l / 2,
					width: c - l - h % 2,
					height: e - l - h % 2,
					r: a.borderRadius
				});
				z = "animate";
				d || (z = "attr", this.plotBackground = d = b.rect().addClass("highcharts-plot-background").add());
				d[z](G);
				d.attr({
					fill: n || "none"
				}).shadow(a.plotShadow);
				q &amp;&amp; (k ? k.animate(G) : this.plotBGImage =
					b.image(q, D, u, t, r).add());
				p ? p.animate({
					width: x.width,
					height: x.height
				}) : this.clipRect = b.clipRect(x);
				z = "animate";
				m || (z = "attr", this.plotBorder = m = b.rect().addClass("highcharts-plot-border").attr({
					zIndex: 1
				}).add());
				m.attr({
					stroke: a.plotBorderColor,
					"stroke-width": a.plotBorderWidth || 0,
					fill: "none"
				});
				m[z](m.crisp({
					x: D,
					y: u,
					width: t,
					height: r
				}, -m.strokeWidth()));
				this.isDirtyBox = !1
			},
			propFromSeries: function() {
				var a = this,
					b = a.options.chart,
					c, e = a.options.series,
					f, d;
				n(["inverted", "angular", "polar"], function(m) {
					c = L[b.type ||
						b.defaultSeriesType];
					d = b[m] || c &amp;&amp; c.prototype[m];
					for (f = e &amp;&amp; e.length; !d &amp;&amp; f--;)(c = L[e[f].type]) &amp;&amp; c.prototype[m] &amp;&amp; (d = !0);
					a[m] = d
				})
			},
			linkSeries: function() {
				var a = this,
					b = a.series;
				n(b, function(a) {
					a.linkedSeries.length = 0
				});
				n(b, function(b) {
					var e = b.options.linkedTo;
					c(e) &amp;&amp; (e = ":previous" === e ? a.series[b.index - 1] : a.get(e)) &amp;&amp; e.linkedParent !== b &amp;&amp; (e.linkedSeries.push(b), b.linkedParent = e, b.visible = J(b.options.visible, e.options.visible, b.visible))
				})
			},
			renderSeries: function() {
				n(this.series, function(a) {
					a.translate();
					a.render()
				})
			},
			renderLabels: function() {
				var a = this,
					b = a.options.labels;
				b.items &amp;&amp; n(b.items, function(c) {
					var e = t(b.style, c.style),
						f = D(e.left) + a.plotLeft,
						d = D(e.top) + a.plotTop + 12;
					delete e.left;
					delete e.top;
					a.renderer.text(c.html, f, d).attr({
						zIndex: 2
					}).css(e).add()
				})
			},
			render: function() {
				var a = this.axes,
					b = this.renderer,
					c = this.options,
					e, f, d;
				this.setTitle();
				this.legend = new q(this, c.legend);
				this.getStacks &amp;&amp; this.getStacks();
				this.getMargins(!0);
				this.setChartSize();
				c = this.plotWidth;
				e = this.plotHeight -= 21;
				n(a, function(a) {
					a.setScale()
				});
				this.getAxisMargins();
				f = 1.1 &lt; c / this.plotWidth;
				d = 1.05 &lt; e / this.plotHeight;
				if (f || d) n(a, function(a) {
					(a.horiz &amp;&amp; f || !a.horiz &amp;&amp; d) &amp;&amp; a.setTickInterval(!0)
				}), this.getMargins();
				this.drawChartBox();
				this.hasCartesianSeries &amp;&amp; n(a, function(a) {
					a.visible &amp;&amp; a.render()
				});
				this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({
					zIndex: 3
				}).add());
				this.renderSeries();
				this.renderLabels();
				this.addCredits();
				this.setResponsive &amp;&amp; this.setResponsive();
				this.hasRendered = !0
			},
			addCredits: function(a) {
				var b = this;
				a = K(!0, this.options.credits,
					a);
				a.enabled &amp;&amp; !this.credits &amp;&amp; (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
					a.href &amp;&amp; (O.location.href = a.href)
				}).attr({
					align: a.position.align,
					zIndex: 8
				}).css(a.style).add().align(a.position), this.credits.update = function(a) {
					b.credits = b.credits.destroy();
					b.addCredits(a)
				})
			},
			destroy: function() {
				var b = this,
					c = b.axes,
					e = b.series,
					f = b.container,
					d, m = f &amp;&amp; f.parentNode;
				k(b, "destroy");
				r[b.index] = void 0;
				a.chartCount--;
				b.renderTo.removeAttribute("data-highcharts-chart");
				G(b);
				for (d = c.length; d--;) c[d] = c[d].destroy();
				this.scroller &amp;&amp; this.scroller.destroy &amp;&amp; this.scroller.destroy();
				for (d = e.length; d--;) e[d] = e[d].destroy();
				n("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "), function(a) {
					var c = b[a];
					c &amp;&amp; c.destroy &amp;&amp; (b[a] = c.destroy())
				});
				f &amp;&amp; (f.innerHTML = "", G(f), m &amp;&amp; l(f));
				for (d in b) delete b[d]
			},
			isReadyToRender: function() {
				var a = this;
				return m || O != O.top || "complete" ===
					p.readyState ? !0 : (p.attachEvent("onreadystatechange", function() {
						p.detachEvent("onreadystatechange", a.firstRender);
						"complete" === p.readyState &amp;&amp; a.firstRender()
					}), !1)
			},
			firstRender: function() {
				var a = this,
					b = a.options;
				if (a.isReadyToRender()) {
					a.getContainer();
					k(a, "init");
					a.resetMargins();
					a.setChartSize();
					a.propFromSeries();
					a.getAxes();
					n(b.series || [], function(b) {
						a.initSeries(b)
					});
					a.linkSeries();
					k(a, "beforeRender");
					I &amp;&amp; (a.pointer = new I(a, b));
					a.render();
					a.renderer.draw();
					if (!a.renderer.imgCount &amp;&amp; a.onload) a.onload();
					a.cloneRenderTo(!0)
				}
			},
			onload: function() {
				n([this.callback].concat(this.callbacks), function(a) {
					a &amp;&amp; void 0 !== this.index &amp;&amp; a.apply(this, [this])
				}, this);
				k(this, "load");
				!1 !== this.options.chart.reflow &amp;&amp; this.initReflow();
				this.onload = null
			}
		}
	})(M);
	(function(a) {
		var E, A = a.each,
			F = a.extend,
			H = a.erase,
			p = a.fireEvent,
			d = a.format,
			g = a.isArray,
			v = a.isNumber,
			l = a.pick,
			r = a.removeEvent;
		E = a.Point = function() {};
		E.prototype = {
			init: function(a, b, d) {
				this.series = a;
				this.color = a.color;
				this.applyOptions(b, d);
				a.options.colorByPoint ? (b = a.options.colors ||
					a.chart.options.colors, this.color = this.color || b[a.colorCounter], b = b.length, d = a.colorCounter, a.colorCounter++, a.colorCounter === b &amp;&amp; (a.colorCounter = 0)) : d = a.colorIndex;
				this.colorIndex = l(this.colorIndex, d);
				a.chart.pointCount++;
				return this
			},
			applyOptions: function(a, b) {
				var f = this.series,
					d = f.options.pointValKey || f.pointValKey;
				a = E.prototype.optionsToObject.call(this, a);
				F(this, a);
				this.options = this.options ? F(this.options, a) : a;
				a.group &amp;&amp; delete this.group;
				d &amp;&amp; (this.y = this[d]);
				this.isNull = l(this.isValid &amp;&amp; !this.isValid(),
					null === this.x || !v(this.y, !0));
				this.selected &amp;&amp; (this.state = "select");
				"name" in this &amp;&amp; void 0 === b &amp;&amp; f.xAxis &amp;&amp; f.xAxis.hasNames &amp;&amp; (this.x = f.xAxis.nameToX(this));
				void 0 === this.x &amp;&amp; f &amp;&amp; (this.x = void 0 === b ? f.autoIncrement(this) : b);
				return this
			},
			optionsToObject: function(a) {
				var b = {},
					f = this.series,
					d = f.options.keys,
					l = d || f.pointArrayMap || ["y"],
					k = l.length,
					e = 0,
					h = 0;
				if (v(a) || null === a) b[l[0]] = a;
				else if (g(a))
					for (!d &amp;&amp; a.length &gt; k &amp;&amp; (f = typeof a[0], "string" === f ? b.name = a[0] : "number" === f &amp;&amp; (b.x = a[0]), e++); h &lt; k;) d &amp;&amp; void 0 === a[e] || (b[l[h]] =
						a[e]), e++, h++;
				else "object" === typeof a &amp;&amp; (b = a, a.dataLabels &amp;&amp; (f._hasPointLabels = !0), a.marker &amp;&amp; (f._hasPointMarkers = !0));
				return b
			},
			getClassName: function() {
				return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "")
			},
			getZone: function() {
				var a = this.series,
					b = a.zones,
					a = a.zoneAxis || "y",
					d = 0,
					g;
				for (g =
					b[d]; this[a] &gt;= g.value;) g = b[++d];
				g &amp;&amp; g.color &amp;&amp; !this.options.color &amp;&amp; (this.color = g.color);
				return g
			},
			destroy: function() {
				var a = this.series.chart,
					b = a.hoverPoints,
					d;
				a.pointCount--;
				b &amp;&amp; (this.setState(), H(b, this), b.length || (a.hoverPoints = null));
				if (this === a.hoverPoint) this.onMouseOut();
				if (this.graphic || this.dataLabel) r(this), this.destroyElements();
				this.legendItem &amp;&amp; a.legend.destroyItem(this);
				for (d in this) this[d] = null
			},
			destroyElements: function() {
				for (var a = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"],
						b, d = 6; d--;) b = a[d], this[b] &amp;&amp; (this[b] = this[b].destroy())
			},
			getLabelConfig: function() {
				return {
					x: this.category,
					y: this.y,
					color: this.color,
					key: this.name || this.category,
					series: this.series,
					point: this,
					percentage: this.percentage,
					total: this.total || this.stackTotal
				}
			},
			tooltipFormatter: function(a) {
				var b = this.series,
					f = b.tooltipOptions,
					g = l(f.valueDecimals, ""),
					t = f.valuePrefix || "",
					k = f.valueSuffix || "";
				A(b.pointArrayMap || ["y"], function(b) {
					b = "{point." + b;
					if (t || k) a = a.replace(b + "}", t + b + "}" + k);
					a = a.replace(b + "}", b + ":,." + g + "f}")
				});
				return d(a, {
					point: this,
					series: this.series
				})
			},
			firePointEvent: function(a, b, d) {
				var f = this,
					g = this.series.options;
				(g.point.events[a] || f.options &amp;&amp; f.options.events &amp;&amp; f.options.events[a]) &amp;&amp; this.importEvents();
				"click" === a &amp;&amp; g.allowPointSelect &amp;&amp; (d = function(a) {
					f.select &amp;&amp; f.select(null, a.ctrlKey || a.metaKey || a.shiftKey)
				});
				p(this, a, b, d)
			},
			visible: !0
		}
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.animObject,
			F = a.arrayMax,
			H = a.arrayMin,
			p = a.correctFloat,
			d = a.Date,
			g = a.defaultOptions,
			v = a.defaultPlotOptions,
			l = a.defined,
			r = a.each,
			f =
			a.erase,
			b = a.error,
			n = a.extend,
			w = a.fireEvent,
			t = a.grep,
			k = a.isArray,
			e = a.isNumber,
			h = a.isString,
			C = a.merge,
			u = a.pick,
			c = a.removeEvent,
			q = a.splat,
			x = a.stableSort,
			K = a.SVGElement,
			I = a.syncTimeout,
			J = a.win;
		a.Series = a.seriesType("line", null, {
			lineWidth: 2,
			allowPointSelect: !1,
			showCheckbox: !1,
			animation: {
				duration: 1E3
			},
			events: {},
			marker: {
				lineWidth: 0,
				lineColor: "#ffffff",
				radius: 4,
				states: {
					hover: {
						animation: {
							duration: 50
						},
						enabled: !0,
						radiusPlus: 2,
						lineWidthPlus: 1
					},
					select: {
						fillColor: "#cccccc",
						lineColor: "#000000",
						lineWidth: 2
					}
				}
			},
			point: {
				events: {}
			},
			dataLabels: {
				align: "center",
				formatter: function() {
					return null === this.y ? "" : a.numberFormat(this.y, -1)
				},
				style: {
					fontSize: "11px",
					fontWeight: "bold",
					color: "contrast",
					textOutline: "1px contrast"
				},
				verticalAlign: "bottom",
				x: 0,
				y: 0,
				padding: 5
			},
			cropThreshold: 300,
			pointRange: 0,
			softThreshold: !0,
			states: {
				hover: {
					lineWidthPlus: 1,
					marker: {},
					halo: {
						size: 10,
						opacity: .25
					}
				},
				select: {
					marker: {}
				}
			},
			stickyTracking: !0,
			turboThreshold: 1E3
		}, {
			isCartesian: !0,
			pointClass: a.Point,
			sorted: !0,
			requireSorting: !0,
			directTouch: !1,
			axisTypes: ["xAxis", "yAxis"],
			colorCounter: 0,
			parallelArrays: ["x", "y"],
			coll: "series",
			init: function(a, b) {
				var c = this,
					e, f, d = a.series,
					h, k = function(a, b) {
						return u(a.options.index, a._i) - u(b.options.index, b._i)
					};
				c.chart = a;
				c.options = b = c.setOptions(b);
				c.linkedSeries = [];
				c.bindAxes();
				n(c, {
					name: b.name,
					state: "",
					visible: !1 !== b.visible,
					selected: !0 === b.selected
				});
				f = b.events;
				for (e in f) E(c, e, f[e]);
				if (f &amp;&amp; f.click || b.point &amp;&amp; b.point.events &amp;&amp; b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;
				c.getColor();
				c.getSymbol();
				r(c.parallelArrays, function(a) {
					c[a +
						"Data"] = []
				});
				c.setData(b.data, !1);
				c.isCartesian &amp;&amp; (a.hasCartesianSeries = !0);
				d.length &amp;&amp; (h = d[d.length - 1]);
				c._i = u(h &amp;&amp; h._i, -1) + 1;
				d.push(c);
				x(d, k);
				this.yAxis &amp;&amp; x(this.yAxis.series, k);
				r(d, function(a, b) {
					a.index = b;
					a.name = a.name || "Series " + (b + 1)
				})
			},
			bindAxes: function() {
				var a = this,
					c = a.options,
					e = a.chart,
					f;
				r(a.axisTypes || [], function(d) {
					r(e[d], function(b) {
						f = b.options;
						if (c[d] === f.index || void 0 !== c[d] &amp;&amp; c[d] === f.id || void 0 === c[d] &amp;&amp; 0 === f.index) b.series.push(a), a[d] = b, b.isDirty = !0
					});
					a[d] || a.optionalAxis === d || b(18, !0)
				})
			},
			updateParallelArrays: function(a, b) {
				var c = a.series,
					f = arguments,
					d = e(b) ? function(e) {
						var f = "y" === e &amp;&amp; c.toYData ? c.toYData(a) : a[e];
						c[e + "Data"][b] = f
					} : function(a) {
						Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(f, 2))
					};
				r(c.parallelArrays, d)
			},
			autoIncrement: function() {
				var a = this.options,
					b = this.xIncrement,
					c, e = a.pointIntervalUnit,
					b = u(b, a.pointStart, 0);
				this.pointInterval = c = u(this.pointInterval, a.pointInterval, 1);
				e &amp;&amp; (a = new d(b), "day" === e ? a = +a[d.hcSetDate](a[d.hcGetDate]() + c) : "month" === e ? a = +a[d.hcSetMonth](a[d.hcGetMonth]() +
					c) : "year" === e &amp;&amp; (a = +a[d.hcSetFullYear](a[d.hcGetFullYear]() + c)), c = a - b);
				this.xIncrement = b + c;
				return b
			},
			setOptions: function(a) {
				var b = this.chart,
					c = b.options.plotOptions,
					b = b.userOptions || {},
					e = b.plotOptions || {},
					f = c[this.type];
				this.userOptions = a;
				c = C(f, c.series, a);
				this.tooltipOptions = C(g.tooltip, g.plotOptions[this.type].tooltip, b.tooltip, e.series &amp;&amp; e.series.tooltip, e[this.type] &amp;&amp; e[this.type].tooltip, a.tooltip);
				null === f.marker &amp;&amp; delete c.marker;
				this.zoneAxis = c.zoneAxis;
				a = this.zones = (c.zones || []).slice();
				!c.negativeColor &amp;&amp;
					!c.negativeFillColor || c.zones || a.push({
						value: c[this.zoneAxis + "Threshold"] || c.threshold || 0,
						className: "highcharts-negative",
						color: c.negativeColor,
						fillColor: c.negativeFillColor
					});
				a.length &amp;&amp; l(a[a.length - 1].value) &amp;&amp; a.push({
					color: this.color,
					fillColor: this.fillColor
				});
				return c
			},
			getCyclic: function(a, b, c) {
				var e, f = this.userOptions,
					d = a + "Index",
					h = a + "Counter",
					k = c ? c.length : u(this.chart.options.chart[a + "Count"], this.chart[a + "Count"]);
				b || (e = u(f[d], f["_" + d]), l(e) || (f["_" + d] = e = this.chart[h] % k, this.chart[h] += 1), c &amp;&amp;
					(b = c[e]));
				void 0 !== e &amp;&amp; (this[d] = e);
				this[a] = b
			},
			getColor: function() {
				this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || v[this.type].color, this.chart.options.colors)
			},
			getSymbol: function() {
				this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols)
			},
			drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,
			setData: function(a, c, f, d) {
				var m = this,
					g = m.points,
					n = g &amp;&amp; g.length || 0,
					q, l = m.options,
					t = m.chart,
					D = null,
					p = m.xAxis,
					x = l.turboThreshold,
					G = this.xData,
					w = this.yData,
					v = (q = m.pointArrayMap) &amp;&amp; q.length;
				a = a || [];
				q = a.length;
				c = u(c, !0);
				if (!1 !== d &amp;&amp; q &amp;&amp; n === q &amp;&amp; !m.cropped &amp;&amp; !m.hasGroupedData &amp;&amp; m.visible) r(a, function(a, b) {
					g[b].update &amp;&amp; a !== l.data[b] &amp;&amp; g[b].update(a, !1, null, !1)
				});
				else {
					m.xIncrement = null;
					m.colorCounter = 0;
					r(this.parallelArrays, function(a) {
						m[a + "Data"].length = 0
					});
					if (x &amp;&amp; q &gt; x) {
						for (f = 0; null === D &amp;&amp; f &lt; q;) D = a[f], f++;
						if (e(D))
							for (f = 0; f &lt; q; f++) G[f] = this.autoIncrement(), w[f] = a[f];
						else if (k(D))
							if (v)
								for (f = 0; f &lt; q; f++) D = a[f], G[f] = D[0], w[f] = D.slice(1, v + 1);
							else
								for (f = 0; f &lt; q; f++) D = a[f], G[f] =
									D[0], w[f] = D[1];
						else b(12)
					} else
						for (f = 0; f &lt; q; f++) void 0 !== a[f] &amp;&amp; (D = {
							series: m
						}, m.pointClass.prototype.applyOptions.apply(D, [a[f]]), m.updateParallelArrays(D, f));
					h(w[0]) &amp;&amp; b(14, !0);
					m.data = [];
					m.options.data = m.userOptions.data = a;
					for (f = n; f--;) g[f] &amp;&amp; g[f].destroy &amp;&amp; g[f].destroy();
					p &amp;&amp; (p.minRange = p.userMinRange);
					m.isDirty = t.isDirtyBox = !0;
					m.isDirtyData = !!g;
					f = !1
				}
				"point" === l.legendType &amp;&amp; (this.processData(), this.generatePoints());
				c &amp;&amp; t.redraw(f)
			},
			processData: function(a) {
				var c = this.xData,
					e = this.yData,
					f = c.length,
					d;
				d =
					0;
				var h, k, g = this.xAxis,
					q, n = this.options;
				q = n.cropThreshold;
				var l = this.getExtremesFromAll || n.getExtremesFromAll,
					u = this.isCartesian,
					n = g &amp;&amp; g.val2lin,
					t = g &amp;&amp; g.isLog,
					r, D;
				if (u &amp;&amp; !this.isDirty &amp;&amp; !g.isDirty &amp;&amp; !this.yAxis.isDirty &amp;&amp; !a) return !1;
				g &amp;&amp; (a = g.getExtremes(), r = a.min, D = a.max);
				if (u &amp;&amp; this.sorted &amp;&amp; !l &amp;&amp; (!q || f &gt; q || this.forceCrop))
					if (c[f - 1] &lt; r || c[0] &gt; D) c = [], e = [];
					else if (c[0] &lt; r || c[f - 1] &gt; D) d = this.cropData(this.xData, this.yData, r, D), c = d.xData, e = d.yData, d = d.start, h = !0;
				for (q = c.length || 1; --q;) f = t ? n(c[q]) - n(c[q - 1]) : c[q] - c[q -
					1], 0 &lt; f &amp;&amp; (void 0 === k || f &lt; k) ? k = f : 0 &gt; f &amp;&amp; this.requireSorting &amp;&amp; b(15);
				this.cropped = h;
				this.cropStart = d;
				this.processedXData = c;
				this.processedYData = e;
				this.closestPointRange = k
			},
			cropData: function(a, b, c, e) {
				var f = a.length,
					d = 0,
					h = f,
					k = u(this.cropShoulder, 1),
					g;
				for (g = 0; g &lt; f; g++)
					if (a[g] &gt;= c) {
						d = Math.max(0, g - k);
						break
					}
				for (c = g; c &lt; f; c++)
					if (a[c] &gt; e) {
						h = c + k;
						break
					}
				return {
					xData: a.slice(d, h),
					yData: b.slice(d, h),
					start: d,
					end: h
				}
			},
			generatePoints: function() {
				var a = this.options.data,
					b = this.data,
					c, e = this.processedXData,
					f = this.processedYData,
					d = this.pointClass,
					h = e.length,
					g = this.cropStart || 0,
					k, n = this.hasGroupedData,
					l, u = [],
					t;
				b || n || (b = [], b.length = a.length, b = this.data = b);
				for (t = 0; t &lt; h; t++) k = g + t, n ? (l = (new d).init(this, [e[t]].concat(q(f[t]))), l.dataGroup = this.groupMap[t]) : (l = b[k]) || void 0 === a[k] || (b[k] = l = (new d).init(this, a[k], e[t])), l.index = k, u[t] = l;
				if (b &amp;&amp; (h !== (c = b.length) || n))
					for (t = 0; t &lt; c; t++) t !== g || n || (t += h), b[t] &amp;&amp; (b[t].destroyElements(), b[t].plotX = void 0);
				this.data = b;
				this.points = u
			},
			getExtremes: function(a) {
				var b = this.yAxis,
					c = this.processedXData,
					f, d = [],
					h = 0;
				f = this.xAxis.getExtremes();
				var g = f.min,
					q = f.max,
					n, l, t, u;
				a = a || this.stackedYData || this.processedYData || [];
				f = a.length;
				for (u = 0; u &lt; f; u++)
					if (l = c[u], t = a[u], n = (e(t, !0) || k(t)) &amp;&amp; (!b.isLog || t.length || 0 &lt; t), l = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[u + 1] || l) &gt;= g &amp;&amp; (c[u - 1] || l) &lt;= q, n &amp;&amp; l)
						if (n = t.length)
							for (; n--;) null !== t[n] &amp;&amp; (d[h++] = t[n]);
						else d[h++] = t;
				this.dataMin = H(d);
				this.dataMax = F(d)
			},
			translate: function() {
				this.processedXData || this.processData();
				this.generatePoints();
				var a =
					this.options,
					b = a.stacking,
					c = this.xAxis,
					f = c.categories,
					d = this.yAxis,
					h = this.points,
					g = h.length,
					k = !!this.modifyValue,
					n = a.pointPlacement,
					q = "between" === n || e(n),
					t = a.threshold,
					r = a.startFromThreshold ? t : 0,
					x, w, v, I, K = Number.MAX_VALUE;
				"between" === n &amp;&amp; (n = .5);
				e(n) &amp;&amp; (n *= u(a.pointRange || c.pointRange));
				for (a = 0; a &lt; g; a++) {
					var C = h[a],
						J = C.x,
						A = C.y;
					w = C.low;
					var E = b &amp;&amp; d.stacks[(this.negStacks &amp;&amp; A &lt; (r ? 0 : t) ? "-" : "") + this.stackKey],
						F;
					d.isLog &amp;&amp; null !== A &amp;&amp; 0 &gt;= A &amp;&amp; (C.isNull = !0);
					C.plotX = x = p(Math.min(Math.max(-1E5, c.translate(J, 0, 0, 0, 1, n,
						"flags" === this.type)), 1E5));
					b &amp;&amp; this.visible &amp;&amp; !C.isNull &amp;&amp; E &amp;&amp; E[J] &amp;&amp; (I = this.getStackIndicator(I, J, this.index), F = E[J], A = F.points[I.key], w = A[0], A = A[1], w === r &amp;&amp; I.key === E[J].base &amp;&amp; (w = u(t, d.min)), d.isLog &amp;&amp; 0 &gt;= w &amp;&amp; (w = null), C.total = C.stackTotal = F.total, C.percentage = F.total &amp;&amp; C.y / F.total * 100, C.stackY = A, F.setOffset(this.pointXOffset || 0, this.barW || 0));
					C.yBottom = l(w) ? d.translate(w, 0, 1, 0, 1) : null;
					k &amp;&amp; (A = this.modifyValue(A, C));
					C.plotY = w = "number" === typeof A &amp;&amp; Infinity !== A ? Math.min(Math.max(-1E5, d.translate(A, 0, 1, 0, 1)), 1E5) :
						void 0;
					C.isInside = void 0 !== w &amp;&amp; 0 &lt;= w &amp;&amp; w &lt;= d.len &amp;&amp; 0 &lt;= x &amp;&amp; x &lt;= c.len;
					C.clientX = q ? p(c.translate(J, 0, 0, 0, 1, n)) : x;
					C.negative = C.y &lt; (t || 0);
					C.category = f &amp;&amp; void 0 !== f[C.x] ? f[C.x] : C.x;
					C.isNull || (void 0 !== v &amp;&amp; (K = Math.min(K, Math.abs(x - v))), v = x)
				}
				this.closestPointRangePx = K
			},
			getValidPoints: function(a, b) {
				var c = this.chart;
				return t(a || this.points || [], function(a) {
					return b &amp;&amp; !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull
				})
			},
			setClip: function(a) {
				var b = this.chart,
					c = this.options,
					e = b.renderer,
					f = b.inverted,
					d = this.clipBox,
					h = d || b.clipBox,
					g = this.sharedClipKey || ["_sharedClip", a &amp;&amp; a.duration, a &amp;&amp; a.easing, h.height, c.xAxis, c.yAxis].join(),
					k = b[g],
					n = b[g + "m"];
				k || (a &amp;&amp; (h.width = 0, b[g + "m"] = n = e.clipRect(-99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), b[g] = k = e.clipRect(h), k.count = {
					length: 0
				});
				a &amp;&amp; !k.count[this.index] &amp;&amp; (k.count[this.index] = !0, k.count.length += 1);
				!1 !== c.clip &amp;&amp; (this.group.clip(a || d ? k : b.clipRect), this.markerGroup.clip(n), this.sharedClipKey = g);
				a || (k.count[this.index] &amp;&amp; (delete k.count[this.index], --k.count.length),
					0 === k.count.length &amp;&amp; g &amp;&amp; b[g] &amp;&amp; (d || (b[g] = b[g].destroy()), b[g + "m"] &amp;&amp; (b[g + "m"] = b[g + "m"].destroy())))
			},
			animate: function(a) {
				var b = this.chart,
					c = A(this.options.animation),
					e;
				a ? this.setClip(c) : (e = this.sharedClipKey, (a = b[e]) &amp;&amp; a.animate({
					width: b.plotSizeX
				}, c), b[e + "m"] &amp;&amp; b[e + "m"].animate({
					width: b.plotSizeX + 99
				}, c), this.animate = null)
			},
			afterAnimate: function() {
				this.setClip();
				w(this, "afterAnimate")
			},
			drawPoints: function() {
				var a = this.points,
					b = this.chart,
					c, f, d, h, g = this.options.marker,
					k, n, q, l, t = this.markerGroup,
					r = u(g.enabled,
						this.xAxis.isRadial ? !0 : null, this.closestPointRangePx &gt; 2 * g.radius);
				if (!1 !== g.enabled || this._hasPointMarkers)
					for (f = a.length; f--;) d = a[f], c = d.plotY, h = d.graphic, k = d.marker || {}, n = !!d.marker, q = r &amp;&amp; void 0 === k.enabled || k.enabled, l = d.isInside, q &amp;&amp; e(c) &amp;&amp; null !== d.y ? (c = u(k.symbol, this.symbol), d.hasImage = 0 === c.indexOf("url"), q = this.markerAttribs(d, d.selected &amp;&amp; "select"), h ? h[l ? "show" : "hide"](!0).animate(q) : l &amp;&amp; (0 &lt; q.width || d.hasImage) &amp;&amp; (d.graphic = h = b.renderer.symbol(c, q.x, q.y, q.width, q.height, n ? k : g).add(t)), h &amp;&amp; h.attr(this.pointAttribs(d,
						d.selected &amp;&amp; "select")), h &amp;&amp; h.addClass(d.getClassName(), !0)) : h &amp;&amp; (d.graphic = h.destroy())
			},
			markerAttribs: function(a, b) {
				var c = this.options.marker,
					e = a &amp;&amp; a.options,
					f = e &amp;&amp; e.marker || {},
					e = u(f.radius, c.radius);
				b &amp;&amp; (c = c.states[b], b = f.states &amp;&amp; f.states[b], e = u(b &amp;&amp; b.radius, c &amp;&amp; c.radius, e + (c &amp;&amp; c.radiusPlus || 0)));
				a.hasImage &amp;&amp; (e = 0);
				a = {
					x: Math.floor(a.plotX) - e,
					y: a.plotY - e
				};
				e &amp;&amp; (a.width = a.height = 2 * e);
				return a
			},
			pointAttribs: function(a, b) {
				var c = this.options.marker,
					e = a &amp;&amp; a.options,
					f = e &amp;&amp; e.marker || {},
					d = this.color,
					h = e &amp;&amp; e.color,
					g = a &amp;&amp;
					a.color,
					e = u(f.lineWidth, c.lineWidth),
					k;
				a &amp;&amp; this.zones.length &amp;&amp; (a = a.getZone()) &amp;&amp; a.color &amp;&amp; (k = a.color);
				d = h || k || g || d;
				k = f.fillColor || c.fillColor || d;
				d = f.lineColor || c.lineColor || d;
				b &amp;&amp; (c = c.states[b], b = f.states &amp;&amp; f.states[b] || {}, e = u(b.lineWidth, c.lineWidth, e + u(b.lineWidthPlus, c.lineWidthPlus, 0)), k = b.fillColor || c.fillColor || k, d = b.lineColor || c.lineColor || d);
				return {
					stroke: d,
					"stroke-width": e,
					fill: k
				}
			},
			destroy: function() {
				var a = this,
					b = a.chart,
					e = /AppleWebKit\/533/.test(J.navigator.userAgent),
					d, h = a.data || [],
					k, g, n;
				w(a,
					"destroy");
				c(a);
				r(a.axisTypes || [], function(b) {
					(n = a[b]) &amp;&amp; n.series &amp;&amp; (f(n.series, a), n.isDirty = n.forceRedraw = !0)
				});
				a.legendItem &amp;&amp; a.chart.legend.destroyItem(a);
				for (d = h.length; d--;)(k = h[d]) &amp;&amp; k.destroy &amp;&amp; k.destroy();
				a.points = null;
				clearTimeout(a.animationTimeout);
				for (g in a) a[g] instanceof K &amp;&amp; !a[g].survive &amp;&amp; (d = e &amp;&amp; "group" === g ? "hide" : "destroy", a[g][d]());
				b.hoverSeries === a &amp;&amp; (b.hoverSeries = null);
				f(b.series, a);
				for (g in a) delete a[g]
			},
			getGraphPath: function(a, b, c) {
				var e = this,
					f = e.options,
					d = f.step,
					h, k = [],
					g = [],
					n;
				a = a ||
					e.points;
				(h = a.reversed) &amp;&amp; a.reverse();
				(d = {
					right: 1,
					center: 2
				}[d] || d &amp;&amp; 3) &amp;&amp; h &amp;&amp; (d = 4 - d);
				!f.connectNulls || b || c || (a = this.getValidPoints(a));
				r(a, function(h, m) {
					var q = h.plotX,
						t = h.plotY,
						u = a[m - 1];
					(h.leftCliff || u &amp;&amp; u.rightCliff) &amp;&amp; !c &amp;&amp; (n = !0);
					h.isNull &amp;&amp; !l(b) &amp;&amp; 0 &lt; m ? n = !f.connectNulls : h.isNull &amp;&amp; !b ? n = !0 : (0 === m || n ? m = ["M", h.plotX, h.plotY] : e.getPointSpline ? m = e.getPointSpline(a, h, m) : d ? (m = 1 === d ? ["L", u.plotX, t] : 2 === d ? ["L", (u.plotX + q) / 2, u.plotY, "L", (u.plotX + q) / 2, t] : ["L", q, u.plotY], m.push("L", q, t)) : m = ["L", q, t], g.push(h.x), d &amp;&amp; g.push(h.x),
						k.push.apply(k, m), n = !1)
				});
				k.xMap = g;
				return e.graphPath = k
			},
			drawGraph: function() {
				var a = this,
					b = this.options,
					c = (this.gappedPath || this.getGraphPath).call(this),
					e = [
						["graph", "highcharts-graph", b.lineColor || this.color, b.dashStyle]
					];
				r(this.zones, function(c, f) {
					e.push(["zone-graph-" + f, "highcharts-graph highcharts-zone-graph-" + f + " " + (c.className || ""), c.color || a.color, c.dashStyle || b.dashStyle])
				});
				r(e, function(e, f) {
					var d = e[0],
						h = a[d];
					h ? (h.endX = c.xMap, h.animate({
						d: c
					})) : c.length &amp;&amp; (a[d] = a.chart.renderer.path(c).addClass(e[1]).attr({
							zIndex: 1
						}).add(a.group),
						h = {
							stroke: e[2],
							"stroke-width": b.lineWidth,
							fill: a.fillGraph &amp;&amp; a.color || "none"
						}, e[3] ? h.dashstyle = e[3] : "square" !== b.linecap &amp;&amp; (h["stroke-linecap"] = h["stroke-linejoin"] = "round"), h = a[d].attr(h).shadow(2 &gt; f &amp;&amp; b.shadow));
					h &amp;&amp; (h.startX = c.xMap, h.isArea = c.isArea)
				})
			},
			applyZones: function() {
				var a = this,
					b = this.chart,
					c = b.renderer,
					e = this.zones,
					f, d, h = this.clips || [],
					k, g = this.graph,
					n = this.area,
					q = Math.max(b.chartWidth, b.chartHeight),
					l = this[(this.zoneAxis || "y") + "Axis"],
					t, p, x = b.inverted,
					w, v, I, K, C = !1;
				e.length &amp;&amp; (g || n) &amp;&amp; l &amp;&amp; void 0 !==
					l.min &amp;&amp; (p = l.reversed, w = l.horiz, g &amp;&amp; g.hide(), n &amp;&amp; n.hide(), t = l.getExtremes(), r(e, function(e, m) {
						f = p ? w ? b.plotWidth : 0 : w ? 0 : l.toPixels(t.min);
						f = Math.min(Math.max(u(d, f), 0), q);
						d = Math.min(Math.max(Math.round(l.toPixels(u(e.value, t.max), !0)), 0), q);
						C &amp;&amp; (f = d = l.toPixels(t.max));
						v = Math.abs(f - d);
						I = Math.min(f, d);
						K = Math.max(f, d);
						l.isXAxis ? (k = {
							x: x ? K : I,
							y: 0,
							width: v,
							height: q
						}, w || (k.x = b.plotHeight - k.x)) : (k = {
							x: 0,
							y: x ? K : I,
							width: q,
							height: v
						}, w &amp;&amp; (k.y = b.plotWidth - k.y));
						x &amp;&amp; c.isVML &amp;&amp; (k = l.isXAxis ? {
							x: 0,
							y: p ? I : K,
							height: k.width,
							width: b.chartWidth
						} : {
							x: k.y - b.plotLeft - b.spacingBox.x,
							y: 0,
							width: k.height,
							height: b.chartHeight
						});
						h[m] ? h[m].animate(k) : (h[m] = c.clipRect(k), g &amp;&amp; a["zone-graph-" + m].clip(h[m]), n &amp;&amp; a["zone-area-" + m].clip(h[m]));
						C = e.value &gt; t.max
					}), this.clips = h)
			},
			invertGroups: function(a) {
				function b() {
					var b = {
						width: c.yAxis.len,
						height: c.xAxis.len
					};
					r(["group", "markerGroup"], function(e) {
						c[e] &amp;&amp; c[e].attr(b).invert(a)
					})
				}
				var c = this,
					e;
				c.xAxis &amp;&amp; (e = E(c.chart, "resize", b), E(c, "destroy", e), b(a), c.invertGroups = b)
			},
			plotGroup: function(a, b, c, e, f) {
				var d = this[a],
					h = !d;
				h &amp;&amp; (this[a] = d = this.chart.renderer.g(b).attr({
					zIndex: e || .1
				}).add(f), d.addClass("highcharts-series-" + this.index + " highcharts-" + this.type + "-series highcharts-color-" + this.colorIndex + " " + (this.options.className || "")));
				d.attr({
					visibility: c
				})[h ? "attr" : "animate"](this.getPlotBox());
				return d
			},
			getPlotBox: function() {
				var a = this.chart,
					b = this.xAxis,
					c = this.yAxis;
				a.inverted &amp;&amp; (b = c, c = this.xAxis);
				return {
					translateX: b ? b.left : a.plotLeft,
					translateY: c ? c.top : a.plotTop,
					scaleX: 1,
					scaleY: 1
				}
			},
			render: function() {
				var a = this,
					b = a.chart,
					c, e = a.options,
					f = !!a.animate &amp;&amp; b.renderer.isSVG &amp;&amp; A(e.animation).duration,
					d = a.visible ? "inherit" : "hidden",
					h = e.zIndex,
					k = a.hasRendered,
					g = b.seriesGroup,
					n = b.inverted;
				c = a.plotGroup("group", "series", d, h, g);
				a.markerGroup = a.plotGroup("markerGroup", "markers", d, h, g);
				f &amp;&amp; a.animate(!0);
				c.inverted = a.isCartesian ? n : !1;
				a.drawGraph &amp;&amp; (a.drawGraph(), a.applyZones());
				a.drawDataLabels &amp;&amp; a.drawDataLabels();
				a.visible &amp;&amp; a.drawPoints();
				a.drawTracker &amp;&amp; !1 !== a.options.enableMouseTracking &amp;&amp; a.drawTracker();
				a.invertGroups(n);
				!1 === e.clip || a.sharedClipKey || k || c.clip(b.clipRect);
				f &amp;&amp; a.animate();
				k || (a.animationTimeout = I(function() {
					a.afterAnimate()
				}, f));
				a.isDirty = a.isDirtyData = !1;
				a.hasRendered = !0
			},
			redraw: function() {
				var a = this.chart,
					b = this.isDirty || this.isDirtyData,
					c = this.group,
					e = this.xAxis,
					f = this.yAxis;
				c &amp;&amp; (a.inverted &amp;&amp; c.attr({
					width: a.plotWidth,
					height: a.plotHeight
				}), c.animate({
					translateX: u(e &amp;&amp; e.left, a.plotLeft),
					translateY: u(f &amp;&amp; f.top, a.plotTop)
				}));
				this.translate();
				this.render();
				b &amp;&amp; delete this.kdTree
			},
			kdDimensions: 1,
			kdAxisArray: ["clientX",
				"plotY"
			],
			searchPoint: function(a, b) {
				var c = this.xAxis,
					e = this.yAxis,
					f = this.chart.inverted;
				return this.searchKDTree({
					clientX: f ? c.len - a.chartY + c.pos : a.chartX - c.pos,
					plotY: f ? e.len - a.chartX + e.pos : a.chartY - e.pos
				}, b)
			},
			buildKDTree: function() {
				function a(c, e, f) {
					var d, h;
					if (h = c &amp;&amp; c.length) return d = b.kdAxisArray[e % f], c.sort(function(a, b) {
						return a[d] - b[d]
					}), h = Math.floor(h / 2), {
						point: c[h],
						left: a(c.slice(0, h), e + 1, f),
						right: a(c.slice(h + 1), e + 1, f)
					}
				}
				var b = this,
					c = b.kdDimensions;
				delete b.kdTree;
				I(function() {
					b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c)
				}, b.options.kdNow ? 0 : 1)
			},
			searchKDTree: function(a, b) {
				function c(a, b, k, g) {
					var m = b.point,
						n = e.kdAxisArray[k % g],
						q, t, u = m;
					t = l(a[f]) &amp;&amp; l(m[f]) ? Math.pow(a[f] - m[f], 2) : null;
					q = l(a[d]) &amp;&amp; l(m[d]) ? Math.pow(a[d] - m[d], 2) : null;
					q = (t || 0) + (q || 0);
					m.dist = l(q) ? Math.sqrt(q) : Number.MAX_VALUE;
					m.distX = l(t) ? Math.sqrt(t) : Number.MAX_VALUE;
					n = a[n] - m[n];
					q = 0 &gt; n ? "left" : "right";
					t = 0 &gt; n ? "right" : "left";
					b[q] &amp;&amp; (q = c(a, b[q], k + 1, g), u = q[h] &lt; u[h] ? q : m);
					b[t] &amp;&amp; Math.sqrt(n * n) &lt; u[h] &amp;&amp; (a = c(a, b[t], k + 1, g), u = a[h] &lt; u[h] ? a : u);
					return u
				}
				var e =
					this,
					f = this.kdAxisArray[0],
					d = this.kdAxisArray[1],
					h = b ? "distX" : "dist";
				this.kdTree || this.buildKDTree();
				if (this.kdTree) return c(a, this.kdTree, this.kdDimensions, this.kdDimensions)
			}
		})
	})(M);
	(function(a) {
		function E(a, f, b, d, g) {
			var n = a.chart.inverted;
			this.axis = a;
			this.isNegative = b;
			this.options = f;
			this.x = d;
			this.total = null;
			this.points = {};
			this.stack = g;
			this.rightCliff = this.leftCliff = 0;
			this.alignOptions = {
				align: f.align || (n ? b ? "left" : "right" : "center"),
				verticalAlign: f.verticalAlign || (n ? "middle" : b ? "bottom" : "top"),
				y: l(f.y,
					n ? 4 : b ? 14 : -6),
				x: l(f.x, n ? b ? -6 : 6 : 0)
			};
			this.textAlign = f.textAlign || (n ? b ? "right" : "left" : "center")
		}
		var A = a.Axis,
			F = a.Chart,
			H = a.correctFloat,
			p = a.defined,
			d = a.destroyObjectProperties,
			g = a.each,
			v = a.format,
			l = a.pick;
		a = a.Series;
		E.prototype = {
			destroy: function() {
				d(this, this.axis)
			},
			render: function(a) {
				var f = this.options,
					b = f.format,
					b = b ? v(b, this) : f.formatter.call(this);
				this.label ? this.label.attr({
					text: b,
					visibility: "hidden"
				}) : this.label = this.axis.chart.renderer.text(b, null, null, f.useHTML).css(f.style).attr({
					align: this.textAlign,
					rotation: f.rotation,
					visibility: "hidden"
				}).add(a)
			},
			setOffset: function(a, f) {
				var b = this.axis,
					d = b.chart,
					g = d.inverted,
					l = b.reversed,
					l = this.isNegative &amp;&amp; !l || !this.isNegative &amp;&amp; l,
					k = b.translate(b.usePercentage ? 100 : this.total, 0, 0, 0, 1),
					b = b.translate(0),
					b = Math.abs(k - b);
				a = d.xAxis[0].translate(this.x) + a;
				var e = d.plotHeight,
					g = {
						x: g ? l ? k : k - b : a,
						y: g ? e - a - f : l ? e - k - b : e - k,
						width: g ? b : f,
						height: g ? f : b
					};
				if (f = this.label) f.align(this.alignOptions, null, g), g = f.alignAttr, f[!1 === this.options.crop || d.isInsidePlot(g.x, g.y) ? "show" : "hide"](!0)
			}
		};
		F.prototype.getStacks = function() {
			var a = this;
			g(a.yAxis, function(a) {
				a.stacks &amp;&amp; a.hasVisibleSeries &amp;&amp; (a.oldStacks = a.stacks)
			});
			g(a.series, function(f) {
				!f.options.stacking || !0 !== f.visible &amp;&amp; !1 !== a.options.chart.ignoreHiddenSeries || (f.stackKey = f.type + l(f.options.stack, ""))
			})
		};
		A.prototype.buildStacks = function() {
			var a = this.series,
				f, b = l(this.options.reversedStacks, !0),
				d = a.length,
				g;
			if (!this.isXAxis) {
				this.usePercentage = !1;
				for (g = d; g--;) a[b ? g : d - g - 1].setStackedPoints();
				for (g = d; g--;) f = a[b ? g : d - g - 1], f.setStackCliffs &amp;&amp;
					f.setStackCliffs();
				if (this.usePercentage)
					for (g = 0; g &lt; d; g++) a[g].setPercentStacks()
			}
		};
		A.prototype.renderStackTotals = function() {
			var a = this.chart,
				f = a.renderer,
				b = this.stacks,
				d, g, l = this.stackTotalGroup;
			l || (this.stackTotalGroup = l = f.g("stack-labels").attr({
				visibility: "visible",
				zIndex: 6
			}).add());
			l.translate(a.plotLeft, a.plotTop);
			for (d in b)
				for (g in a = b[d], a) a[g].render(l)
		};
		A.prototype.resetStacks = function() {
			var a = this.stacks,
				f, b;
			if (!this.isXAxis)
				for (f in a)
					for (b in a[f]) a[f][b].touched &lt; this.stacksTouched ? (a[f][b].destroy(),
						delete a[f][b]) : (a[f][b].total = null, a[f][b].cum = null)
		};
		A.prototype.cleanStacks = function() {
			var a, f, b;
			if (!this.isXAxis)
				for (f in this.oldStacks &amp;&amp; (a = this.stacks = this.oldStacks), a)
					for (b in a[f]) a[f][b].cum = a[f][b].total
		};
		a.prototype.setStackedPoints = function() {
			if (this.options.stacking &amp;&amp; (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
				var a = this.processedXData,
					f = this.processedYData,
					b = [],
					d = f.length,
					g = this.options,
					t = g.threshold,
					k = g.startFromThreshold ? t : 0,
					e = g.stack,
					g = g.stacking,
					h = this.stackKey,
					v = "-" + h,
					u = this.negStacks,
					c = this.yAxis,
					q = c.stacks,
					x = c.oldStacks,
					K, I, J, D, G, A, F;
				c.stacksTouched += 1;
				for (G = 0; G &lt; d; G++) A = a[G], F = f[G], K = this.getStackIndicator(K, A, this.index), D = K.key, J = (I = u &amp;&amp; F &lt; (k ? 0 : t)) ? v : h, q[J] || (q[J] = {}), q[J][A] || (x[J] &amp;&amp; x[J][A] ? (q[J][A] = x[J][A], q[J][A].total = null) : q[J][A] = new E(c, c.options.stackLabels, I, A, e)), J = q[J][A], null !== F &amp;&amp; (J.points[D] = J.points[this.index] = [l(J.cum, k)], p(J.cum) || (J.base = D), J.touched = c.stacksTouched, 0 &lt; K.index &amp;&amp; !1 === this.singleStacks &amp;&amp; (J.points[D][0] = J.points[this.index +
					"," + A + ",0"][0])), "percent" === g ? (I = I ? h : v, u &amp;&amp; q[I] &amp;&amp; q[I][A] ? (I = q[I][A], J.total = I.total = Math.max(I.total, J.total) + Math.abs(F) || 0) : J.total = H(J.total + (Math.abs(F) || 0))) : J.total = H(J.total + (F || 0)), J.cum = l(J.cum, k) + (F || 0), null !== F &amp;&amp; (J.points[D].push(J.cum), b[G] = J.cum);
				"percent" === g &amp;&amp; (c.usePercentage = !0);
				this.stackedYData = b;
				c.oldStacks = {}
			}
		};
		a.prototype.setPercentStacks = function() {
			var a = this,
				f = a.stackKey,
				b = a.yAxis.stacks,
				d = a.processedXData,
				l;
			g([f, "-" + f], function(f) {
				for (var g = d.length, e, h; g--;)
					if (e = d[g], l = a.getStackIndicator(l,
							e, a.index, f), e = (h = b[f] &amp;&amp; b[f][e]) &amp;&amp; h.points[l.key]) h = h.total ? 100 / h.total : 0, e[0] = H(e[0] * h), e[1] = H(e[1] * h), a.stackedYData[g] = e[1]
			})
		};
		a.prototype.getStackIndicator = function(a, f, b, d) {
			!p(a) || a.x !== f || d &amp;&amp; a.key !== d ? a = {
				x: f,
				index: 0,
				key: d
			} : a.index++;
			a.key = [b, f, a.index].join();
			return a
		}
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.animate,
			F = a.Axis,
			H = a.createElement,
			p = a.css,
			d = a.defined,
			g = a.each,
			v = a.erase,
			l = a.extend,
			r = a.fireEvent,
			f = a.inArray,
			b = a.isNumber,
			n = a.isObject,
			w = a.merge,
			t = a.pick,
			k = a.Point,
			e = a.Series,
			h = a.seriesTypes,
			C = a.setAnimation,
			u = a.splat;
		l(a.Chart.prototype, {
			addSeries: function(a, b, e) {
				var c, f = this;
				a &amp;&amp; (b = t(b, !0), r(f, "addSeries", {
					options: a
				}, function() {
					c = f.initSeries(a);
					f.isDirtyLegend = !0;
					f.linkSeries();
					b &amp;&amp; f.redraw(e)
				}));
				return c
			},
			addAxis: function(a, b, e, f) {
				var c = b ? "xAxis" : "yAxis",
					d = this.options;
				a = w(a, {
					index: this[c].length,
					isX: b
				});
				new F(this, a);
				d[c] = u(d[c] || {});
				d[c].push(a);
				t(e, !0) &amp;&amp; this.redraw(f)
			},
			showLoading: function(a) {
				var b = this,
					c = b.options,
					e = b.loadingDiv,
					f = c.loading,
					d = function() {
						e &amp;&amp; p(e, {
							left: b.plotLeft +
								"px",
							top: b.plotTop + "px",
							width: b.plotWidth + "px",
							height: b.plotHeight + "px"
						})
					};
				e || (b.loadingDiv = e = H("div", {
					className: "highcharts-loading highcharts-loading-hidden"
				}, null, b.container), b.loadingSpan = H("span", {
					className: "highcharts-loading-inner"
				}, null, e), E(b, "redraw", d));
				e.className = "highcharts-loading";
				b.loadingSpan.innerHTML = a || c.lang.loading;
				p(e, l(f.style, {
					zIndex: 10
				}));
				p(b.loadingSpan, f.labelStyle);
				b.loadingShown || (p(e, {
					opacity: 0,
					display: ""
				}), A(e, {
					opacity: f.style.opacity || .5
				}, {
					duration: f.showDuration ||
						0
				}));
				b.loadingShown = !0;
				d()
			},
			hideLoading: function() {
				var a = this.options,
					b = this.loadingDiv;
				b &amp;&amp; (b.className = "highcharts-loading highcharts-loading-hidden", A(b, {
					opacity: 0
				}, {
					duration: a.loading.hideDuration || 100,
					complete: function() {
						p(b, {
							display: "none"
						})
					}
				}));
				this.loadingShown = !1
			},
			propsRequireDirtyBox: "backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
			propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions".split(" "),
			update: function(a, e) {
				var c, h = {
						credits: "addCredits",
						title: "setTitle",
						subtitle: "setSubtitle"
					},
					k = a.chart,
					n, q;
				if (k) {
					w(!0, this.options.chart, k);
					"className" in k &amp;&amp; this.setClassName(k.className);
					if ("inverted" in k || "polar" in k) this.propFromSeries(), n = !0;
					for (c in k) k.hasOwnProperty(c) &amp;&amp; (-1 !== f("chart." + c, this.propsRequireUpdateSeries) &amp;&amp; (q = !0), -1 !== f(c, this.propsRequireDirtyBox) &amp;&amp; (this.isDirtyBox = !0));
					"style" in k &amp;&amp; this.renderer.setStyle(k.style)
				}
				for (c in a) {
					if (this[c] &amp;&amp; "function" === typeof this[c].update) this[c].update(a[c], !1);
					else if ("function" === typeof this[h[c]]) this[h[c]](a[c]);
					"chart" !== c &amp;&amp; -1 !== f(c, this.propsRequireUpdateSeries) &amp;&amp; (q = !0)
				}
				a.colors &amp;&amp; (this.options.colors = a.colors);
				a.plotOptions &amp;&amp; w(!0, this.options.plotOptions, a.plotOptions);
				g(["xAxis", "yAxis", "series"], function(b) {
					a[b] &amp;&amp; g(u(a[b]), function(a) {
						var c = d(a.id) &amp;&amp; this.get(a.id) || this[b][0];
						c &amp;&amp; c.coll === b &amp;&amp; c.update(a, !1)
					}, this)
				}, this);
				n &amp;&amp; g(this.axes, function(a) {
					a.update({}, !1)
				});
				q &amp;&amp; g(this.series, function(a) {
					a.update({}, !1)
				});
				a.loading &amp;&amp; w(!0, this.options.loading, a.loading);
				c = k &amp;&amp; k.width;
				k = k &amp;&amp; k.height;
				b(c) &amp;&amp; c !== this.chartWidth || b(k) &amp;&amp; k !== this.chartHeight ? this.setSize(c, k) : t(e, !0) &amp;&amp; this.redraw()
			},
			setSubtitle: function(a) {
				this.setTitle(void 0, a)
			}
		});
		l(k.prototype, {
			update: function(a, b, e, f) {
				function c() {
					d.applyOptions(a);
					null === d.y &amp;&amp; g &amp;&amp; (d.graphic = g.destroy());
					n(a, !0) &amp;&amp; (g &amp;&amp; g.element &amp;&amp; a &amp;&amp; a.marker &amp;&amp; a.marker.symbol &amp;&amp; (d.graphic = g.destroy()),
						a &amp;&amp; a.dataLabels &amp;&amp; d.dataLabel &amp;&amp; (d.dataLabel = d.dataLabel.destroy()));
					k = d.index;
					h.updateParallelArrays(d, k);
					m.data[k] = n(m.data[k], !0) ? d.options : a;
					h.isDirty = h.isDirtyData = !0;
					!h.fixedBox &amp;&amp; h.hasCartesianSeries &amp;&amp; (q.isDirtyBox = !0);
					"point" === m.legendType &amp;&amp; (q.isDirtyLegend = !0);
					b &amp;&amp; q.redraw(e)
				}
				var d = this,
					h = d.series,
					g = d.graphic,
					k, q = h.chart,
					m = h.options;
				b = t(b, !0);
				!1 === f ? c() : d.firePointEvent("update", {
					options: a
				}, c)
			},
			remove: function(a, b) {
				this.series.removePoint(f(this, this.series.data), a, b)
			}
		});
		l(e.prototype, {
			addPoint: function(a,
				b, e, f) {
				var c = this.options,
					d = this.data,
					h = this.chart,
					g = this.xAxis &amp;&amp; this.xAxis.names,
					k = c.data,
					n, m, q = this.xData,
					l, u;
				b = t(b, !0);
				n = {
					series: this
				};
				this.pointClass.prototype.applyOptions.apply(n, [a]);
				u = n.x;
				l = q.length;
				if (this.requireSorting &amp;&amp; u &lt; q[l - 1])
					for (m = !0; l &amp;&amp; q[l - 1] &gt; u;) l--;
				this.updateParallelArrays(n, "splice", l, 0, 0);
				this.updateParallelArrays(n, l);
				g &amp;&amp; n.name &amp;&amp; (g[u] = n.name);
				k.splice(l, 0, a);
				m &amp;&amp; (this.data.splice(l, 0, null), this.processData());
				"point" === c.legendType &amp;&amp; this.generatePoints();
				e &amp;&amp; (d[0] &amp;&amp; d[0].remove ?
					d[0].remove(!1) : (d.shift(), this.updateParallelArrays(n, "shift"), k.shift()));
				this.isDirtyData = this.isDirty = !0;
				b &amp;&amp; h.redraw(f)
			},
			removePoint: function(a, b, e) {
				var c = this,
					f = c.data,
					d = f[a],
					h = c.points,
					g = c.chart,
					k = function() {
						h &amp;&amp; h.length === f.length &amp;&amp; h.splice(a, 1);
						f.splice(a, 1);
						c.options.data.splice(a, 1);
						c.updateParallelArrays(d || {
							series: c
						}, "splice", a, 1);
						d &amp;&amp; d.destroy();
						c.isDirty = !0;
						c.isDirtyData = !0;
						b &amp;&amp; g.redraw()
					};
				C(e, g);
				b = t(b, !0);
				d ? d.firePointEvent("remove", null, k) : k()
			},
			remove: function(a, b, e) {
				function c() {
					f.destroy();
					d.isDirtyLegend = d.isDirtyBox = !0;
					d.linkSeries();
					t(a, !0) &amp;&amp; d.redraw(b)
				}
				var f = this,
					d = f.chart;
				!1 !== e ? r(f, "remove", null, c) : c()
			},
			update: function(a, b) {
				var c = this,
					e = this.chart,
					f = this.userOptions,
					d = this.type,
					k = a.type || f.type || e.options.chart.type,
					n = h[d].prototype,
					q = ["group", "markerGroup", "dataLabelsGroup"],
					u;
				if (k &amp;&amp; k !== d || void 0 !== a.zIndex) q.length = 0;
				g(q, function(a) {
					q[a] = c[a];
					delete c[a]
				});
				a = w(f, {
					animation: !1,
					index: this.index,
					pointStart: this.xData[0]
				}, {
					data: this.options.data
				}, a);
				this.remove(!1, null, !1);
				for (u in n) this[u] =
					void 0;
				l(this, h[k || d].prototype);
				g(q, function(a) {
					c[a] = q[a]
				});
				this.init(e, a);
				e.linkSeries();
				t(b, !0) &amp;&amp; e.redraw(!1)
			}
		});
		l(F.prototype, {
			update: function(a, b) {
				var c = this.chart;
				a = c.options[this.coll][this.options.index] = w(this.userOptions, a);
				this.destroy(!0);
				this.init(c, l(a, {
					events: void 0
				}));
				c.isDirtyBox = !0;
				t(b, !0) &amp;&amp; c.redraw()
			},
			remove: function(a) {
				for (var b = this.chart, c = this.coll, e = this.series, f = e.length; f--;) e[f] &amp;&amp; e[f].remove(!1);
				v(b.axes, this);
				v(b[c], this);
				b.options[c].splice(this.options.index, 1);
				g(b[c],
					function(a, b) {
						a.options.index = b
					});
				this.destroy();
				b.isDirtyBox = !0;
				t(a, !0) &amp;&amp; b.redraw()
			},
			setTitle: function(a, b) {
				this.update({
					title: a
				}, b)
			},
			setCategories: function(a, b) {
				this.update({
					categories: a
				}, b)
			}
		})
	})(M);
	(function(a) {
		var E = a.color,
			A = a.each,
			F = a.map,
			H = a.pick,
			p = a.Series,
			d = a.seriesType;
		d("area", "line", {
			softThreshold: !1,
			threshold: 0
		}, {
			singleStacks: !1,
			getStackPoints: function() {
				var a = [],
					d = [],
					l = this.xAxis,
					p = this.yAxis,
					f = p.stacks[this.stackKey],
					b = {},
					n = this.points,
					w = this.index,
					t = p.series,
					k = t.length,
					e, h = H(p.options.reversedStacks, !0) ? 1 : -1,
					C, u;
				if (this.options.stacking) {
					for (C = 0; C &lt; n.length; C++) b[n[C].x] = n[C];
					for (u in f) null !== f[u].total &amp;&amp; d.push(u);
					d.sort(function(a, b) {
						return a - b
					});
					e = F(t, function() {
						return this.visible
					});
					A(d, function(c, g) {
						var n = 0,
							q, u;
						if (b[c] &amp;&amp; !b[c].isNull) a.push(b[c]), A([-1, 1], function(a) {
							var n = 1 === a ? "rightNull" : "leftNull",
								l = 0,
								t = f[d[g + a]];
							if (t)
								for (C = w; 0 &lt;= C &amp;&amp; C &lt; k;) q = t.points[C], q || (C === w ? b[c][n] = !0 : e[C] &amp;&amp; (u = f[c].points[C]) &amp;&amp; (l -= u[1] - u[0])), C += h;
							b[c][1 === a ? "rightCliff" : "leftCliff"] = l
						});
						else {
							for (C = w; 0 &lt;= C &amp;&amp; C &lt; k;) {
								if (q =
									f[c].points[C]) {
									n = q[1];
									break
								}
								C += h
							}
							n = p.toPixels(n, !0);
							a.push({
								isNull: !0,
								plotX: l.toPixels(c, !0),
								plotY: n,
								yBottom: n
							})
						}
					})
				}
				return a
			},
			getGraphPath: function(a) {
				var d = p.prototype.getGraphPath,
					g = this.options,
					r = g.stacking,
					f = this.yAxis,
					b, n, w = [],
					t = [],
					k = this.index,
					e, h = f.stacks[this.stackKey],
					C = g.threshold,
					u = f.getThreshold(g.threshold),
					c, g = g.connectNulls || "percent" === r,
					q = function(b, c, d) {
						var g = a[b];
						b = r &amp;&amp; h[g.x].points[k];
						var n = g[d + "Null"] || 0;
						d = g[d + "Cliff"] || 0;
						var q, l, g = !0;
						d || n ? (q = (n ? b[0] : b[1]) + d, l = b[0] + d, g = !!n) : !r &amp;&amp;
							a[c] &amp;&amp; a[c].isNull &amp;&amp; (q = l = C);
						void 0 !== q &amp;&amp; (t.push({
							plotX: e,
							plotY: null === q ? u : f.getThreshold(q),
							isNull: g
						}), w.push({
							plotX: e,
							plotY: null === l ? u : f.getThreshold(l),
							doCurve: !1
						}))
					};
				a = a || this.points;
				r &amp;&amp; (a = this.getStackPoints());
				for (b = 0; b &lt; a.length; b++)
					if (n = a[b].isNull, e = H(a[b].rectPlotX, a[b].plotX), c = H(a[b].yBottom, u), !n || g) g || q(b, b - 1, "left"), n &amp;&amp; !r &amp;&amp; g || (t.push(a[b]), w.push({
						x: b,
						plotX: e,
						plotY: c
					})), g || q(b, b + 1, "right");
				b = d.call(this, t, !0, !0);
				w.reversed = !0;
				n = d.call(this, w, !0, !0);
				n.length &amp;&amp; (n[0] = "L");
				n = b.concat(n);
				d =
					d.call(this, t, !1, g);
				n.xMap = b.xMap;
				this.areaPath = n;
				return d
			},
			drawGraph: function() {
				this.areaPath = [];
				p.prototype.drawGraph.apply(this);
				var a = this,
					d = this.areaPath,
					l = this.options,
					r = [
						["area", "highcharts-area", this.color, l.fillColor]
					];
				A(this.zones, function(d, b) {
					r.push(["zone-area-" + b, "highcharts-area highcharts-zone-area-" + b + " " + d.className, d.color || a.color, d.fillColor || l.fillColor])
				});
				A(r, function(f) {
					var b = f[0],
						g = a[b];
					g ? (g.endX = d.xMap, g.animate({
						d: d
					})) : (g = a[b] = a.chart.renderer.path(d).addClass(f[1]).attr({
						fill: H(f[3],
							E(f[2]).setOpacity(H(l.fillOpacity, .75)).get()),
						zIndex: 0
					}).add(a.group), g.isArea = !0);
					g.startX = d.xMap;
					g.shiftUnit = l.step ? 2 : 1
				})
			},
			drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
		})
	})(M);
	(function(a) {
		var E = a.pick;
		a = a.seriesType;
		a("spline", "line", {}, {
			getPointSpline: function(a, F, H) {
				var p = F.plotX,
					d = F.plotY,
					g = a[H - 1];
				H = a[H + 1];
				var v, l, r, f;
				if (g &amp;&amp; !g.isNull &amp;&amp; !1 !== g.doCurve &amp;&amp; H &amp;&amp; !H.isNull &amp;&amp; !1 !== H.doCurve) {
					a = g.plotY;
					r = H.plotX;
					H = H.plotY;
					var b = 0;
					v = (1.5 * p + g.plotX) / 2.5;
					l = (1.5 * d + a) / 2.5;
					r = (1.5 * p + r) / 2.5;
					f = (1.5 * d + H) / 2.5;
					r !== v &amp;&amp; (b = (f - l) * (r - p) / (r - v) + d - f);
					l += b;
					f += b;
					l &gt; a &amp;&amp; l &gt; d ? (l = Math.max(a, d), f = 2 * d - l) : l &lt; a &amp;&amp; l &lt; d &amp;&amp; (l = Math.min(a, d), f = 2 * d - l);
					f &gt; H &amp;&amp; f &gt; d ? (f = Math.max(H, d), l = 2 * d - f) : f &lt; H &amp;&amp; f &lt; d &amp;&amp; (f = Math.min(H, d), l = 2 * d - f);
					F.rightContX = r;
					F.rightContY = f
				}
				F = ["C", E(g.rightContX, g.plotX), E(g.rightContY, g.plotY), E(v, p), E(l, d), p, d];
				g.rightContX = g.rightContY = null;
				return F
			}
		})
	})(M);
	(function(a) {
		var E = a.seriesTypes.area.prototype,
			A = a.seriesType;
		A("areaspline", "spline", a.defaultPlotOptions.area, {
			getStackPoints: E.getStackPoints,
			getGraphPath: E.getGraphPath,
			setStackCliffs: E.setStackCliffs,
			drawGraph: E.drawGraph,
			drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
		})
	})(M);
	(function(a) {
		var E = a.animObject,
			A = a.color,
			F = a.each,
			H = a.extend,
			p = a.isNumber,
			d = a.merge,
			g = a.pick,
			v = a.Series,
			l = a.seriesType,
			r = a.svg;
		l("column", "line", {
			borderRadius: 0,
			groupPadding: .2,
			marker: null,
			pointPadding: .1,
			minPointLength: 0,
			cropThreshold: 50,
			pointRange: null,
			states: {
				hover: {
					halo: !1,
					brightness: .1,
					shadow: !1
				},
				select: {
					color: "#cccccc",
					borderColor: "#000000",
					shadow: !1
				}
			},
			dataLabels: {
				align: null,
				verticalAlign: null,
				y: null
			},
			softThreshold: !1,
			startFromThreshold: !0,
			stickyTracking: !1,
			tooltip: {
				distance: 6
			},
			threshold: 0,
			borderColor: "#ffffff"
		}, {
			cropShoulder: 0,
			directTouch: !0,
			trackerGroups: ["group", "dataLabelsGroup"],
			negStacks: !0,
			init: function() {
				v.prototype.init.apply(this, arguments);
				var a = this,
					b = a.chart;
				b.hasRendered &amp;&amp; F(b.series, function(b) {
					b.type === a.type &amp;&amp; (b.isDirty = !0)
				})
			},
			getColumnMetrics: function() {
				var a = this,
					b = a.options,
					d = a.xAxis,
					l = a.yAxis,
					t = d.reversed,
					k, e = {},
					h = 0;
				!1 === b.grouping ? h = 1 : F(a.chart.series, function(b) {
					var c =
						b.options,
						d = b.yAxis,
						f;
					b.type === a.type &amp;&amp; b.visible &amp;&amp; l.len === d.len &amp;&amp; l.pos === d.pos &amp;&amp; (c.stacking ? (k = b.stackKey, void 0 === e[k] &amp;&amp; (e[k] = h++), f = e[k]) : !1 !== c.grouping &amp;&amp; (f = h++), b.columnIndex = f)
				});
				var p = Math.min(Math.abs(d.transA) * (d.ordinalSlope || b.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),
					u = p * b.groupPadding,
					c = (p - 2 * u) / h,
					b = Math.min(b.maxPointWidth || d.len, g(b.pointWidth, c * (1 - 2 * b.pointPadding)));
				a.columnMetrics = {
					width: b,
					offset: (c - b) / 2 + (u + ((a.columnIndex || 0) + (t ? 1 : 0)) * c - p / 2) * (t ? -1 : 1)
				};
				return a.columnMetrics
			},
			crispCol: function(a, b, d, g) {
				var f = this.chart,
					k = this.borderWidth,
					e = -(k % 2 ? .5 : 0),
					k = k % 2 ? .5 : 1;
				f.inverted &amp;&amp; f.renderer.isVML &amp;&amp; (k += 1);
				d = Math.round(a + d) + e;
				a = Math.round(a) + e;
				g = Math.round(b + g) + k;
				e = .5 &gt;= Math.abs(b) &amp;&amp; .5 &lt; g;
				b = Math.round(b) + k;
				g -= b;
				e &amp;&amp; g &amp;&amp; (--b, g += 1);
				return {
					x: a,
					y: b,
					width: d - a,
					height: g
				}
			},
			translate: function() {
				var a = this,
					b = a.chart,
					d = a.options,
					l = a.dense = 2 &gt; a.closestPointRange * a.xAxis.transA,
					l = a.borderWidth = g(d.borderWidth, l ? 0 : 1),
					t = a.yAxis,
					k = a.translatedThreshold = t.getThreshold(d.threshold),
					e = g(d.minPointLength,
						5),
					h = a.getColumnMetrics(),
					p = h.width,
					u = a.barW = Math.max(p, 1 + 2 * l),
					c = a.pointXOffset = h.offset;
				b.inverted &amp;&amp; (k -= .5);
				d.pointPadding &amp;&amp; (u = Math.ceil(u));
				v.prototype.translate.apply(a);
				F(a.points, function(d) {
					var f = g(d.yBottom, k),
						h = 999 + Math.abs(f),
						h = Math.min(Math.max(-h, d.plotY), t.len + h),
						n = d.plotX + c,
						l = u,
						q = Math.min(h, f),
						r, v = Math.max(h, f) - q;
					Math.abs(v) &lt; e &amp;&amp; e &amp;&amp; (v = e, r = !t.reversed &amp;&amp; !d.negative || t.reversed &amp;&amp; d.negative, q = Math.abs(q - k) &gt; e ? f - e : k - (r ? e : 0));
					d.barX = n;
					d.pointWidth = p;
					d.tooltipPos = b.inverted ? [t.len + t.pos - b.plotLeft -
						h, a.xAxis.len - n - l / 2, v
					] : [n + l / 2, h + t.pos - b.plotTop, v];
					d.shapeType = "rect";
					d.shapeArgs = a.crispCol.apply(a, d.isNull ? [d.plotX, t.len / 2, 0, 0] : [n, q, l, v])
				})
			},
			getSymbol: a.noop,
			drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
			drawGraph: function() {
				this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data")
			},
			pointAttribs: function(a, b) {
				var d = this.options,
					f = this.pointAttrToOptions || {},
					g = f.stroke || "borderColor",
					k = f["stroke-width"] || "borderWidth",
					e = a &amp;&amp; a.color || this.color,
					h = a[g] || d[g] || this.color || e,
					f =
					d.dashStyle,
					l;
				a &amp;&amp; this.zones.length &amp;&amp; (e = (e = a.getZone()) &amp;&amp; e.color || a.options.color || this.color);
				b &amp;&amp; (b = d.states[b], l = b.brightness, e = b.color || void 0 !== l &amp;&amp; A(e).brighten(b.brightness).get() || e, h = b[g] || h, f = b.dashStyle || f);
				a = {
					fill: e,
					stroke: h,
					"stroke-width": a[k] || d[k] || this[k] || 0
				};
				d.borderRadius &amp;&amp; (a.r = d.borderRadius);
				f &amp;&amp; (a.dashstyle = f);
				return a
			},
			drawPoints: function() {
				var a = this,
					b = this.chart,
					g = a.options,
					l = b.renderer,
					t = g.animationLimit || 250,
					k;
				F(a.points, function(e) {
					var f = e.graphic;
					if (p(e.plotY) &amp;&amp; null !== e.y) {
						k =
							e.shapeArgs;
						if (f) f[b.pointCount &lt; t ? "animate" : "attr"](d(k));
						else e.graphic = f = l[e.shapeType](k).attr({
							"class": e.getClassName()
						}).add(e.group || a.group);
						f.attr(a.pointAttribs(e, e.selected &amp;&amp; "select")).shadow(g.shadow, null, g.stacking &amp;&amp; !g.borderRadius)
					} else f &amp;&amp; (e.graphic = f.destroy())
				})
			},
			animate: function(a) {
				var b = this,
					d = this.yAxis,
					f = b.options,
					g = this.chart.inverted,
					k = {};
				r &amp;&amp; (a ? (k.scaleY = .001, a = Math.min(d.pos + d.len, Math.max(d.pos, d.toPixels(f.threshold))), g ? k.translateX = a - d.len : k.translateY = a, b.group.attr(k)) :
					(k[g ? "translateX" : "translateY"] = d.pos, b.group.animate(k, H(E(b.options.animation), {
						step: function(a, d) {
							b.group.attr({
								scaleY: Math.max(.001, d.pos)
							})
						}
					})), b.animate = null))
			},
			remove: function() {
				var a = this,
					b = a.chart;
				b.hasRendered &amp;&amp; F(b.series, function(b) {
					b.type === a.type &amp;&amp; (b.isDirty = !0)
				});
				v.prototype.remove.apply(a, arguments)
			}
		})
	})(M);
	(function(a) {
		a = a.seriesType;
		a("bar", "column", null, {
			inverted: !0
		})
	})(M);
	(function(a) {
		var E = a.Series;
		a = a.seriesType;
		a("scatter", "line", {
			lineWidth: 0,
			marker: {
				enabled: !0
			},
			tooltip: {
				headerFormat: '\x3cspan style\x3d"color:{point.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 0.85em"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e',
				pointFormat: "x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e"
			}
		}, {
			sorted: !1,
			requireSorting: !1,
			noSharedTooltip: !0,
			trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
			takeOrdinalPosition: !1,
			kdDimensions: 2,
			drawGraph: function() {
				this.options.lineWidth &amp;&amp; E.prototype.drawGraph.call(this)
			}
		})
	})(M);
	(function(a) {
		var E = a.pick,
			A = a.relativeLength;
		a.CenteredSeriesMixin = {
			getCenter: function() {
				var a = this.options,
					H = this.chart,
					p = 2 * (a.slicedOffset || 0),
					d = H.plotWidth - 2 * p,
					H = H.plotHeight -
					2 * p,
					g = a.center,
					g = [E(g[0], "50%"), E(g[1], "50%"), a.size || "100%", a.innerSize || 0],
					v = Math.min(d, H),
					l, r;
				for (l = 0; 4 &gt; l; ++l) r = g[l], a = 2 &gt; l || 2 === l &amp;&amp; /%$/.test(r), g[l] = A(r, [d, H, v, g[2]][l]) + (a ? p : 0);
				g[3] &gt; g[2] &amp;&amp; (g[3] = g[2]);
				return g
			}
		}
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.defined,
			F = a.each,
			H = a.extend,
			p = a.inArray,
			d = a.noop,
			g = a.pick,
			v = a.Point,
			l = a.Series,
			r = a.seriesType,
			f = a.setAnimation;
		r("pie", "line", {
			center: [null, null],
			clip: !1,
			colorByPoint: !0,
			dataLabels: {
				distance: 30,
				enabled: !0,
				formatter: function() {
					return null === this.y ?
						void 0 : this.point.name
				},
				x: 0
			},
			ignoreHiddenPoint: !0,
			legendType: "point",
			marker: null,
			size: null,
			showInLegend: !1,
			slicedOffset: 10,
			stickyTracking: !1,
			tooltip: {
				followPointer: !0
			},
			borderColor: "#ffffff",
			borderWidth: 1,
			states: {
				hover: {
					brightness: .1,
					shadow: !1
				}
			}
		}, {
			isCartesian: !1,
			requireSorting: !1,
			directTouch: !0,
			noSharedTooltip: !0,
			trackerGroups: ["group", "dataLabelsGroup"],
			axisTypes: [],
			pointAttribs: a.seriesTypes.column.prototype.pointAttribs,
			animate: function(a) {
				var b = this,
					d = b.points,
					f = b.startAngleRad;
				a || (F(d, function(a) {
					var e =
						a.graphic,
						d = a.shapeArgs;
					e &amp;&amp; (e.attr({
						r: a.startR || b.center[3] / 2,
						start: f,
						end: f
					}), e.animate({
						r: d.r,
						start: d.start,
						end: d.end
					}, b.options.animation))
				}), b.animate = null)
			},
			updateTotals: function() {
				var a, d = 0,
					f = this.points,
					g = f.length,
					k, e = this.options.ignoreHiddenPoint;
				for (a = 0; a &lt; g; a++) k = f[a], 0 &gt; k.y &amp;&amp; (k.y = null), d += e &amp;&amp; !k.visible ? 0 : k.y;
				this.total = d;
				for (a = 0; a &lt; g; a++) k = f[a], k.percentage = 0 &lt; d &amp;&amp; (k.visible || !e) ? k.y / d * 100 : 0, k.total = d
			},
			generatePoints: function() {
				l.prototype.generatePoints.call(this);
				this.updateTotals()
			},
			translate: function(a) {
				this.generatePoints();
				var b = 0,
					d = this.options,
					f = d.slicedOffset,
					k = f + (d.borderWidth || 0),
					e, h, l, u = d.startAngle || 0,
					c = this.startAngleRad = Math.PI / 180 * (u - 90),
					u = (this.endAngleRad = Math.PI / 180 * (g(d.endAngle, u + 360) - 90)) - c,
					q = this.points,
					p = d.dataLabels.distance,
					d = d.ignoreHiddenPoint,
					r, v = q.length,
					A;
				a || (this.center = a = this.getCenter());
				this.getX = function(b, c) {
					l = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + p), 1));
					return a[0] + (c ? -1 : 1) * Math.cos(l) * (a[2] / 2 + p)
				};
				for (r = 0; r &lt; v; r++) {
					A = q[r];
					e = c + b * u;
					if (!d || A.visible) b += A.percentage / 100;
					h = c + b * u;
					A.shapeType =
						"arc";
					A.shapeArgs = {
						x: a[0],
						y: a[1],
						r: a[2] / 2,
						innerR: a[3] / 2,
						start: Math.round(1E3 * e) / 1E3,
						end: Math.round(1E3 * h) / 1E3
					};
					l = (h + e) / 2;
					l &gt; 1.5 * Math.PI ? l -= 2 * Math.PI : l &lt; -Math.PI / 2 &amp;&amp; (l += 2 * Math.PI);
					A.slicedTranslation = {
						translateX: Math.round(Math.cos(l) * f),
						translateY: Math.round(Math.sin(l) * f)
					};
					e = Math.cos(l) * a[2] / 2;
					h = Math.sin(l) * a[2] / 2;
					A.tooltipPos = [a[0] + .7 * e, a[1] + .7 * h];
					A.half = l &lt; -Math.PI / 2 || l &gt; Math.PI / 2 ? 1 : 0;
					A.angle = l;
					k = Math.min(k, p / 5);
					A.labelPos = [a[0] + e + Math.cos(l) * p, a[1] + h + Math.sin(l) * p, a[0] + e + Math.cos(l) * k, a[1] + h + Math.sin(l) *
						k, a[0] + e, a[1] + h, 0 &gt; p ? "center" : A.half ? "right" : "left", l
					]
				}
			},
			drawGraph: null,
			drawPoints: function() {
				var a = this,
					d = a.chart.renderer,
					f, g, k, e, h = a.options.shadow;
				h &amp;&amp; !a.shadowGroup &amp;&amp; (a.shadowGroup = d.g("shadow").add(a.group));
				F(a.points, function(b) {
					if (null !== b.y) {
						g = b.graphic;
						e = b.shapeArgs;
						f = b.sliced ? b.slicedTranslation : {};
						var l = b.shadowGroup;
						h &amp;&amp; !l &amp;&amp; (l = b.shadowGroup = d.g("shadow").add(a.shadowGroup));
						l &amp;&amp; l.attr(f);
						k = a.pointAttribs(b, b.selected &amp;&amp; "select");
						g ? g.setRadialReference(a.center).attr(k).animate(H(e, f)) : (b.graphic =
							g = d[b.shapeType](e).addClass(b.getClassName()).setRadialReference(a.center).attr(f).add(a.group), b.visible || g.attr({
								visibility: "hidden"
							}), g.attr(k).attr({
								"stroke-linejoin": "round"
							}).shadow(h, l))
					}
				})
			},
			searchPoint: d,
			sortByAngle: function(a, d) {
				a.sort(function(a, b) {
					return void 0 !== a.angle &amp;&amp; (b.angle - a.angle) * d
				})
			},
			drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
			getCenter: a.CenteredSeriesMixin.getCenter,
			getSymbol: d
		}, {
			init: function() {
				v.prototype.init.apply(this, arguments);
				var a = this,
					d;
				a.name = g(a.name, "Slice");
				d = function(b) {
					a.slice("select" === b.type)
				};
				E(a, "select", d);
				E(a, "unselect", d);
				return a
			},
			setVisible: function(a, d) {
				var b = this,
					f = b.series,
					k = f.chart,
					e = f.options.ignoreHiddenPoint;
				d = g(d, e);
				a !== b.visible &amp;&amp; (b.visible = b.options.visible = a = void 0 === a ? !b.visible : a, f.options.data[p(b, f.data)] = b.options, F(["graphic", "dataLabel", "connector", "shadowGroup"], function(e) {
					if (b[e]) b[e][a ? "show" : "hide"](!0)
				}), b.legendItem &amp;&amp; k.legend.colorizeItem(b, a), a || "hover" !== b.state || b.setState(""), e &amp;&amp; (f.isDirty = !0), d &amp;&amp; k.redraw())
			},
			slice: function(a, d, l) {
				var b = this.series;
				f(l, b.chart);
				g(d, !0);
				this.sliced = this.options.sliced = a = A(a) ? a : !this.sliced;
				b.options.data[p(this, b.data)] = this.options;
				a = a ? this.slicedTranslation : {
					translateX: 0,
					translateY: 0
				};
				this.graphic.animate(a);
				this.shadowGroup &amp;&amp; this.shadowGroup.animate(a)
			},
			haloPath: function(a) {
				var b = this.shapeArgs;
				return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(b.x, b.y, b.r + a, b.r + a, {
					innerR: this.shapeArgs.r,
					start: b.start,
					end: b.end
				})
			}
		})
	})(M);
	(function(a) {
		var E =
			a.addEvent,
			A = a.arrayMax,
			F = a.defined,
			H = a.each,
			p = a.extend,
			d = a.format,
			g = a.map,
			v = a.merge,
			l = a.noop,
			r = a.pick,
			f = a.relativeLength,
			b = a.Series,
			n = a.seriesTypes,
			w = a.stableSort;
		a.distribute = function(a, b) {
			function e(a, b) {
				return a.target - b.target
			}
			var d, f = !0,
				k = a,
				c = [],
				l;
			l = 0;
			for (d = a.length; d--;) l += a[d].size;
			if (l &gt; b) {
				w(a, function(a, b) {
					return (b.rank || 0) - (a.rank || 0)
				});
				for (l = d = 0; l &lt;= b;) l += a[d].size, d++;
				c = a.splice(d - 1, a.length)
			}
			w(a, e);
			for (a = g(a, function(a) {
					return {
						size: a.size,
						targets: [a.target]
					}
				}); f;) {
				for (d = a.length; d--;) f =
					a[d], l = (Math.min.apply(0, f.targets) + Math.max.apply(0, f.targets)) / 2, f.pos = Math.min(Math.max(0, l - f.size / 2), b - f.size);
				d = a.length;
				for (f = !1; d--;) 0 &lt; d &amp;&amp; a[d - 1].pos + a[d - 1].size &gt; a[d].pos &amp;&amp; (a[d - 1].size += a[d].size, a[d - 1].targets = a[d - 1].targets.concat(a[d].targets), a[d - 1].pos + a[d - 1].size &gt; b &amp;&amp; (a[d - 1].pos = b - a[d - 1].size), a.splice(d, 1), f = !0)
			}
			d = 0;
			H(a, function(a) {
				var b = 0;
				H(a.targets, function() {
					k[d].pos = a.pos + b;
					b += k[d].size;
					d++
				})
			});
			k.push.apply(k, c);
			w(k, e)
		};
		b.prototype.drawDataLabels = function() {
			var a = this,
				b = a.options,
				e = b.dataLabels,
				f = a.points,
				g, l, c = a.hasRendered || 0,
				q, n, w = r(e.defer, !0),
				I = a.chart.renderer;
			if (e.enabled || a._hasPointLabels) a.dlProcessOptions &amp;&amp; a.dlProcessOptions(e), n = a.plotGroup("dataLabelsGroup", "data-labels", w &amp;&amp; !c ? "hidden" : "visible", e.zIndex || 6), w &amp;&amp; (n.attr({
				opacity: +c
			}), c || E(a, "afterAnimate", function() {
				a.visible &amp;&amp; n.show(!0);
				n[b.animation ? "animate" : "attr"]({
					opacity: 1
				}, {
					duration: 200
				})
			})), l = e, H(f, function(c) {
				var f, h = c.dataLabel,
					k, u, m = c.connector,
					t = !0,
					x, w = {};
				g = c.dlOptions || c.options &amp;&amp; c.options.dataLabels;
				f = r(g &amp;&amp; g.enabled, l.enabled) &amp;&amp; null !== c.y;
				if (h &amp;&amp; !f) c.dataLabel = h.destroy();
				else if (f) {
					e = v(l, g);
					x = e.style;
					f = e.rotation;
					k = c.getLabelConfig();
					q = e.format ? d(e.format, k) : e.formatter.call(k, e);
					x.color = r(e.color, x.color, a.color, "#000000");
					if (h) F(q) ? (h.attr({
						text: q
					}), t = !1) : (c.dataLabel = h = h.destroy(), m &amp;&amp; (c.connector = m.destroy()));
					else if (F(q)) {
						h = {
							fill: e.backgroundColor,
							stroke: e.borderColor,
							"stroke-width": e.borderWidth,
							r: e.borderRadius || 0,
							rotation: f,
							padding: e.padding,
							zIndex: 1
						};
						"contrast" === x.color &amp;&amp; (w.color = e.inside ||
							0 &gt; e.distance || b.stacking ? I.getContrast(c.color || a.color) : "#000000");
						b.cursor &amp;&amp; (w.cursor = b.cursor);
						for (u in h) void 0 === h[u] &amp;&amp; delete h[u];
						h = c.dataLabel = I[f ? "text" : "label"](q, 0, -9999, e.shape, null, null, e.useHTML, null, "data-label").attr(h);
						h.addClass("highcharts-data-label-color-" + c.colorIndex + " " + (e.className || "") + (e.useHTML ? "highcharts-tracker" : ""));
						h.css(p(x, w));
						h.add(n);
						h.shadow(e.shadow)
					}
					h &amp;&amp; a.alignDataLabel(c, h, e, null, t)
				}
			})
		};
		b.prototype.alignDataLabel = function(a, b, e, d, f) {
			var g = this.chart,
				c = g.inverted,
				h = r(a.plotX, -9999),
				k = r(a.plotY, -9999),
				l = b.getBBox(),
				n, t = e.rotation,
				v = e.align,
				w = this.visible &amp;&amp; (a.series.forceDL || g.isInsidePlot(h, Math.round(k), c) || d &amp;&amp; g.isInsidePlot(h, c ? d.x + 1 : d.y + d.height - 1, c)),
				A = "justify" === r(e.overflow, "justify");
			w &amp;&amp; (n = e.style.fontSize, n = g.renderer.fontMetrics(n, b).b, d = p({
				x: c ? g.plotWidth - k : h,
				y: Math.round(c ? g.plotHeight - h : k),
				width: 0,
				height: 0
			}, d), p(e, {
				width: l.width,
				height: l.height
			}), t ? (A = !1, c = g.renderer.rotCorr(n, t), c = {
				x: d.x + e.x + d.width / 2 + c.x,
				y: d.y + e.y + {
						top: 0,
						middle: .5,
						bottom: 1
					}[e.verticalAlign] *
					d.height
			}, b[f ? "attr" : "animate"](c).attr({
				align: v
			}), h = (t + 720) % 360, h = 180 &lt; h &amp;&amp; 360 &gt; h, "left" === v ? c.y -= h ? l.height : 0 : "center" === v ? (c.x -= l.width / 2, c.y -= l.height / 2) : "right" === v &amp;&amp; (c.x -= l.width, c.y -= h ? 0 : l.height)) : (b.align(e, null, d), c = b.alignAttr), A ? this.justifyDataLabel(b, e, c, l, d, f) : r(e.crop, !0) &amp;&amp; (w = g.isInsidePlot(c.x, c.y) &amp;&amp; g.isInsidePlot(c.x + l.width, c.y + l.height)), e.shape &amp;&amp; !t &amp;&amp; b.attr({
				anchorX: a.plotX,
				anchorY: a.plotY
			}));
			w || (b.attr({
				y: -9999
			}), b.placed = !1)
		};
		b.prototype.justifyDataLabel = function(a, b, e, d, f, g) {
			var c =
				this.chart,
				h = b.align,
				k = b.verticalAlign,
				l, n, u = a.box ? 0 : a.padding || 0;
			l = e.x + u;
			0 &gt; l &amp;&amp; ("right" === h ? b.align = "left" : b.x = -l, n = !0);
			l = e.x + d.width - u;
			l &gt; c.plotWidth &amp;&amp; ("left" === h ? b.align = "right" : b.x = c.plotWidth - l, n = !0);
			l = e.y + u;
			0 &gt; l &amp;&amp; ("bottom" === k ? b.verticalAlign = "top" : b.y = -l, n = !0);
			l = e.y + d.height - u;
			l &gt; c.plotHeight &amp;&amp; ("top" === k ? b.verticalAlign = "bottom" : b.y = c.plotHeight - l, n = !0);
			n &amp;&amp; (a.placed = !g, a.align(b, null, f))
		};
		n.pie &amp;&amp; (n.pie.prototype.drawDataLabels = function() {
			var d = this,
				f = d.data,
				e, h = d.chart,
				l = d.options.dataLabels,
				n =
				r(l.connectorPadding, 10),
				c = r(l.connectorWidth, 1),
				q = h.plotWidth,
				p = h.plotHeight,
				v, w = l.distance,
				E = d.center,
				D = E[2] / 2,
				G = E[1],
				F = 0 &lt; w,
				N, m, z, O, M = [
					[],
					[]
				],
				y, B, Q, R, S = [0, 0, 0, 0];
			d.visible &amp;&amp; (l.enabled || d._hasPointLabels) &amp;&amp; (b.prototype.drawDataLabels.apply(d), H(f, function(a) {
				a.dataLabel &amp;&amp; a.visible &amp;&amp; (M[a.half].push(a), a.dataLabel._pos = null)
			}), H(M, function(b, c) {
				var f, k, u = b.length,
					r, t, v;
				if (u)
					for (d.sortByAngle(b, c - .5), 0 &lt; w &amp;&amp; (f = Math.max(0, G - D - w), k = Math.min(G + D + w, h.plotHeight), r = g(b, function(a) {
							if (a.dataLabel) return v =
								a.dataLabel.getBBox().height || 21, {
									target: a.labelPos[1] - f + v / 2,
									size: v,
									rank: a.y
								}
						}), a.distribute(r, k + v - f)), R = 0; R &lt; u; R++) e = b[R], z = e.labelPos, N = e.dataLabel, Q = !1 === e.visible ? "hidden" : "inherit", t = z[1], r ? void 0 === r[R].pos ? Q = "hidden" : (O = r[R].size, B = f + r[R].pos) : B = t, y = l.justify ? E[0] + (c ? -1 : 1) * (D + w) : d.getX(B &lt; f + 2 || B &gt; k - 2 ? t : B, c), N._attr = {
						visibility: Q,
						align: z[6]
					}, N._pos = {
						x: y + l.x + ({
							left: n,
							right: -n
						}[z[6]] || 0),
						y: B + l.y - 10
					}, z.x = y, z.y = B, null === d.options.size &amp;&amp; (m = N.width, y - m &lt; n ? S[3] = Math.max(Math.round(m - y + n), S[3]) : y + m &gt; q - n &amp;&amp;
						(S[1] = Math.max(Math.round(y + m - q + n), S[1])), 0 &gt; B - O / 2 ? S[0] = Math.max(Math.round(-B + O / 2), S[0]) : B + O / 2 &gt; p &amp;&amp; (S[2] = Math.max(Math.round(B + O / 2 - p), S[2])))
			}), 0 === A(S) || this.verifyDataLabelOverflow(S)) &amp;&amp; (this.placeDataLabels(), F &amp;&amp; c &amp;&amp; H(this.points, function(a) {
				var b;
				v = a.connector;
				if ((N = a.dataLabel) &amp;&amp; N._pos &amp;&amp; a.visible) {
					Q = N._attr.visibility;
					if (b = !v) a.connector = v = h.renderer.path().addClass("highcharts-data-label-connector highcharts-color-" + a.colorIndex).add(d.dataLabelsGroup), v.attr({
						"stroke-width": c,
						stroke: l.connectorColor ||
							a.color || "#666666"
					});
					v[b ? "attr" : "animate"]({
						d: d.connectorPath(a.labelPos)
					});
					v.attr("visibility", Q)
				} else v &amp;&amp; (a.connector = v.destroy())
			}))
		}, n.pie.prototype.connectorPath = function(a) {
			var b = a.x,
				d = a.y;
			return r(this.options.dataLabels.softConnector, !0) ? ["M", b + ("left" === a[6] ? 5 : -5), d, "C", b, d, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], "L", a[4], a[5]] : ["M", b + ("left" === a[6] ? 5 : -5), d, "L", a[2], a[3], "L", a[4], a[5]]
		}, n.pie.prototype.placeDataLabels = function() {
			H(this.points, function(a) {
				var b = a.dataLabel;
				b &amp;&amp; a.visible &amp;&amp; ((a = b._pos) ?
					(b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), b.moved = !0) : b &amp;&amp; b.attr({
						y: -9999
					}))
			})
		}, n.pie.prototype.alignDataLabel = l, n.pie.prototype.verifyDataLabelOverflow = function(a) {
			var b = this.center,
				d = this.options,
				g = d.center,
				l = d.minSize || 80,
				n, c;
			null !== g[0] ? n = Math.max(b[2] - Math.max(a[1], a[3]), l) : (n = Math.max(b[2] - a[1] - a[3], l), b[0] += (a[3] - a[1]) / 2);
			null !== g[1] ? n = Math.max(Math.min(n, b[2] - Math.max(a[0], a[2])), l) : (n = Math.max(Math.min(n, b[2] - a[0] - a[2]), l), b[1] += (a[0] - a[2]) / 2);
			n &lt; b[2] ? (b[2] = n, b[3] = Math.min(f(d.innerSize ||
				0, n), n), this.translate(b), this.drawDataLabels &amp;&amp; this.drawDataLabels()) : c = !0;
			return c
		});
		n.column &amp;&amp; (n.column.prototype.alignDataLabel = function(a, d, e, f, g) {
			var h = this.chart.inverted,
				c = a.series,
				k = a.dlBox || a.shapeArgs,
				l = r(a.below, a.plotY &gt; r(this.translatedThreshold, c.yAxis.len)),
				n = r(e.inside, !!this.options.stacking);
			k &amp;&amp; (f = v(k), 0 &gt; f.y &amp;&amp; (f.height += f.y, f.y = 0), k = f.y + f.height - c.yAxis.len, 0 &lt; k &amp;&amp; (f.height -= k), h &amp;&amp; (f = {
				x: c.yAxis.len - f.y - f.height,
				y: c.xAxis.len - f.x - f.width,
				width: f.height,
				height: f.width
			}), n || (h ? (f.x += l ?
				0 : f.width, f.width = 0) : (f.y += l ? f.height : 0, f.height = 0)));
			e.align = r(e.align, !h || n ? "center" : l ? "right" : "left");
			e.verticalAlign = r(e.verticalAlign, h || n ? "middle" : l ? "top" : "bottom");
			b.prototype.alignDataLabel.call(this, a, d, e, f, g)
		})
	})(M);
	(function(a) {
		var E = a.Chart,
			A = a.each,
			F = a.pick,
			H = a.addEvent;
		E.prototype.callbacks.push(function(a) {
			function d() {
				var d = [];
				A(a.series, function(a) {
					var g = a.options.dataLabels,
						p = a.dataLabelCollections || ["dataLabel"];
					(g.enabled || a._hasPointLabels) &amp;&amp; !g.allowOverlap &amp;&amp; a.visible &amp;&amp; A(p, function(f) {
						A(a.points,
							function(a) {
								a[f] &amp;&amp; (a[f].labelrank = F(a.labelrank, a.shapeArgs &amp;&amp; a.shapeArgs.height), d.push(a[f]))
							})
					})
				});
				a.hideOverlappingLabels(d)
			}
			d();
			H(a, "redraw", d)
		});
		E.prototype.hideOverlappingLabels = function(a) {
			var d = a.length,
				g, p, l, r, f, b, n, w, t, k = function(a, b, d, f, c, g, k, l) {
					return !(c &gt; a + d || c + k &lt; a || g &gt; b + f || g + l &lt; b)
				};
			for (p = 0; p &lt; d; p++)
				if (g = a[p]) g.oldOpacity = g.opacity, g.newOpacity = 1;
			a.sort(function(a, b) {
				return (b.labelrank || 0) - (a.labelrank || 0)
			});
			for (p = 0; p &lt; d; p++)
				for (l = a[p], g = p + 1; g &lt; d; ++g)
					if (r = a[g], l &amp;&amp; r &amp;&amp; l.placed &amp;&amp; r.placed &amp;&amp; 0 !==
						l.newOpacity &amp;&amp; 0 !== r.newOpacity &amp;&amp; (f = l.alignAttr, b = r.alignAttr, n = l.parentGroup, w = r.parentGroup, t = 2 * (l.box ? 0 : l.padding), f = k(f.x + n.translateX, f.y + n.translateY, l.width - t, l.height - t, b.x + w.translateX, b.y + w.translateY, r.width - t, r.height - t)))(l.labelrank &lt; r.labelrank ? l : r).newOpacity = 0;
			A(a, function(a) {
				var b, d;
				a &amp;&amp; (d = a.newOpacity, a.oldOpacity !== d &amp;&amp; a.placed &amp;&amp; (d ? a.show(!0) : b = function() {
					a.hide()
				}, a.alignAttr.opacity = d, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b)), a.isOld = !0)
			})
		}
	})(M);
	(function(a) {
		var E = a.addEvent,
			A = a.Chart,
			F = a.createElement,
			H = a.css,
			p = a.defaultOptions,
			d = a.defaultPlotOptions,
			g = a.each,
			v = a.extend,
			l = a.fireEvent,
			r = a.hasTouch,
			f = a.inArray,
			b = a.isObject,
			n = a.Legend,
			w = a.merge,
			t = a.pick,
			k = a.Point,
			e = a.Series,
			h = a.seriesTypes,
			C = a.svg;
		a = a.TrackerMixin = {
			drawTrackerPoint: function() {
				var a = this,
					b = a.chart,
					d = b.pointer,
					e = function(a) {
						for (var c = a.target, d; c &amp;&amp; !d;) d = c.point, c = c.parentNode;
						if (void 0 !== d &amp;&amp; d !== b.hoverPoint) d.onMouseOver(a)
					};
				g(a.points, function(a) {
					a.graphic &amp;&amp; (a.graphic.element.point = a);
					a.dataLabel &amp;&amp; (a.dataLabel.div ?
						a.dataLabel.div.point = a : a.dataLabel.element.point = a)
				});
				a._hasTracking || (g(a.trackerGroups, function(b) {
					if (a[b]) {
						a[b].addClass("highcharts-tracker").on("mouseover", e).on("mouseout", function(a) {
							d.onTrackerMouseOut(a)
						});
						if (r) a[b].on("touchstart", e);
						a.options.cursor &amp;&amp; a[b].css(H).css({
							cursor: a.options.cursor
						})
					}
				}), a._hasTracking = !0)
			},
			drawTrackerGraph: function() {
				var a = this,
					b = a.options,
					d = b.trackByArea,
					e = [].concat(d ? a.areaPath : a.graphPath),
					f = e.length,
					h = a.chart,
					k = h.pointer,
					l = h.renderer,
					n = h.options.tooltip.snap,
					p = a.tracker,
					t, m = function() {
						if (h.hoverSeries !== a) a.onMouseOver()
					},
					v = "rgba(192,192,192," + (C ? .0001 : .002) + ")";
				if (f &amp;&amp; !d)
					for (t = f + 1; t--;) "M" === e[t] &amp;&amp; e.splice(t + 1, 0, e[t + 1] - n, e[t + 2], "L"), (t &amp;&amp; "M" === e[t] || t === f) &amp;&amp; e.splice(t, 0, "L", e[t - 2] + n, e[t - 1]);
				p ? p.attr({
					d: e
				}) : a.graph &amp;&amp; (a.tracker = l.path(e).attr({
					"stroke-linejoin": "round",
					visibility: a.visible ? "visible" : "hidden",
					stroke: v,
					fill: d ? v : "none",
					"stroke-width": a.graph.strokeWidth() + (d ? 0 : 2 * n),
					zIndex: 2
				}).add(a.group), g([a.tracker, a.markerGroup], function(a) {
					a.addClass("highcharts-tracker").on("mouseover",
						m).on("mouseout", function(a) {
						k.onTrackerMouseOut(a)
					});
					b.cursor &amp;&amp; a.css({
						cursor: b.cursor
					});
					if (r) a.on("touchstart", m)
				}))
			}
		};
		h.column &amp;&amp; (h.column.prototype.drawTracker = a.drawTrackerPoint);
		h.pie &amp;&amp; (h.pie.prototype.drawTracker = a.drawTrackerPoint);
		h.scatter &amp;&amp; (h.scatter.prototype.drawTracker = a.drawTrackerPoint);
		v(n.prototype, {
			setItemEvents: function(a, b, d) {
				var c = this,
					e = c.chart,
					f = "highcharts-legend-" + (a.series ? "point" : "series") + "-active";
				(d ? b : a.legendGroup).on("mouseover", function() {
					a.setState("hover");
					e.seriesGroup.addClass(f);
					b.css(c.options.itemHoverStyle)
				}).on("mouseout", function() {
					b.css(a.visible ? c.itemStyle : c.itemHiddenStyle);
					e.seriesGroup.removeClass(f);
					a.setState()
				}).on("click", function(b) {
					var c = function() {
						a.setVisible &amp;&amp; a.setVisible()
					};
					b = {
						browserEvent: b
					};
					a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : l(a, "legendItemClick", b, c)
				})
			},
			createCheckboxForItem: function(a) {
				a.checkbox = F("input", {
					type: "checkbox",
					checked: a.selected,
					defaultChecked: a.selected
				}, this.options.itemCheckboxStyle, this.chart.container);
				E(a.checkbox,
					"click",
					function(b) {
						l(a.series || a, "checkboxClick", {
							checked: b.target.checked,
							item: a
						}, function() {
							a.select()
						})
					})
			}
		});
		p.legend.itemStyle.cursor = "pointer";
		v(A.prototype, {
			showResetZoom: function() {
				var a = this,
					b = p.lang,
					d = a.options.chart.resetZoomButton,
					e = d.theme,
					f = e.states,
					g = "chart" === d.relativeTo ? null : "plotBox";
				this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function() {
					a.zoomOut()
				}, e, f &amp;&amp; f.hover).attr({
					align: d.position.align,
					title: b.resetZoomTitle
				}).addClass("highcharts-reset-zoom").add().align(d.position, !1, g)
			},
			zoomOut: function() {
				var a = this;
				l(a, "selection", {
					resetSelection: !0
				}, function() {
					a.zoom()
				})
			},
			zoom: function(a) {
				var c, d = this.pointer,
					e = !1,
					f;
				!a || a.resetSelection ? g(this.axes, function(a) {
					c = a.zoom()
				}) : g(a.xAxis.concat(a.yAxis), function(a) {
					var b = a.axis;
					d[b.isXAxis ? "zoomX" : "zoomY"] &amp;&amp; (c = b.zoom(a.min, a.max), b.displayBtn &amp;&amp; (e = !0))
				});
				f = this.resetZoomButton;
				e &amp;&amp; !f ? this.showResetZoom() : !e &amp;&amp; b(f) &amp;&amp; (this.resetZoomButton = f.destroy());
				c &amp;&amp; this.redraw(t(this.options.chart.animation, a &amp;&amp; a.animation, 100 &gt; this.pointCount))
			},
			pan: function(a, b) {
				var c = this,
					d = c.hoverPoints,
					e;
				d &amp;&amp; g(d, function(a) {
					a.setState()
				});
				g("xy" === b ? [1, 0] : [1], function(b) {
					b = c[b ? "xAxis" : "yAxis"][0];
					var d = b.horiz,
						f = b.reversed,
						g = a[d ? "chartX" : "chartY"],
						d = d ? "mouseDownX" : "mouseDownY",
						h = c[d],
						k = (b.pointRange || 0) / (f ? -2 : 2),
						l = b.getExtremes(),
						n = b.toValue(h - g, !0) + k,
						k = b.toValue(h + b.len - g, !0) - k,
						h = h &gt; g;
					f &amp;&amp; (h = !h, f = n, n = k, k = f);
					b.series.length &amp;&amp; (h || n &gt; Math.min(l.dataMin, l.min)) &amp;&amp; (!h || k &lt; Math.max(l.dataMax, l.max)) &amp;&amp; (b.setExtremes(n, k, !1, !1, {
						trigger: "pan"
					}), e = !0);
					c[d] = g
				});
				e &amp;&amp; c.redraw(!1);
				H(c.container, {
					cursor: "move"
				})
			}
		});
		v(k.prototype, {
			select: function(a, b) {
				var c = this,
					d = c.series,
					e = d.chart;
				a = t(a, !c.selected);
				c.firePointEvent(a ? "select" : "unselect", {
					accumulate: b
				}, function() {
					c.selected = c.options.selected = a;
					d.options.data[f(c, d.data)] = c.options;
					c.setState(a &amp;&amp; "select");
					b || g(e.getSelectedPoints(), function(a) {
						a.selected &amp;&amp; a !== c &amp;&amp; (a.selected = a.options.selected = !1, d.options.data[f(a, d.data)] = a.options, a.setState(""), a.firePointEvent("unselect"))
					})
				})
			},
			onMouseOver: function(a, b) {
				var c = this.series,
					d = c.chart,
					e = d.tooltip,
					f = d.hoverPoint;
				if (this.series) {
					if (!b) {
						if (f &amp;&amp; f !== this) f.onMouseOut();
						if (d.hoverSeries !== c) c.onMouseOver();
						d.hoverPoint = this
					}!e || e.shared &amp;&amp; !c.noSharedTooltip ? e || this.setState("hover") : (this.setState("hover"), e.refresh(this, a));
					this.firePointEvent("mouseOver")
				}
			},
			onMouseOut: function() {
				var a = this.series.chart,
					b = a.hoverPoints;
				this.firePointEvent("mouseOut");
				b &amp;&amp; -1 !== f(this, b) || (this.setState(), a.hoverPoint = null)
			},
			importEvents: function() {
				if (!this.hasImportedEvents) {
					var a = w(this.series.options.point,
							this.options).events,
						b;
					this.events = a;
					for (b in a) E(this, b, a[b]);
					this.hasImportedEvents = !0
				}
			},
			setState: function(a, b) {
				var c = Math.floor(this.plotX),
					e = this.plotY,
					f = this.series,
					g = f.options.states[a] || {},
					h = d[f.type].marker &amp;&amp; f.options.marker,
					k = h &amp;&amp; !1 === h.enabled,
					l = h &amp;&amp; h.states &amp;&amp; h.states[a] || {},
					n = !1 === l.enabled,
					p = f.stateMarkerGraphic,
					m = this.marker || {},
					r = f.chart,
					u = f.halo,
					w, y = h &amp;&amp; f.markerAttribs;
				a = a || "";
				if (!(a === this.state &amp;&amp; !b || this.selected &amp;&amp; "select" !== a || !1 === g.enabled || a &amp;&amp; (n || k &amp;&amp; !1 === l.enabled) || a &amp;&amp; m.states &amp;&amp;
						m.states[a] &amp;&amp; !1 === m.states[a].enabled)) {
					y &amp;&amp; (w = f.markerAttribs(this, a));
					if (this.graphic) this.state &amp;&amp; this.graphic.removeClass("highcharts-point-" + this.state), a &amp;&amp; this.graphic.addClass("highcharts-point-" + a), this.graphic.attr(f.pointAttribs(this, a)), w &amp;&amp; this.graphic.animate(w, t(r.options.chart.animation, l.animation, h.animation)), p &amp;&amp; p.hide();
					else {
						if (a &amp;&amp; l) {
							h = m.symbol || f.symbol;
							p &amp;&amp; p.currentSymbol !== h &amp;&amp; (p = p.destroy());
							if (p) p[b ? "animate" : "attr"]({
								x: w.x,
								y: w.y
							});
							else h &amp;&amp; (f.stateMarkerGraphic = p = r.renderer.symbol(h,
								w.x, w.y, w.width, w.height).add(f.markerGroup), p.currentSymbol = h);
							p &amp;&amp; p.attr(f.pointAttribs(this, a))
						}
						p &amp;&amp; (p[a &amp;&amp; r.isInsidePlot(c, e, r.inverted) ? "show" : "hide"](), p.element.point = this)
					}(c = g.halo) &amp;&amp; c.size ? (u || (f.halo = u = r.renderer.path().add(y ? f.markerGroup : f.group)), u[b ? "animate" : "attr"]({
						d: this.haloPath(c.size)
					}), u.attr({
						"class": "highcharts-halo highcharts-color-" + t(this.colorIndex, f.colorIndex)
					}), u.attr(v({
						fill: this.color || f.color,
						"fill-opacity": c.opacity,
						zIndex: -1
					}, c.attributes))) : u &amp;&amp; u.animate({
						d: this.haloPath(0)
					});
					this.state = a
				}
			},
			haloPath: function(a) {
				return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a)
			}
		});
		v(e.prototype, {
			onMouseOver: function() {
				var a = this.chart,
					b = a.hoverSeries;
				if (b &amp;&amp; b !== this) b.onMouseOut();
				this.options.events.mouseOver &amp;&amp; l(this, "mouseOver");
				this.setState("hover");
				a.hoverSeries = this
			},
			onMouseOut: function() {
				var a = this.options,
					b = this.chart,
					d = b.tooltip,
					e = b.hoverPoint;
				b.hoverSeries = null;
				if (e) e.onMouseOut();
				this &amp;&amp; a.events.mouseOut &amp;&amp; l(this, "mouseOut");
				!d || a.stickyTracking ||
					d.shared &amp;&amp; !this.noSharedTooltip || d.hide();
				this.setState()
			},
			setState: function(a) {
				var b = this,
					d = b.options,
					e = b.graph,
					f = d.states,
					h = d.lineWidth,
					d = 0;
				a = a || "";
				if (b.state !== a &amp;&amp; (g([b.group, b.markerGroup], function(c) {
						c &amp;&amp; (b.state &amp;&amp; c.removeClass("highcharts-series-" + b.state), a &amp;&amp; c.addClass("highcharts-series-" + a))
					}), b.state = a, !f[a] || !1 !== f[a].enabled) &amp;&amp; (a &amp;&amp; (h = f[a].lineWidth || h + (f[a].lineWidthPlus || 0)), e &amp;&amp; !e.dashstyle))
					for (f = {
							"stroke-width": h
						}, e.attr(f); b["zone-graph-" + d];) b["zone-graph-" + d].attr(f), d += 1
			},
			setVisible: function(a,
				b) {
				var c = this,
					d = c.chart,
					e = c.legendItem,
					f, h = d.options.chart.ignoreHiddenSeries,
					k = c.visible;
				f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !k : a) ? "show" : "hide";
				g(["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"], function(a) {
					if (c[a]) c[a][f]()
				});
				if (d.hoverSeries === c || (d.hoverPoint &amp;&amp; d.hoverPoint.series) === c) c.onMouseOut();
				e &amp;&amp; d.legend.colorizeItem(c, a);
				c.isDirty = !0;
				c.options.stacking &amp;&amp; g(d.series, function(a) {
					a.options.stacking &amp;&amp; a.visible &amp;&amp; (a.isDirty = !0)
				});
				g(c.linkedSeries, function(b) {
					b.setVisible(a, !1)
				});
				h &amp;&amp; (d.isDirtyBox = !0);
				!1 !== b &amp;&amp; d.redraw();
				l(c, f)
			},
			show: function() {
				this.setVisible(!0)
			},
			hide: function() {
				this.setVisible(!1)
			},
			select: function(a) {
				this.selected = a = void 0 === a ? !this.selected : a;
				this.checkbox &amp;&amp; (this.checkbox.checked = a);
				l(this, a ? "select" : "unselect")
			},
			drawTracker: a.drawTrackerGraph
		})
	})(M);
	(function(a) {
		var E = a.Chart,
			A = a.each,
			F = a.inArray,
			H = a.isObject,
			p = a.pick,
			d = a.splat;
		E.prototype.setResponsive = function(a) {
			var d = this.options.responsive;
			d &amp;&amp; d.rules &amp;&amp; A(d.rules, function(d) {
				this.matchResponsiveRule(d,
					a)
			}, this)
		};
		E.prototype.matchResponsiveRule = function(d, v) {
			var g = this.respRules,
				r = d.condition,
				f;
			f = r.callback || function() {
				return this.chartWidth &lt;= p(r.maxWidth, Number.MAX_VALUE) &amp;&amp; this.chartHeight &lt;= p(r.maxHeight, Number.MAX_VALUE) &amp;&amp; this.chartWidth &gt;= p(r.minWidth, 0) &amp;&amp; this.chartHeight &gt;= p(r.minHeight, 0)
			};
			void 0 === d._id &amp;&amp; (d._id = a.uniqueKey());
			f = f.call(this);
			!g[d._id] &amp;&amp; f ? d.chartOptions &amp;&amp; (g[d._id] = this.currentOptions(d.chartOptions), this.update(d.chartOptions, v)) : g[d._id] &amp;&amp; !f &amp;&amp; (this.update(g[d._id], v), delete g[d._id])
		};
		E.prototype.currentOptions = function(a) {
			function g(a, f, b) {
				var l, p;
				for (l in a)
					if (-1 &lt; F(l, ["series", "xAxis", "yAxis"]))
						for (a[l] = d(a[l]), b[l] = [], p = 0; p &lt; a[l].length; p++) b[l][p] = {}, g(a[l][p], f[l][p], b[l][p]);
					else H(a[l]) ? (b[l] = {}, g(a[l], f[l] || {}, b[l])) : b[l] = f[l] || null
			}
			var l = {};
			g(a, this.options, l);
			return l
		}
	})(M);
	return M
});]]&gt;&lt;/script&gt;&lt;script_name/&gt;&lt;sys_class_name&gt;sys_ui_script&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-08 21:52:54&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;true&lt;/sys_customer_update&gt;&lt;sys_id&gt;5752058bdbd53200f687dfea5e9619f8&lt;/sys_id&gt;&lt;sys_mod_count&gt;3&lt;/sys_mod_count&gt;&lt;sys_name&gt;PE Highcharts 5_0_5&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_ui_script_5752058bdbd53200f687dfea5e9619f8&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 06:09:37&lt;/sys_updated_on&gt;&lt;use_scoped_format&gt;false&lt;/use_scoped_format&gt;&lt;/sys_ui_script&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>efdbb59fdbd532002e5df2b6ae9619c6</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Highcharts 5_0_5</target_name>
<type>UI Script</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
<sys_update_xml action="INSERT_OR_UPDATE">
<action>INSERT_OR_UPDATE</action>
<application display_value="Global">global</application>
<category>customer</category>
<comments/>
<name>sys_ws_operation_a9fc960bdbd932002e5df2b6ae961971</name>
<payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_ws_operation"&gt;&lt;sys_ws_operation action="INSERT_OR_UPDATE"&gt;&lt;active&gt;true&lt;/active&gt;&lt;consumes&gt;application/json,application/xml,text/xml&lt;/consumes&gt;&lt;consumes_customized&gt;false&lt;/consumes_customized&gt;&lt;default_operation_uri/&gt;&lt;enforce_acl/&gt;&lt;http_method&gt;GET&lt;/http_method&gt;&lt;name&gt;PE Get Data&lt;/name&gt;&lt;operation_script&gt;&lt;![CDATA[(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {
	var highchartsHelper = new PEHighchartsHelper(request,response);
	return highchartsHelper.process();
})(request, response);]]&gt;&lt;/operation_script&gt;&lt;operation_uri&gt;/api/snc/pe_highcharts_helper/get_data&lt;/operation_uri&gt;&lt;produces&gt;application/json,application/xml,text/xml&lt;/produces&gt;&lt;produces_customized&gt;false&lt;/produces_customized&gt;&lt;relative_path&gt;/get_data&lt;/relative_path&gt;&lt;request_example/&gt;&lt;requires_acl_authorization&gt;false&lt;/requires_acl_authorization&gt;&lt;requires_authentication&gt;true&lt;/requires_authentication&gt;&lt;short_description/&gt;&lt;sys_class_name&gt;sys_ws_operation&lt;/sys_class_name&gt;&lt;sys_created_by&gt;dachtman&lt;/sys_created_by&gt;&lt;sys_created_on&gt;2017-03-09 04:30:39&lt;/sys_created_on&gt;&lt;sys_customer_update&gt;true&lt;/sys_customer_update&gt;&lt;sys_id&gt;a9fc960bdbd932002e5df2b6ae961971&lt;/sys_id&gt;&lt;sys_mod_count&gt;1&lt;/sys_mod_count&gt;&lt;sys_name&gt;PE Get Data&lt;/sys_name&gt;&lt;sys_package display_value="Global" source="global"&gt;global&lt;/sys_package&gt;&lt;sys_policy/&gt;&lt;sys_replace_on_upgrade&gt;false&lt;/sys_replace_on_upgrade&gt;&lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;&lt;sys_update_name&gt;sys_ws_operation_a9fc960bdbd932002e5df2b6ae961971&lt;/sys_update_name&gt;&lt;sys_updated_by&gt;dachtman&lt;/sys_updated_by&gt;&lt;sys_updated_on&gt;2017-03-09 04:31:07&lt;/sys_updated_on&gt;&lt;web_service_definition display_value="PE Highcharts Helper"&gt;226c520bdbd932002e5df2b6ae961978&lt;/web_service_definition&gt;&lt;web_service_version/&gt;&lt;/sys_ws_operation&gt;&lt;/record_update&gt;</payload>
<remote_update_set display_value="PE Highcharts - Bar Chart">a3dbb59fdbd532002e5df2b6ae9619c3</remote_update_set>
<replace_on_upgrade>false</replace_on_upgrade>
<sys_created_by>dachtman</sys_created_by>
<sys_created_on>2017-03-09 20:42:37</sys_created_on>
<sys_id>fbdbb59fdbd532002e5df2b6ae9619c7</sys_id>
<sys_mod_count>0</sys_mod_count>
<sys_updated_by>dachtman</sys_updated_by>
<sys_updated_on>2017-03-09 20:42:37</sys_updated_on>
<table/>
<target_name>PE Get Data</target_name>
<type>Scripted REST Resource</type>
<update_domain>global</update_domain>
<update_set display_value=""/>
<view/>
</sys_update_xml>
</unload>
