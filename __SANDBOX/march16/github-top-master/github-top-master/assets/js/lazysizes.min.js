/*! lazysizes - v5.2.0-beta1 */ global();
function global () {
  !( ( a, b ) => {
    const c = b( a, a.document );
    a.lazySizes = c, "object" == typeof module && module.exports && ( module.exports = c );
  } )( "undefined" != typeof window ? window : {}, ( a, b ) => {
    "use strict";
    let c, d;
    if ( ( () => {
      let b;

      const c = {
        lazyClass: "lazyload",
        loadedClass: "lazyloaded",
        loadingClass: "lazyloading",
        preloadClass: "lazypreload",
        errorClass: "lazyerror",
        autosizesClass: "lazyautosizes",
        srcAttr: "data-src",
        srcsetAttr: "data-srcset",
        sizesAttr: "data-sizes",
        minSize: 40,
        customMedia: {},
        init: !0,
        expFactor: 1.5,
        hFac: .8,
        loadMode: 2,
        loadHidden: !0,
        ricTimeout: 0,
        throttleDelay: 125
      };

      d = a.lazySizesConfig || a.lazysizesConfig || {};
      for ( b in c )
        b in d || ( d[ b ] = c[ b ] );
    } )(), !b || !b.getElementsByClassName )
      return {
        init () { },
        cfg: d,
        noSupport: !0
      };
    const e = b.documentElement,
      f = a.Date,
      g = a.HTMLPictureElement,
      h = "addEventListener",
      i = "getAttribute",
      j = a[ h ],
      k = a.setTimeout,
      l = a.requestAnimationFrame || k,
      m = a.requestIdleCallback,
      n = /^picture$/i,
      o = [ "load", "error", "lazyincluded", "_lazyloaded" ],
      p = {},
      q = Array.prototype.forEach,
      r = ( a, b ) => {
        return p[ b ] || ( p[ b ] = new RegExp( "(\\s|^)" + b + "(\\s|$)" ) ), p[ b ].test( a[ i ]( "class" ) || "" ) && p[ b ];
      },
      s = ( a, b ) => {
        r( a, b ) || a.setAttribute( "class", ( a[ i ]( "class" ) || "" ).trim() + " " + b );
      },
      t = ( a, b ) => {
        let c;
        ( c = r( a, b ) ) && a.setAttribute( "class", ( a[ i ]( "class" ) || "" ).replace( c, " " ) );
      },
      u = ( a, b, c ) => {
        const d = c ? h : "removeEventListener";
        c && u( a, b ), o.forEach( c => {
          a[ d ]( c, b );
        } );
      },
      v = ( a, d, e, f, g ) => {
        const h = b.createEvent( "Event" );
        return e || ( e = {} ), e.instance = c, h.initEvent( d, !f, !g ), h.detail = e, a.dispatchEvent( h ), h;
      },
      w = ( b, c ) => {
        let e;
        !g && ( e = a.picturefill || d.pf ) ? ( c && c.src && !b[ i ]( "srcset" ) && b.setAttribute( "srcset", c.src ), e( {
          reevaluate: !0,
          elements: [ b ]
        } ) ) : c && c.src && ( b.src = c.src );
      },
      x = ( a, b ) => {
        return ( getComputedStyle( a, null ) || {} )[ b ];
      },
      y = ( a, b, c ) => {
        for ( c = c || a.offsetWidth; c < d.minSize && b && !a._lazysizesWidth; )
          c = b.offsetWidth, b = b.parentNode;
        return c;
      },
      z = ( () => {
        let a;
        let c;
        const d = [];
        const e = [];
        let f = d;

        const g = () => {
          const b = f;
          for ( f = d.length ? e : d, a = !0, c = !1; b.length; )
            b.shift()();
          a = !1;
        };

        const h = function ( d, e ) {
          a && !e ? d.apply( this, arguments ) : ( f.push( d ), c || ( c = !0, ( b.hidden ? k : l )( g ) ) );
        };

        return h._lsFlush = g, h;
      } )(),
      A = ( a, b ) => {
        return b ? () => {
          z( a );
        } : function ( ...args ) {
          const b = this, c = args;
          z( () => {
            a.apply( b, c );
          } );
        };
      },
      B = a => {
        let b;
        let c = 0;
        const e = d.throttleDelay;
        let g = d.ricTimeout;

        const h = () => {
          b = !1, c = f.now(), a();
        };

        const i = m && g > 49 ? () => {
          m( h, {
            timeout: g
          } ), g !== d.ricTimeout && ( g = d.ricTimeout );
        } : A( () => {
          k( h );
        }, !0 );

        return a => {
          let d;
          ( a = !0 === a ) && ( g = 33 ), b || ( b = !0, d = e - ( f.now() - c ), d < 0 && ( d = 0 ), a || d < 9 ? i() : k( i, d ) );
        };
      },
      C = a => {
        let b;
        let c;
        const d = 99;

        const e = () => {
          b = null, a();
        };

        const g = () => {
          const a = f.now() - c;
          a < d ? k( g, d - a ) : ( m || e )( e );
        };

        return () => {
          c = f.now(), b || ( b = k( g, d ) );
        };
      },
      D = ( () => {
        let g;
        let m;
        let o;
        let p;
        let y;
        let D;
        let F;
        let G;
        let H;
        let I;
        let J;
        let K;
        const L = /^img$/i;
        const M = /^iframe$/i;
        const N = "onscroll" in a && !/(gle|ing)bot/.test( navigator.userAgent );
        const O = 0;
        let P = 0;
        let Q = 0;
        let R = -1;

        const S = a => {
          Q--, ( !a || Q < 0 || !a.target ) && ( Q = 0 );
        };

        const T = a => {
          return null == K && ( K = "hidden" == x( b.body, "visibility" ) ), K || !( "hidden" == x( a.parentNode, "visibility" ) && "hidden" == x( a, "visibility" ) );
        };

        const U = ( a, c ) => {
          let d, f = a, g = T( a );
          for ( G -= c, J += c, H -= c, I += c; g && ( f = f.offsetParent ) && f != b.body && f != e; )
            ( g = ( x( f, "opacity" ) || 1 ) > 0 ) && "visible" != x( f, "overflow" ) && ( d = f.getBoundingClientRect(), g = I > d.left && H < d.right && J > d.top - 1 && G < d.bottom + 1 );
          return g;
        };

        const V = () => {
          let a;
          let f;
          let h;
          let j;
          let k;
          let l;
          let n;
          let o;
          let q;
          let r;
          let s;
          let t;
          const u = c.elements;
          if ( ( p = d.loadMode ) && Q < 8 && ( a = u.length ) ) {
            for ( f = 0, R++; f < a; f++ )
              if ( u[ f ] && !u[ f ]._lazyRace )
                if ( !N || c.prematureUnveil && c.prematureUnveil( u[ f ] ) )
                  ba( u[ f ] );
                else if ( ( o = u[ f ][ i ]( "data-expand" ) ) && ( l = 1 * o ) || ( l = P ), r || ( r = !d.expand || d.expand < 1 ? e.clientHeight > 500 && e.clientWidth > 500 ? 500 : 370 : d.expand, c._defEx = r, s = r * d.expFactor, t = d.hFac, K = null, P < s && Q < 1 && R > 2 && p > 2 && !b.hidden ? ( P = s, R = 0 ) : P = p > 1 && R > 1 && Q < 6 ? r : O ), q !== l && ( D = innerWidth + l * t, F = innerHeight + l, n = -1 * l, q = l ), h = u[ f ].getBoundingClientRect(), ( J = h.bottom ) >= n && ( G = h.top ) <= F && ( I = h.right ) >= n * t && ( H = h.left ) <= D && ( J || I || H || G ) && ( d.loadHidden || T( u[ f ] ) ) && ( m && Q < 3 && !o && ( p < 3 || R < 4 ) || U( u[ f ], l ) ) ) {
                  if ( ba( u[ f ] ), k = !0, Q > 9 )
                    break;
                } else
                  !k && m && !j && Q < 4 && R < 4 && p > 2 && ( g[ 0 ] || d.preloadAfterLoad ) && ( g[ 0 ] || !o && ( J || I || H || G || "auto" != u[ f ][ i ]( d.sizesAttr ) ) ) && ( j = g[ 0 ] || u[ f ] );
            j && !k && ba( j );
          }
        };

        const W = B( V );

        const X = a => {
          const b = a.target;
          if ( b._lazyCache )
            return void delete b._lazyCache;
          S( a ), s( b, d.loadedClass ), t( b, d.loadingClass ), u( b, Z ), v( b, "lazyloaded" );
        };

        const Y = A( X );

        const Z = a => {
          Y( {
            target: a.target
          } );
        };

        const $ = ( a, b ) => {
          try {
            a.contentWindow.location.replace( b );
          } catch ( c ) {
            a.src = b;
          }
        };

        const _ = a => {
          let b;
          const c = a[ i ]( d.srcsetAttr );
          ( b = d.customMedia[ a[ i ]( "data-media" ) || a[ i ]( "media" ) ] ) && a.setAttribute( "media", b ), c && a.setAttribute( "srcset", c );
        };

        const aa = A( ( a, b, c, e, f ) => {
          let g, h, j, l, m, p;
          ( m = v( a, "lazybeforeunveil", b ) ).defaultPrevented || ( e && ( c ? s( a, d.autosizesClass ) : a.setAttribute( "sizes", e ) ), h = a[ i ]( d.srcsetAttr ), g = a[ i ]( d.srcAttr ), f && ( j = a.parentNode, l = j && n.test( j.nodeName || "" ) ), p = b.firesLoad || "src" in a && ( h || g || l ), m = {
            target: a
          }, s( a, d.loadingClass ), p && ( clearTimeout( o ), o = k( S, 2500 ), u( a, Z, !0 ) ), l && q.call( j.getElementsByTagName( "source" ), _ ), h ? a.setAttribute( "srcset", h ) : g && !l && ( M.test( a.nodeName ) ? $( a, g ) : a.src = g ), f && ( h || l ) && w( a, {
            src: g
          } ) ), a._lazyRace && delete a._lazyRace, t( a, d.lazyClass ), z( () => {
            const b = a.complete && a.naturalWidth > 1;
            p && !b || ( b && s( a, "ls-is-cached" ), X( m ), a._lazyCache = !0, k( () => {
              "_lazyCache" in a && delete a._lazyCache;
            }, 9 ) ), "lazy" == a.loading && Q--;
          }, !0 );
        } );

        const ba = a => {
          if ( !a._lazyRace ) {
            let b;
            const c = L.test( a.nodeName );
            const e = c && ( a[ i ]( d.sizesAttr ) || a[ i ]( "sizes" ) );
            const f = "auto" == e;
            ( !f && m || !c || !a[ i ]( "src" ) && !a.srcset || a.complete || r( a, d.errorClass ) || !r( a, d.lazyClass ) ) && ( b = v( a, "lazyunveilread" ).detail, f && E.updateElem( a, !0, a.offsetWidth ), a._lazyRace = !0, Q++, aa( a, b, f, e, c ) );
          }
        };

        const ca = C( () => {
          d.loadMode = 3, W();
        } );

        const da = () => {
          3 == d.loadMode && ( d.loadMode = 2 ), ca();
        };

        const ea = () => {
          if ( !m ) {
            if ( f.now() - y < 999 )
              return void k( ea, 999 );
            m = !0, d.loadMode = 3, W(), j( "scroll", da, !0 );
          }
        };

        return {
          _ () {
            y = f.now(), c.elements = b.getElementsByClassName( d.lazyClass ), g = b.getElementsByClassName( d.lazyClass + " " + d.preloadClass ), j( "scroll", W, !0 ), j( "resize", W, !0 ), j( "pageshow", a => {
              if ( a.persisted ) {
                const c = b.querySelectorAll( "." + d.loadingClass );
                c.length && c.forEach && l( () => {
                  c.forEach( a => {
                    a.complete && ba( a );
                  } );
                } );
              }
            } ), a.MutationObserver ? new MutationObserver( W ).observe( e, {
              childList: !0,
              subtree: !0,
              attributes: !0
            } ) : ( e[ h ]( "DOMNodeInserted", W, !0 ), e[ h ]( "DOMAttrModified", W, !0 ), setInterval( W, 999 ) ), j( "hashchange", W, !0 ), [ "focus", "mouseover", "click", "load", "transitionend", "animationend" ].forEach( a => {
              b[ h ]( a, W, !0 );
            } ), /d$|^c/.test( b.readyState ) ? ea() : ( j( "load", ea ), b[ h ]( "DOMContentLoaded", W ), k( ea, 2e4 ) ), c.elements.length ? ( V(), z._lsFlush() ) : W();
          },
          checkElems: W,
          unveil: ba,
          _aLSL: da
        };
      } )(),
      E = ( () => {
        let a;

        const c = A( ( a, b, c, d ) => {
          let e, f, g;
          if ( a._lazysizesWidth = d, d += "px", a.setAttribute( "sizes", d ), n.test( b.nodeName || "" ) )
            for ( e = b.getElementsByTagName( "source" ), f = 0, g = e.length; f < g; f++ )
              e[ f ].setAttribute( "sizes", d );
          c.detail.dataAttr || w( a, c.detail );
        } );

        const e = ( a, b, d ) => {
          let e;
          const f = a.parentNode;
          f && ( d = y( a, f, d ), e = v( a, "lazybeforesizes", {
            width: d,
            dataAttr: !!b
          } ), e.defaultPrevented || ( d = e.detail.width ) && d !== a._lazysizesWidth && c( a, f, e, d ) );
        };

        const f = () => {
          let b;
          const c = a.length;
          if ( c )
            for ( b = 0; b < c; b++ )
              e( a[ b ] );
        };

        const g = C( f );
        return {
          _ () {
            a = b.getElementsByClassName( d.autosizesClass ), j( "resize", g );
          },
          checkElems: g,
          updateElem: e
        };
      } )(),
      F = () => {
        !F.i && b.getElementsByClassName && ( F.i = !0, E._(), D._() );
      };
    return k( () => {
      d.init && F();
    } ), c = {
      cfg: d,
      autoSizer: E,
      loader: D,
      init: F,
      uP: w,
      aC: s,
      rC: t,
      hC: r,
      fire: v,
      gW: y,
      rAF: z
    };
  } );
}

