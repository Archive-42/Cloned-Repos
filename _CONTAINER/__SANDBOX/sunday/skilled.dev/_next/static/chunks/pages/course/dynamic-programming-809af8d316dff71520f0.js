_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[67],{"4MTN":function(e,a,t){"use strict";t.r(a),t.d(a,"__N_SSG",(function(){return x}));var n=t("wx14"),o=t("q1tI"),i=t("NoRJ"),s=t("Qovc"),l=t("ekJs"),r={segments:[{name:"Introduction",startTimeSeconds:0,endTimeSeconds:84},{name:"Dynamic Program Defined",startTimeSeconds:84,endTimeSeconds:214},{name:"Visualize Dynamic Programming",startTimeSeconds:214,endTimeSeconds:479},{name:"Keys to Dynamic Programming",startTimeSeconds:479,endTimeSeconds:586},{name:"Top-Down Dynamic Programming",startTimeSeconds:586,endTimeSeconds:901},{name:"Bottom-Up Dynamic Programming",startTimeSeconds:901,endTimeSeconds:1119},{name:"DP Example: Coin Change Problem",startTimeSeconds:1119,endTimeSeconds:1450},{name:"DP Example: Knapsack Problem",startTimeSeconds:1450,endTimeSeconds:1708},{name:"Summary",startTimeSeconds:1708,endTimeSeconds:1806}]},c=t("Ff2n"),m=t("7ljp"),u=t("YFqc"),p=t.n(u),h=t("uk0T"),b=t("93Pr"),d=t("gWsq"),g=t("jDXR"),w=t("Ydbm"),f=t("jkan"),v=t("SFdv"),y=t("2tul"),j=t("+uJx"),O=t("HGY8"),N={};function k(e){var a=e.components,t=Object(c.a)(e,["components"]);return Object(m.a)("wrapper",Object(n.a)({},N,t,{components:a,mdxType:"MDXLayout"}),Object(m.a)(b.b,{mdxType:"Section"},Object(m.a)("p",null,"Dynamic programming is one of the most misunderstood and feared topics for programming interviews.\nMost explanations use complex terminology and jargon instead of defining the process simply.\nHere, we'll start from the most basic ideas stated in simple English and build up from that."),Object(m.a)("p",null,"Dynamic programming takes time and practice, so work through this lesson, answer the interview questions, and it will eventually click."),Object(m.a)("blockquote",null,Object(m.a)("p",{parentName:"blockquote"},"As we work through this article, we'll integreate some of the common terminology like ",Object(m.a)(p.a,{href:"/".concat(h.b.Course,"/subproblems-and-overlapping-subproblems"),passHref:!0,mdxType:"Link"},Object(m.a)("a",null,"subproblem")),", ",Object(m.a)(p.a,{href:"/".concat(h.b.Course,"/memoization"),passHref:!0,mdxType:"Link"},Object(m.a)("a",null,"memoization")),", and ",Object(m.a)(p.a,{href:"/".concat(h.b.Course,"/bottom-up-vs-top-down"),passHref:!0,mdxType:"Link"},Object(m.a)("a",null,"top-down vs. bottom-up")),",\nso make sure you have completed those sections first so that this lesson is more clear.\nYou may notice this article looks similar to those previous lessons, and that's because it is.\nWe've already learned all the core concepts for dynamic programming, and this article just ties them together to provide the complete picture.")),Object(m.a)("p",null,Object(m.a)("strong",{parentName:"p"},"Dynamic programming is an optimization."),"\nAfter we calculate a piece of a solution, we store it in a data structure so we can use it later instead of performing the calculation again."),Object(m.a)("p",null,"Let's re-define dynamic programming so it matches how it's used in interview questions."),Object(m.a)("p",null,'"Dynamic programming": Breaking a problem into small increments and solving each as its own step and storing the results for each step in a data structure (often a hash table or array).\nOnce you have all the steps solved, you can combine them to calculate the answer.'),Object(m.a)("p",null,Object(m.a)("strong",{parentName:"p"},"Dynamic programming often means calculating ALL the values for ALL steps to reach the desired solution"),".\nWe store the result of each subproblem so it only needs to be calculated once, which is the key to dynamic programming.\nWhile it might sound inefficient to use all the values at all the steps, oftentimes it is the only way.\nThe optimization is that we store the results of each step so we only perform each calculation once when we have the overlapping subproblems."),Object(m.a)("p",null,"The keys to dynamic programming:"),Object(m.a)("ol",null,Object(m.a)("li",{parentName:"ol"},Object(m.a)("strong",{parentName:"li"},"There are subproblems"),": we can solve the same problem repeatedly with different input values and combine them to calculate the solution"),Object(m.a)("li",{parentName:"ol"},Object(m.a)("strong",{parentName:"li"},"The subproblems are overlapping"),": the algorithm requires the solution from a subproblem using the same input value multiple times"),Object(m.a)("li",{parentName:"ol"},Object(m.a)("strong",{parentName:"li"},"We can memoize the results of overlapping subproblems to remove duplicate work"),": after calculating the solution to a subproblem with a given input, we store its result in a data structure (often a hash table or array)")),Object(m.a)("p",null,"With dynamic programming, each subproblem is a decision.\nAt each point, we consider the current value and the solutions to the subproblems we previously calculated.\nThen we make the best choice to solve the current subproblem given the data available to get the local solution at each step.\nOnce we have solved the problem at each step, we will have calculated our overall solution."),Object(m.a)("p",null,Object(m.a)("strong",{parentName:"p"},"The key to dynamic programming is learning to think in subproblems"),", and this comes with practice.\nDon't memorize tables or recursive trees.\nLearn to think about solving the problem in steps using the same logic at each increment but with different input values.\nThen just store the answer in a data structure so you don't have to repeat the calculations again.\nYou look backward in the data structure and utilize previously calculated solutions.")),Object(m.a)(b.b,{mdxType:"Section"},Object(m.a)(g.a,{mdxType:"SubsectionHeader"},"Dynamic Programming Example"),Object(m.a)("p",null,"Let's take calculating a Fibonacci number as an example for dynamic programming.\nAny given Fibonacci number is defined as the sum of the two numbers that come before it in the sequence.\nSo the 100th Fibonacci number is the 99th + 98th ",Object(m.a)("inlineCode",{parentName:"p"},"fib(100) = fib(99) + fib(98)"),".\nBut to find the 99th and 98th, we must find the two numbers before each of those."),Object(m.a)("p",null,"So to find the value of the 100th Fibonacci number, we find the value of all 99 Fibonacci numbers before it.\nEach calculation introduces overlapping subproblems because each number is used multiple times to calculate any given Fibonacci number.\nFinding the value of these 99 numbers step-by-step and using memoization to remove the duplicate calculations is exactly how dynamic programming works."),Object(m.a)("p",null,"The key is storing the result calculated in each step.\n",Object(m.a)("inlineCode",{parentName:"p"},"fib(100) = fib(99) + fib(98)"),", but ",Object(m.a)("inlineCode",{parentName:"p"},"fib(99) = fib(98) + fib(97)"),".\nSo both ",Object(m.a)("inlineCode",{parentName:"p"},"fib(100)")," and ",Object(m.a)("inlineCode",{parentName:"p"},"fib(99)")," each need ",Object(m.a)("inlineCode",{parentName:"p"},"fib(98)"),", so we only need to calculate ",Object(m.a)("inlineCode",{parentName:"p"},"fib(98)")," once and then we can reuse its value when needed.\nWe do this for all values that we calculate in the Fibonacci sequence so we solve each step only once."),Object(m.a)("p",null,"Dynamic programming can be used in either top-down or bottom-up algorithms.\nIn either case, we use a data structure (often a hash table or array) to store the results as we build our solution."),Object(m.a)("p",null,"With top-down, we store the result of a recursive function call for a given input.\nThe key in the hash table is the function input, and the value for the key in the hash table is the result returned from the recursive function for that input."),Object(m.a)("p",null,"With bottom-up, we start with the smallest value and build up our hash table as we continue to solve each step.\nThe bottom-up approach uses previously calculated values stored in the hash table to determine the current value.\nThis repeats until you reach the solution."),Object(m.a)("blockquote",null,Object(m.a)("p",{parentName:"blockquote"},"Dynamic programming is only an optimization when you have overlapping subproblems and storing the value for each step removes duplicate work.\nIf there are no overlapping subproblems, then storing the result for each step is likely unnecessary (and could incur unneeded space complexity) because you will only be required to calcualte that step once to find the solution.\nYou can use a standard recursive or iterative solution without dynamic programming to solve the question.")),Object(m.a)("p",null,"Let's consider Fibonacci with a top-down and bottom-up dynamic programming solution.\nIt is important to note that the approach and way we think about it doesn't change \u2014 we break the question into subproblems and solve each with different input values.\nAll that changes is the implementation in either starting at the smallest value and working up, or starting at the largest value and working down."),Object(m.a)("h3",null,"Top-Down Fibonacci Dynamic Programming"),Object(m.a)("p",null,"Many developers find dynamic programming to be easier to grasp by using recursion since we more explicitly declare the subproblems.\nWe go top-down by starting with the desired result and solving subproblems recursively by changing the input until we reach the base case.\nOnce we have the base case, we start building the solution up until we reach our initial function call."),Object(m.a)("p",null,"For example, with the Fibonacci, we calculate it recursively as the following:"),Object(m.a)(v.a,{mdxType:"FibBasic"}),Object(m.a)("p",null,"So if we're specifically talking about dynamic programming implemented recursively, we could define it as:\nsolving a problem recursively and storing the results of recursive calls in a data structure so you don't call a function again with the same parameters more than once.\nWith a top-down approach, we can simply think of dynamic programming as just an optimization on top of recursion by using memoization."),Object(m.a)(y.a,{mdxType:"FibMemo"}),Object(m.a)("p",null,"If we have overlapping subproblems, all we're really saying is that different recursive calls need a result from the same recursive function.\nFor example, think of calculating the 5th Fibonacci number."),Object(m.a)(d.h,{mdxType:"Container"},Object(m.a)("pre",{className:"language-javascript"},Object(m.a)("code",{parentName:"pre",className:"language-javascript"},Object(m.a)("span",{parentName:"code",className:"token function"},"fib"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},"("),Object(m.a)("span",{parentName:"code",className:"token number"},"7"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},")")," ",Object(m.a)("span",{parentName:"code",className:"token operator"},"=")," ",Object(m.a)("span",{parentName:"code",className:"token function"},"fib"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},"("),Object(m.a)("span",{parentName:"code",className:"token number"},"6"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},")"),"   ",Object(m.a)("span",{parentName:"code",className:"token operator"},"+"),"   ",Object(m.a)("span",{parentName:"code",className:"token function"},"fib"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},"("),Object(m.a)("span",{parentName:"code",className:"token number"},"5"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},")"),"\n        ",Object(m.a)("span",{parentName:"code",className:"token operator"},"/"),"      \\     ",Object(m.a)("span",{parentName:"code",className:"token operator"},"/"),"      \\\n       ",Object(m.a)("span",{parentName:"code",className:"token function"},"f"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},"("),Object(m.a)("span",{parentName:"code",className:"token number"},"5"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},")")," ",Object(m.a)("span",{parentName:"code",className:"token operator"},"+")," ",Object(m.a)("span",{parentName:"code",className:"token function"},"f"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},"("),Object(m.a)("span",{parentName:"code",className:"token number"},"4"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},")"),"  ",Object(m.a)("span",{parentName:"code",className:"token function"},"f"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},"("),Object(m.a)("span",{parentName:"code",className:"token number"},"4"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},")")," ",Object(m.a)("span",{parentName:"code",className:"token operator"},"+")," ",Object(m.a)("span",{parentName:"code",className:"token function"},"f"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},"("),Object(m.a)("span",{parentName:"code",className:"token number"},"3"),Object(m.a)("span",{parentName:"code",className:"token punctuation"},")"),"\n"))),Object(m.a)("p",null,"To calculate ",Object(m.a)("inlineCode",{parentName:"p"},"fib(7)")," we need ",Object(m.a)("inlineCode",{parentName:"p"},"fib(6)")," and ",Object(m.a)("inlineCode",{parentName:"p"},"fib(5)"),", but to calculate ",Object(m.a)("inlineCode",{parentName:"p"},"fib(6)")," we also need ",Object(m.a)("inlineCode",{parentName:"p"},"fib(5)"),".\nIn addition, both ",Object(m.a)("inlineCode",{parentName:"p"},"fib(6)")," and ",Object(m.a)("inlineCode",{parentName:"p"},"fib(5)")," need the result from ",Object(m.a)("inlineCode",{parentName:"p"},"fib(4)")," to calculate their values.\nThese are overlapping subproblems, and we use memoization to store the result of function calls so they don't have to be recursively calculated each time."),Object(m.a)("p",null,"Fibonacci without memoization requires ~",Object(m.a)(w.a.bin,null)," time complexity.\nWith ",Object(m.a)("inlineCode",{parentName:"p"},"n = 7"),", we have over 40 operations."),Object(m.a)(f.a,{src:"/images/memofib.png",isVisuAlgo:!0,mdxType:"Image"}),Object(m.a)("p",null,"With dynamic programming, we memoize the results and build up a table that we can read from to get previously calculated values instead of recalculating them and introducing duplicate work.\nSo as we calculate a value in the Fibonacci sequence, we can store its result in a hash table:"),Object(m.a)(f.a,{src:"/images/fib-memo-table.png",mdxType:"Image"}),Object(m.a)("p",null,"Or in code:"),Object(m.a)(j.a,{mdxType:"MemoHashTable"}),Object(m.a)("p",null,"When we read the memoized results from the hash table, it allows us to reduce the Fibonacci calculation to ",Object(m.a)(w.a.n,null)," time by adding ",Object(m.a)(w.a.n,null)," space.\nWe remove the duplicate work and only perform the calculations shown in the image below.\nThe blue nodes are when we read from the memoization table for a value that was previously calculated."),Object(m.a)(f.a,{src:"/images/memofib-unused-hidden.png",isVisuAlgo:!0,mdxType:"Image"}),Object(m.a)("p",null,"That's really all there is to it.\nIf you can feel comfortable with recursive thinking and understand how to store data in another data structure,\nyou can tackle almost any dynamic programming question.\nNot only that, they can even become very easy for you."),Object(m.a)("h3",null,"Bottom-Up Fibonacci Dynamic Programming"),Object(m.a)("p",null,"Any question that can be solved recursively can also be solved iteratively.\nRecursion is just a simple way to think about how to break a problem into smaller subproblems.\nSolving a problem recursively is called a top-down approach and solving a problem iteratively is called a bottom-up approach."),Object(m.a)("p",null,"With bottom-up Fibonacci, we start at the smallest values we know and build up our hash table again and calculate the current value using the previous two values until we reach our solution.\nAgain, we're using memoization and solving subproblems to get our answer."),Object(m.a)(O.a,{mdxType:"FibonacciBottomUp"}),Object(m.a)("p",null,"At each iteration of the loop, we are solving a subproblem.\nWe calculate the current Fibonacci number by looking backward in the memoization data structure and use the result from previous subproblems where we calculated prior Fibonacci numbers."),Object(m.a)("p",null,"Using a data structure is actually not required to calculate a solution for bottom-up Fibonacci since we can just store the previous two Fibonacci numbers in variables.\nHowever, very often in dynamic programming bottom-up solutions, you will need to construct a full table like this to solve your subproblems efficiently.")),Object(m.a)(b.b,{mdxType:"Section"},Object(m.a)(g.a,{mdxType:"SubsectionHeader"},"Dynamic Programming in Interviews"),Object(m.a)("p",null,"Enough with the Fibonacci, am I right?\nLet's take a look at some common examples of dynamic programming and classic DP questions."),Object(m.a)("h3",null,"Knapsack Problem"),Object(m.a)("p",null,"The knapsack problem is a classic dynamic programming interview question.\nWe have a list of items, and each item has a weight and value.\nYou want to find the largest value from any combination of items while keeping the weight below a certain threshold."),Object(m.a)("p",null,"You iterate through all the items.\nThen go from 0 to the max weight for each item and determine which item is best to keep at each point.\nSo we have subproblems where try each item at each weight.\nWe memoize the solution to each subproblem, and then as we try the new item combinations, we use the previously calculated optimal solutions and test it against the current item and keep the combination that provides maximum value while staying under the allowed weight."),Object(m.a)("p",null,"With dynamic programming, each point is a decision.\nWe make the optimal choice based on the current input and previously calculated solutions to subproblems.\nHere we decide at each step if we should keep the current item or use a previous item to produce the maximum combined item value."),Object(m.a)("p",null,"This allows us to build up our solution, and once we have tried all the item combinations at all the weights, we will have solved the problem."),Object(m.a)(f.a,{src:"/images/knapsack.png",mdxType:"Image"}),Object(m.a)("h3",null,"Coin Change"),Object(m.a)("p",null,"There are a few ways to ask this question, but they all revolve around combining various change denominations.\nIn this course, we have a ",Object(m.a)("a",{target:"_blank",href:"/course/vending-machine"},"similar question")," where you find the minimum number of coins required to calculate a target value from available denominations."),Object(m.a)("p",null,"We solve this by starting at zero and finding the minimum coins to reach every value up to the desired ",Object(m.a)("inlineCode",{parentName:"p"},"target")," value.\nWe try every denomination at every value.\nAt each point, we keep the minimum number of coins required to reach the current value, and we determine this by using the minimum coins used to reach prior spots."),Object(m.a)("p",null,"Each step is a decision where we choose the denomination that will allow us to reach each current value with the fewest coins.\nBy finding the minimum coins to reach each value from 0 up to the ",Object(m.a)("inlineCode",{parentName:"p"},"target")," locally in each subproblem, we will have solved the problem globally once we reach the end."),Object(m.a)(f.a,{src:"/images/2-3-coins.png",mdxType:"Image"}),Object(m.a)("h3",null,"What Do They Have in Common?"),Object(m.a)("p",null,"Both of these examples follow the same pattern we see in dynamic programming.\nThey solve subproblems, which means at each point, we solve the problem locally for a given input and look at back previously calculated optimal subproblem solutions to make the best choice at the current step.\nWe use memoization to build up the answers to the subproblems.\nOnce we reach the end, we will have solved the problem globally and have the answer.")),Object(m.a)(b.b,{mdxType:"Section"},Object(m.a)(g.a,{mdxType:"SubsectionHeader"},"Summary"),Object(m.a)("p",null,"Dynamic programming is an optimization, and we use it when we have overlapping subproblems.\nWe use a data structure (often a hash table or array) to memoize the result of subproblems so we only perform the calculation for each input value only once."),Object(m.a)("p",null,"Each subproblem is just its own problem.\nWe find the best solution for this step based on the available information we have.\nEach subproblem is a decision, and we make the choice that will solve it optimally at this point.\nWe store this value which will be used later to find the answer to future subproblems.\nAfter solving each problem locally, once we reach the end, we have solved the problem globally and will have our answer."),Object(m.a)("p",null,"If there are subproblems but they aren't overlapping (ie. you need to calculate the solution to a subproblem only once),\nthen dynamic programming/memoization is not an improvement."),Object(m.a)("p",null,"To restate the introduction, the keys to dynamic programming:"),Object(m.a)("ol",null,Object(m.a)("li",{parentName:"ol"},Object(m.a)("strong",{parentName:"li"},"There are subproblems"),": we can solve the same problem repeatedly with different input values and combine them to calculate the solution"),Object(m.a)("li",{parentName:"ol"},Object(m.a)("strong",{parentName:"li"},"The subproblems are overlapping"),": the algorithm requires the solution from a subproblem using the same input value multiple times"),Object(m.a)("li",{parentName:"ol"},Object(m.a)("strong",{parentName:"li"},"We can memoize the results of overlapping subproblems to remove duplicate work"),": after calculating the solution to a subproblem with a given input, we store its result in a data structure (often a hash table or array)"))))}k.isMDXComponent=!0;var T=function(e){return o.createElement(l.a,Object(n.a)({},e,{Content:k,video:r}))},x=!0;a.default=Object(s.a)((function(e){return o.useEffect((function(){e.lesson&&"ACTIVE"===e.lesson.status||(window.location.href="/course")}),[e]),e.lesson&&"ACTIVE"===e.lesson.status?o.createElement(i.a,Object(n.a)({},e,{Component:T})):null}),{ssr:!1})},yw23:function(e,a,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/course/dynamic-programming",function(){return t("4MTN")}])}},[["yw23",0,1,4,6,5,9,12,11,13,14,15,18,17,2,3,7,8,10,16,19,20,36]]]);