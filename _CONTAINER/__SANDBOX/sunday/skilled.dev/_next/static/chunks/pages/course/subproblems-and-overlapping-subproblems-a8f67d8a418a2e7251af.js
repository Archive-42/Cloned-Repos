_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[106],{"7dQm":function(e,n,t){"use strict";var a=t("q1tI"),o=t("uqmq"),r=t("D+/m"),c=function(e){var n=e.fill,t=void 0===n?"currentColor":n,c=e.stroke,i=void 0===c?"currentColor":c,l=e.children;return a.createElement(o.b,null,a.createElement(r.a,{stroke:i,fill:t},l))};n.a=c},"D+/m":function(e,n,t){"use strict";t.d(n,"a",(function(){return r})),t.d(n,"b",(function(){return c}));var a=t("vOnD"),o=Object(a.d)(["svg{color:",";fill:",";}path{color:",";stroke:",";}"],(function(e){return e.theme.color.textPrimary}),(function(e){var n=e.fill;return void 0===n?"currentColor":n}),(function(e){return e.theme.color.textPrimary}),(function(e){var n=e.stroke;return void 0===n?"currentColor":n})),r=a.e.div.withConfig({componentId:"sc-145zq7y-0"})(["color:",";display:flex;justify-content:center;",";"],(function(e){return e.theme.color.textPrimary}),o),c=a.e.div.withConfig({componentId:"sc-145zq7y-1"})(["",";svg{width:100%;height:100%;}"],o)},Ydbm:function(e,n,t){"use strict";var a=t("q1tI"),o={constant:function(){return a.createElement("em",null,"O(1)")},n:function(e){var n=e.letter,t=void 0===n?"n":n;return a.createElement("em",null,"O(",t,")")},n2:function(e){var n=e.letter,t=void 0===n?"n":n,o=e.exponent,r=void 0===o?2:o;return a.createElement("em",null,"O(",t,a.createElement("sup",null,r),")")},logn:function(e){var n=e.letter,t=void 0===n?"n":n;return a.createElement("em",null,"O(log ",t,")")},nlogn:function(e){var n=e.letter,t=void 0===n?"n":n;return a.createElement("em",null,"O(",t," log ",t,")")},bin:function(e){var n=e.base,t=void 0===n?2:n,o=e.letter,r=void 0===o?"n":o;return a.createElement("em",null,"O(",t,a.createElement("sup",null,r),")")},factorial:function(e){var n=e.letter,t=void 0===n?"n":n;return a.createElement("em",null,"O(",t,"!)")}};n.a=o},jDXR:function(e,n,t){"use strict";var a=t("q1tI"),o=function(e){var n=e.children;return a.createElement("h2",null,n)};n.a=o},jkan:function(e,n,t){"use strict";var a=t("q1tI"),o=t("vOnD"),r=t("uqmq"),c=t("5nwr"),i=Object(o.e)(r.b).withConfig({componentId:"sc-1u1nk7e-0"})(["display:flex;justify-content:center;align-items:center;flex-direction:column;"]),l=o.e.img.withConfig({componentId:"sc-1u1nk7e-1"})(["border-radius:6px;max-width:",";","{max-width:100% !important;}"],(function(e){var n=e.maxWidth;return n?"".concat(n," !important"):"100%"}),Object(c.b)()),s=o.e.div.withConfig({componentId:"sc-1u1nk7e-2"})(["margin-top:4px;font-size:12px;color:",";text-align:center;width:100%;a,a:hover,a:visited{color:",";text-decoration:underline;}"],(function(e){return e.theme.color.textSecondary}),(function(e){return e.theme.color.textSecondary})),u=function(){return a.createElement("span",null,"Credit:"," ",a.createElement("a",{href:"https://visualgo.net/",target:"_blank",rel:"noopener noreferrer"},"VisuAlgo"))},p=function(e){var n=e.src,t=e.credit,o=e.isVisuAlgo,r=e.maxWidth;return a.createElement(i,null,a.createElement(l,{maxWidth:r,src:n}),!!t&&a.createElement(s,null,t),!!o&&a.createElement(s,null,a.createElement(u,null)))};n.a=p},oIXU:function(e,n,t){"use strict";t.r(n),t.d(n,"__N_SSG",(function(){return v}));var a=t("wx14"),o=t("q1tI"),r=t("NoRJ"),c=t("Qovc"),i=t("ekJs"),l={segments:[{name:"Introduction",startTimeSeconds:0,endTimeSeconds:46},{name:'Defining "Subproblem"',startTimeSeconds:46,endTimeSeconds:220},{name:"Subproblem Example: Factorial Function",startTimeSeconds:220,endTimeSeconds:360},{name:"Overlapping Subproblems Explained",startTimeSeconds:360,endTimeSeconds:456},{name:"Visualizing Overlapping Subproblems",startTimeSeconds:456,endTimeSeconds:533},{name:"Subproblems vs. Overlapping Subproblems",startTimeSeconds:533,endTimeSeconds:653}]},s=t("Ff2n"),u=t("7ljp"),p=t("YFqc"),m=t.n(p),b=t("jkan"),d=t("uk0T"),h=t("93Pr"),f=t("gWsq"),j=(t("7dQm"),t("jDXR"),t("Ydbm"),{});function g(e){var n=e.components,t=Object(s.a)(e,["components"]);return Object(u.a)("wrapper",Object(a.a)({},j,t,{components:n,mdxType:"MDXLayout"}),Object(u.a)(h.b,{mdxType:"Section"},Object(u.a)("p",null,"From my experience, resources that teach dynamic programming gloss over subproblems and assume you already know them (or perhaps don't know how to teach it).\nYou usually see a phrase like, \"If you recognize overlapping subproblems, it's a great opportunity for dynamic programming.\"\nHowever, without understanding what a subproblem is, you can't feel confident implementing dynamic programming or possibly even recursion."),Object(u.a)("h3",null,"Subproblems"),Object(u.a)("p",null,"I'll first define what a subproblem is, and then we'll walk through it step-by-step.\n",Object(u.a)("strong",{parentName:"p"},"Solving subproblems means we take a function and call it multiple times with different input values."),"\n",Object(u.a)("strong",{parentName:"p"},"We start with the smallest value and build up to the largest (bottom-up) or recursively decrease the input from the largest value down to the smallest (top-down) until we reach the base.\nThen we combine the results of all the function calls to calculate the solution.")),Object(u.a)("p",null,"We previously saw that we could ",Object(u.a)(m.a,{href:"/".concat(d.b.Course,"/recursion"),passHref:!0,mdxType:"Link"},Object(u.a)("a",null,"recursively solve for the factorial"))," for any number ",Object(u.a)("inlineCode",{parentName:"p"},"n!"),".\nIt took the following form (ignoring the base case for now):"),Object(u.a)(f.h,{mdxType:"Container"},Object(u.a)("pre",{className:"language-javascript"},Object(u.a)("code",{parentName:"pre",className:"language-javascript"},Object(u.a)("span",{parentName:"code",className:"token function"},"factorial"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},"("),"n",Object(u.a)("span",{parentName:"code",className:"token punctuation"},")")," ",Object(u.a)("span",{parentName:"code",className:"token operator"},"=")," n ",Object(u.a)("span",{parentName:"code",className:"token operator"},"*")," ",Object(u.a)("span",{parentName:"code",className:"token function"},"factorial"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},"("),"n ",Object(u.a)("span",{parentName:"code",className:"token operator"},"-")," ",Object(u.a)("span",{parentName:"code",className:"token number"},"1"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},")"),"\n"))),Object(u.a)("p",null,"What we did was recognize a subproblem.\nTo find the factorial of any number ",Object(u.a)("inlineCode",{parentName:"p"},"n"),", you can multiply ",Object(u.a)("inlineCode",{parentName:"p"},"n * (n - 1)!"),".\nAnd then this repeated because ",Object(u.a)("inlineCode",{parentName:"p"},"(n - 1)! = (n - 1) * (n - 2)!"),".\nSo you need the number before the current ",Object(u.a)("inlineCode",{parentName:"p"},"n")," to find the solution, but then you need the number before ",Object(u.a)("inlineCode",{parentName:"p"},"n - 1")," to solve for that number.\nThis logic continues until you reach the base case."),Object(u.a)("p",null,"The image below is a visual for factorial recursion.\nEach of the steps where you change the input the value to ",Object(u.a)("inlineCode",{parentName:"p"},"factorial")," is solving a different subproblem.\nYou combine them by multiplying each current number by the result of the subproblem before it to eventually calculate ",Object(u.a)("inlineCode",{parentName:"p"},"4!"),"."),Object(u.a)(b.a,{src:"/images/recursion-demo.gif",mdxType:"Image"}),Object(u.a)("p",null,"So to explicitly state what's happening, we can say ",Object(u.a)("inlineCode",{parentName:"p"},"4! = 4 * 3!")," which is ",Object(u.a)("inlineCode",{parentName:"p"},"4! = 4 * 3 * 2!")," which is ",Object(u.a)("inlineCode",{parentName:"p"},"4! = 4 * 3 * 2 * 1"),"."),Object(u.a)("p",null,"You repeat the same logic over and over from the base case up to the ",Object(u.a)("inlineCode",{parentName:"p"},"n!")," you're looking for.\nThe only thing that changes is the input value at each step.\nThe solution for each step is returned to the function call that invoked it, and this function can then use this result to calculate the solution to its own subproblem.\nBy building up the results to each subproblem, we can eventually calculate ",Object(u.a)("inlineCode",{parentName:"p"},"n!")," of the original function invocation."),Object(u.a)("p",null,"If we wanted to calculate ",Object(u.a)("inlineCode",{parentName:"p"},"factorial(1000)"),", we don't need to actually know what ",Object(u.a)("inlineCode",{parentName:"p"},"factorial(999)")," and ",Object(u.a)("inlineCode",{parentName:"p"},"factorial(998)")," are.\nBy specifying the correct base case and recursive case, the result of all the preceding subproblems will produce the solution we need."),Object(u.a)("h3",null,"Overlapping Subproblems"),Object(u.a)("p",null,"Up to this point in this article, we haven't discussed ",Object(u.a)("em",{parentName:"p"},"overlapping")," subproblems, because there aren't any with the factorial function.\nThey are all subproblems called with unique values."),Object(u.a)("p",null,"For overlapping subproblems to occur, our function will be called with the same input value multiple times.\nThis most often happens when we have ",Object(u.a)("strong",{parentName:"p"},"more than one recursive call in a recursive function"),"."),Object(u.a)("p",null,"For example, the logic for finding a Fibonacci number is the following:"),Object(u.a)(f.h,{mdxType:"Container"},Object(u.a)("pre",{className:"language-javascript"},Object(u.a)("code",{parentName:"pre",className:"language-javascript"},Object(u.a)("span",{parentName:"code",className:"token function"},"fib"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},"("),"n",Object(u.a)("span",{parentName:"code",className:"token punctuation"},")")," ",Object(u.a)("span",{parentName:"code",className:"token operator"},"=")," ",Object(u.a)("span",{parentName:"code",className:"token function"},"fib"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},"("),"n ",Object(u.a)("span",{parentName:"code",className:"token operator"},"-")," ",Object(u.a)("span",{parentName:"code",className:"token number"},"1"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},")")," ",Object(u.a)("span",{parentName:"code",className:"token operator"},"+")," ",Object(u.a)("span",{parentName:"code",className:"token function"},"fib"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},"("),"n ",Object(u.a)("span",{parentName:"code",className:"token operator"},"-")," ",Object(u.a)("span",{parentName:"code",className:"token number"},"2"),Object(u.a)("span",{parentName:"code",className:"token punctuation"},")"),"\n"))),Object(u.a)("p",null,"We have subproblems where we can calculate the Fibonacci number for any value ",Object(u.a)("inlineCode",{parentName:"p"},"n"),".\nSo then to calculate any given Fibonacci number, we just need the results of the Fibonacci numbers before it."),Object(u.a)("p",null,"We require two recursive function calls to calculate a number: ",Object(u.a)("inlineCode",{parentName:"p"},"fib(n - 1)")," and ",Object(u.a)("inlineCode",{parentName:"p"},"fib(n - 2)"),".\nSo if we wanted ",Object(u.a)("inlineCode",{parentName:"p"},"fib(100) = fib(99) + fib(98)"),",\nboth ",Object(u.a)("inlineCode",{parentName:"p"},"fib(99)")," and ",Object(u.a)("inlineCode",{parentName:"p"},"fib(98)")," would separately generate all the numbers ",Object(u.a)("inlineCode",{parentName:"p"},"fib(97)")," to ",Object(u.a)("inlineCode",{parentName:"p"},"fib(1)"),"\nbecause ",Object(u.a)("code",null,"fib(99) = fib(98) + ",Object(u.a)("strong",null,"fib(97)"))," and ",Object(u.a)("code",null,"fib(98) = ",Object(u.a)("strong",null,"fib(97)")," + fib(96)"),".\nEach step generates many more function calls, and we call ",Object(u.a)("inlineCode",{parentName:"p"},"fib")," with repeated input values many times.\nThis branches outward with each nested step continuing to do the same thing."),Object(u.a)("p",null,"If we look at ",Object(u.a)("inlineCode",{parentName:"p"},"fib(7)"),", we can see the repeated calculations:"),Object(u.a)(b.a,{src:"/images/memofib.png",isVisuAlgo:!0,mdxType:"Image"}),Object(u.a)("p",null,"The items highlighted in blue are repetitive functions calls that use the same input multiple times.\nThese are the ",Object(u.a)("strong",{parentName:"p"},"overlapping subproblems"),".\nWhen visualizing the recursive calls as a tree, the branching is a sign that we'll have subproblems that overlap."),Object(u.a)("p",null,"On the other hand, when calculating the factorial, we have subproblems, but we don't have overlapping subproblems.\nEvery time we call ",Object(u.a)("inlineCode",{parentName:"p"},"factorial"),", we pass it a new value that we haven't calculated the subproblem answer for.\nSo instead of creating a tree structure with branching, it simply forms a straight line."),Object(u.a)(b.a,{src:"/images/factorialstructure.png",mdxType:"Image"}),Object(u.a)("p",null,"When we have overlapping subproblems like in the Fibonacci example, this is when we are able to use dynamic programming.\nWith dynamic programming, we utilize ",Object(u.a)(m.a,{href:"/".concat(d.b.Course,"/memoization"),passHref:!0,mdxType:"Link"},Object(u.a)("a",null,"memoization"))," to store the results of these repeated steps so that we only solve each overlapping subproblem once.")))}g.isMDXComponent=!0;var O=function(e){return o.createElement(i.a,Object(a.a)({},e,{Content:g,video:l}))},v=!0;n.default=Object(c.a)((function(e){return o.useEffect((function(){e.lesson&&"ACTIVE"===e.lesson.status||(window.location.href="/course")}),[e]),e.lesson&&"ACTIVE"===e.lesson.status?o.createElement(r.a,Object(a.a)({},e,{Component:O})):null}),{ssr:!1})},tboh:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/course/subproblems-and-overlapping-subproblems",function(){return t("oIXU")}])},uqmq:function(e,n,t){"use strict";t.d(n,"b",(function(){return c})),t.d(n,"c",(function(){return i})),t.d(n,"a",(function(){return l}));var a=t("vOnD"),o=t("gWsq"),r=t("SOUA"),c=Object(a.e)(o.h).withConfig({componentId:"sc-16wjbcj-0"})(["margin-top:","px;"],r.a),i=Object(a.e)(c).withConfig({componentId:"sc-16wjbcj-1"})(["display:flex;justify-content:center;align-items:center;"]),l=a.e.div.withConfig({componentId:"sc-16wjbcj-2"})(["margin-top:","px;"],r.a)}},[["tboh",0,1,4,6,5,9,12,11,13,14,15,18,17,2,3,7,8,10,16,19,20]]]);